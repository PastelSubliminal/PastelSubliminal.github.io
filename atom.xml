<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>埃斯佩拉某处</title>
  
  <subtitle>刹那之拳的博客</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-11T11:51:33.280Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Zero_warmwine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Less和CSS的区别</title>
    <link href="http://example.com/2021/04/02/Less%E5%92%8CCSS%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://example.com/2021/04/02/Less%E5%92%8CCSS%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2021-04-01T16:00:01.000Z</published>
    <updated>2021-04-11T11:51:33.280Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Less和CSS介绍"><a href="#Less和CSS介绍" class="headerlink" title="Less和CSS介绍"></a>Less和CSS介绍</h1><p>Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。</p><p>LESS是一个 CSS 预处理器，可以为网站启用可自定义，可管理和可重用的样式表。LESS 是一种动态样式表语言，扩展了 CSS 的功能。 LESS 也是跨浏览器友好。</p><p>CSS预处理器是一种脚本语言，可扩展 CSS 并将其编译为常规 CSS 语法，以便可以通过 Web 浏览器读取。 它提供诸如变量，函数，mixins 和操作等功能，可以构建动态 CSS。</p><p>Less 允许我们定义变量，使用嵌套式声明，定义函数等。严格说 Less 包含两部分：（1）Less 的语法 （2）Less 预处理器。浏览器终究只认识 CSS，所以 Less 文件需要经过 Less 预处理器编译成为 CSS。</p><p>CSS：层叠样式表是一种用来表现 HTML（标准通用标记语言的一个应用）或 XML（标准通用标记语言的一个子集）等文件样式的计算机语言。</p><h1 id="二、Less与CSS区别总结"><a href="#二、Less与CSS区别总结" class="headerlink" title="二、Less与CSS区别总结"></a>二、Less与CSS区别总结</h1><p>1、Less 是一门 CSS 预处理语言，CSS 是一种用来表现 HTML 或 XML 等文件样式的计算机语言。</p><p>2、Less 扩展了 CSS 语言，增加了变量、Mixin、函数等特性。</p><p>3、CSS 可以被浏览器直接识别，Less 需要先编译为 CSS。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="HTML+CSS" scheme="http://example.com/tags/HTML-CSS/"/>
    
  </entry>
  
  <entry>
    <title>url编码及api的使用</title>
    <link href="http://example.com/2021/04/02/url%E7%BC%96%E7%A0%81%E5%8F%8Aapi%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/04/02/url%E7%BC%96%E7%A0%81%E5%8F%8Aapi%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-01T16:00:01.000Z</published>
    <updated>2021-04-11T11:54:48.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在因特网上传送 URL，只能采用 ASCII 字符集，即是常说的 get 请求只能使用 ASCII 字符。</p><p>也就是说 URL 只能使用字母和数字[0-9a-zA-Z]、一些特殊符号$-_.+!*’()[不包括双引号]、以及某些保留字（空格转换为+），才可以不经过编码直接用于 URL。</p><p>Javascript 中提供了3对函数用来对 url 编码以得到合法的 url，他们分别是</p><ul><li>escape / unescape</li><li>encodeURI / decodeURI</li><li>encodeURIComponent / decodeURIComponent</li></ul><p>这三个编码的函数——escape，encodeURI，encodeURIComponent——都是用于将不安全不合法的 Url 字符转换为合法的Url字符表示，它们有以下几个不同点。</p><ol><li><p>安全字符不同：<br>下面列出了这三个函数的安全字符（即函数不会对这些字符进行编码）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>（<span class="number">69</span>个）：    */@+-._0-<span class="number">9</span>a-zA-Z</span><br><span class="line"><span class="built_in">encodeURI</span>（<span class="number">82</span>个）：    !#$&amp;<span class="string">&#x27;()*+,/:;=?@-._~0-9a-zA-Z</span></span><br><span class="line"><span class="string">encodeURIComponent（71个）：    !&#x27;</span>()*-._~<span class="number">0</span>-<span class="number">9</span>a-zA-Z</span><br></pre></td></tr></table></figure></li><li><p>对 Unicode 字符的编码方式不同：<br>这三个函数对于 ASCII 字符的编码方式相同，均是使用百分号 + 两位十六进制字符来表示。但是对于 Unicode 字符，escape 的编码方式是 %uxxxx，其中的 xxxx 是用来表示 unicode 字符的4位十六进制字符。这种方式已经被 W3C 废弃了。但是在 ECMA-262 标准中仍然保留着 escape 的这种编码语法。encodeURI 和 encodeURIComponent 则使用UTF-8 对非 ASCII 字符进行编码，然后再进行百分号编码。这是 RFC 推荐的。因此建议尽可能的使用 <strong>encodeURI 和 encodeURIComponent</strong> 这两个函数替代 escape 进行编码。</p></li><li><p>适用场合不同：<br>encodeURI 被用作对一个完整的 URI 进行编码，而 encodeURIComponent 被用作对URI的一个组件进行编码。从上面提到的安全字符范围表格来看，我们会发现，encodeURIComponent 编码的字符范围要比 encodeURI 的大。</p></li></ol><h2 id="encodeURI-："><a href="#encodeURI-：" class="headerlink" title="encodeURI()："></a>encodeURI()：</h2><ul><li>encodeURI() 是 Javascript中真正用来对 URL 编码的函数。<br>它着眼于对整个URL进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp; = + $ , #”，也不进行编码。编码后，它输出符号的 utf-8 形式，并且在每个字节前加上%。</li></ul><h2 id="encodeURIComponent"><a href="#encodeURIComponent" class="headerlink" title="encodeURIComponent()"></a>encodeURIComponent()</h2><ul><li>它用于对 URL 的组成部分进行个别编码，而不用于对整个 URL 进行编码。<br>因此，”; / ? : @ &amp; = + $ , #”，这些在 encodeURI() 中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。</li></ul><h2 id="encodeURIComponent-和-encodeURI-的区别演示："><a href="#encodeURIComponent-和-encodeURI-的区别演示：" class="headerlink" title="encodeURIComponent() 和 encodeURI() 的区别演示："></a>encodeURIComponent() 和 encodeURI() 的区别演示：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURI</span>(<span class="string">&quot;?name=zhangsan&amp;age=21&quot;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURIComponent</span>(<span class="string">&quot;?name=zhangsan&amp;age=21&quot;</span>)) </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020080916202843.png" alt="Image text"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>开发中大部分情况下使用 encodeURI / decodeURI 和 encodeURIComponent / decodeURIComponent 完全可以了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS的作用域</title>
    <link href="http://example.com/2021/02/08/JS%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://example.com/2021/02/08/JS%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2021-02-07T16:00:00.000Z</published>
    <updated>2021-04-11T10:39:29.887Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>在介绍 JS 的作用域之前，先介绍一下编译原理。</p><p>JavaScript引擎进行编译的步骤和传统编译语言比较相似，但在某些环节比预想的复杂。</p><p>在传统的编译语言中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。</p><ul><li>分词/词法分析：将有字符组成的字符串分解成（对编程语言来说）有意义的代码块。</li><li>解析/语法分析：将词法单元流（数组）转换成一个有元素逐级嵌套所形成的代表了程序与法结构的树。这个数被称为“抽象语法树”（Abstract Syntax Tree, AST）。</li><li>代码生成：将 AST 转换为可执行代码的过程。</li></ul><h1 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h1><p>如 var a = 2，变量的复制操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能找到就对它进行赋值。</p><h2 id="LHS-和-RHS"><a href="#LHS-和-RHS" class="headerlink" title="LHS 和 RHS"></a>LHS 和 RHS</h2><p>引擎会为变量 a 进行 LHS 查询，另外一个查询的类型叫做 RHS。含义分别为 Left Hand Side 和 Right Hand Side。</p><p>即变量出现在复制操作左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。RHS 查询与简单的查找某个变量的值无异，LHS 则试图找到变量的容器本身。从而可以对其赋值。准确的说，所有“非左侧”都是 RHS。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>其中对 a 的引用是一个 RHS 引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这里对 a 的引用是一个 LHS 引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>最后一行 foo(2) 函数的调用需要对 foo 进行 RHS 引用<br>代码中隐式的 a = 2 的操作需要进行一次 LHS 查询<br>将得到的值传给 console.log()，需要对 a 进行一次 RHS 引用</p><h1 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h1><p>作用域是根据名称查找变凉的一套规则。当在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，知道找到该变量或抵达全局作用域为止。</p><p>LHS 和 RHS 引用都会在当前作用域进行查找，如果没有找到，就往上一层作用域，直到找到或者抵达全局作用域后停止查找。</p><p>如果 RHS 查询在所有嵌套的作用域中都找不到所需的变量，引擎就会抛出 ReferenceError 异常；如果 LHS 查询在全局作用域中也无法找到目标变量，则会隐式地在全局作用域创建这个变量（非严格模式下）并作为这次 LHS 查询的目标，或者抛出 ReferenceError。</p><p>如果试图对 RHS 查询到的变量的值进行不合理的操作，如调用非函数类型的值或引用 null 或 undefined 中的属性，则会抛出 TypeError。</p><p>ReferenceError 和作用域判别失败有关， TypeError 则是判别成功了，但是对结果的操作是非法的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6中的Set和Map数据结构</title>
    <link href="http://example.com/2021/01/28/ES6%E7%9A%84Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2021/01/28/ES6%E7%9A%84Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-01-27T16:00:00.000Z</published>
    <updated>2021-02-08T00:53:49.710Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>集合（Set）是由一组无序且唯一的项组成的，该数据结构使用了和有限集合相同的数学概念，但应用在计算机科学的数据结构中。</p><p>可以把集合想象成一个既没有重复元素，也没有顺序概念的数组</p><p>一些集合可用的方法：<br>add(element)：向集合添加一个新元素。<br>delete(element)：从集合移除一个元素。<br>has(element)：如果元素在集合中，返回 true ，否则返回 false。<br>clear()：移除集合中的所有元素。<br>size()：返回集合所包含元素的数量。它与数组的 length 属性类似。<br>keys()：返回一个包含集合中所有键名的数组。<br>values()：返回一个包含集合中所有值（元素）的数组。</p><p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例</span></span><br><span class="line">    <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">//2,3,5,4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</span></span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure><p>可以利用set没有重复的值这一特性, 实现数组去重<br>不考虑兼容性，这种去重的方法代码最少。但这种方法无法去掉“{}”空对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"> <span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;]</span></span><br></pre></td></tr></table></figure><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><p>为了解决这个问题，ES6 提供了 散列表（Map） 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;, <span class="number">1</span>], [<span class="string">&quot;aa&quot;</span>, <span class="number">2</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br></pre></td></tr></table></figure><p>一些散列表可用的基本方法，散列表也可以使用 Set 的方法：<br>put(key, value)：向散列表添加一个新的项（也能更新散列表）。<br>remove(key)：根据键值从散列表中移除值。<br>get(key)：返回根据键值检索到的特定的值。<br>entries()：返回散列表中的所有键值对。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ES6中的import as</title>
    <link href="http://example.com/2020/11/27/ES6%E4%B8%AD%E7%9A%84import%20as/"/>
    <id>http://example.com/2020/11/27/ES6%E4%B8%AD%E7%9A%84import%20as/</id>
    <published>2020-11-26T16:00:00.000Z</published>
    <updated>2021-04-11T10:39:16.581Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>import * as xxx from ‘xxx’  会将 “xxx” 中所有 export 导出的内容组合成一个对象返回(或import * as obj from ‘xx’  这种写法是把所有的输出包裹到obj对象里);</p><p>eg：</p><p>xxx里中：</p><p>export function test(){</p><pre><code>return &#39;返回是test 内容&#39;;</code></pre><p> }</p><p>export function login(){</p><pre><code>return &#39;返回login 内容&#39;;</code></pre><p> }</p><p>调用test 函数，即obj.test();</p><p>调用login 函数，即obj.login();</p><p>扩展：那不带*as(即import xxx from ‘xxx’)</p><p><img src="https://img1.sycdn.imooc.com/5c9458a3000186e409180058.jpg" alt="image text"></p><p><img src="https://img1.sycdn.imooc.com/5c946ada000142c421721538.jpg" alt="image text"></p><p>总结：</p><p>import * as xxx from ‘xxx’: 会将若干export导出的内容组合成一个对象返回；</p><p>import xxx from ‘xxx’：（export default Din）只会导出这个默认的对象作为一个对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>扫码点餐各个页面的制作过程</title>
    <link href="http://example.com/2020/11/15/%E6%89%AB%E7%A0%81%E7%82%B9%E8%8F%9C%E4%B8%80%E4%BA%9B%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2020/11/15/%E6%89%AB%E7%A0%81%E7%82%B9%E8%8F%9C%E4%B8%80%E4%BA%9B%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/</id>
    <published>2020-11-14T16:00:00.000Z</published>
    <updated>2021-04-11T10:37:38.782Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="扫码点餐各个页面是如何实现的"><a href="#扫码点餐各个页面是如何实现的" class="headerlink" title="扫码点餐各个页面是如何实现的"></a>扫码点餐各个页面是如何实现的</h1><h2 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h2><p>首先用到的模块是 ‘react-router-dom’ 的 withRouter 和封装好的 axios API。整个登录逻辑写在 withRouter中，在 jsx 里使用 ref 获得输入的用户名、密码、验证码，登录先 preventDefault 然后用户名密码验证码分别是 ref 获取到的当前输入值，使用 try-catch 用 post 请求发送给后端，如果成功就用 history.push 给 url 传值转跳页面，不然就 alert 后端设定好的错误信息。</p><h2 id="点餐界面："><a href="#点餐界面：" class="headerlink" title="点餐界面："></a>点餐界面：</h2><p>首先用到的模块是 ‘prop-types’，’immer’，’history’，’socket.io-client’。</p><p>菜单内容是一个函数组件，参数是 food，onupdate 和 amount，返回的 jsx 是一个菜单列表，列表里的每个菜都有按钮可以增减选择数量，使用 onupdate 来控制点击按钮时的菜品数量增减。<br>随后用到了 React 的属性验证功能 要求菜单内容这个函数组件必须要传参数且必须要传指定类型的参数。calTotaoPrice 是一个用 reduce 来计算下单总价的函数，初始值为 0 元。</p><p>购物车状态是一个函数组件，返回的 jsx 显示了当前下单总价，以及展开收起按钮，使用 useState 来控制是否展开，默认 false。</p><p>点餐主界面是一个类组件，state 里有三个属性：cart 数组里放当前点了的菜，foodMenu 数组里放当前提供可选的菜品列表，deskInfo 对象里是当前的餐桌号，顾客数，总价，点了的菜。</p><p>接下来是各个生命周期里做的事情：在 componentDidMount 中，首先用 props.match.params 拿到路由传递过来的参数 params，然后用 get 请求到当前餐桌 id 和菜单信息用 setState 设置为当前餐桌和当前菜单信息。为了同步同一餐桌不同用户间的点单，设置 socket 的路径和请求，在接入餐桌连接时用 socket.on 在 ‘cart food’ 时向后端发送字符串命令和餐桌 id。后端发回此桌面已点菜单，这里用到了 immer 的 produce：先定义一个变更，有数据时再执行这个变更，然后用 socket.on 在 ‘new food’ 时调用 foodChange 函数变更菜品和数量，下单成功时用 socket.on 在 ‘placeorder success’ 时用路由 push 点餐成功页面的路径并将订单状态设置为 order。componentWillUnmount 中关闭 socket 链接。</p><p>cartChange 函数用 socket.emit 在 ‘new food’ 时向后端发送当前餐桌 id，所点食物和数量。placeOrder 函数用于下单，用 post 请求向后端发送路径和当前订单信息后转跳到成功界面，state 设置为 res.data。</p><p>最后点餐主界面 render 了菜单列表，返回的菜单列表用 map 渲染，返回的是当前能点的菜的列表。</p><h2 id="菜品管理："><a href="#菜品管理：" class="headerlink" title="菜品管理："></a>菜品管理：</h2><p>列表中每个菜是一个函数组件，可以进行菜品的删改增查，使用了三个 hook 来管理状态：setFoodInfo、setIsModify、setFoodProps，默认分别是food、false、和属性是菜品各项信息的对象。save 函数 new 一个 FormDate 后将遍历到的菜品属性键值对插入进去，然后用 put 请求向后端放松当前菜品 id 和属性后将菜品信息设置为当前菜品信息。</p><p>change 和 imgChange 函数用于重新设置菜品信息，使用 setFoodProps 将菜品信息设置为当前传入事件参数的值即可。然后是菜品的删除、设置是否提供，用put请求向后端发送状态后使用 hook 变更菜品属性即可。最后 jsx 返回的是修改界面，根据是修改将对应的 html 样式返回即可。最后整个函数组件返回的是菜品展示图和一些功能按钮（修改、保存、下架、上架、删除）。</p><h2 id="订单管理："><a href="#订单管理：" class="headerlink" title="订单管理："></a>订单管理：</h2><p>首先用到的模块是 ‘socket.io-client’，’immer’ 和封装好的 axios API。订单状态用 hook 的 useState 管理。订单列表使用函数组件。</p><p>然后是实现各个逻辑的函数。使订单状态变为确认：用 put 请求向后端发送当前订单 id 的状态变更为 confirmed，然后用 setOrder 将订单的属性设置为当前属性为 confirmed，setComplete 同理。</p><p>删除订单则是直接向后端发送对应订单 id 的 delete 请求即可。最后订单列表返回显示总价格、人数、订单状态、打印、确认、完成、删除功能的 jsx。</p><p>订单管理使用类组件，state 为由 orders 组成的数组。</p><p>在订单管理的生命周期中，componentDidMount 首先获取参数，定义 socket 的路径和请求，在 on ‘connect’ 是向后端发送当前加入餐厅 id，在 on ‘new order’ 时发送在当前页面新增一个订单。用 get 请求获取当前订单。componentWillUnmount 中关闭 socket 连接，和删除订单的函数。最后 render 的是订单管理页面，根据订单长度 map 一个订单项列表。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>组件库的制作</title>
    <link href="http://example.com/2020/11/02/%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/"/>
    <id>http://example.com/2020/11/02/%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/</id>
    <published>2020-11-01T16:00:10.000Z</published>
    <updated>2021-04-11T10:39:05.438Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>提示，这里需要先学习一下Vue插件的API： <a href="https://cn.vuejs.org/v2/api/#Vue-use">https://cn.vuejs.org/v2/api/#Vue-use</a></p><p>在package.json中加一条命令，用于指定打包目标为库</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">       <span class="attr">&quot;lib&quot;</span>: <span class="string">&quot;vue-cli-service build --target lib packages/index.js&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令行输入 yarn lib<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEJTGN48rsMPNqepV548w.aV9yCjuYp5H*nXXXoZKA9OQcAEwBbHw6gozXNJsP3Bj03vyMNg8plvqrq.EVb1XGEc!/r" alt="image text"><br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEBfbeH.4zaLcWgHcrz4RpoL**GaE7I*bgaozV6IH8I7TX5KTg2xhcBQBejx.mi6v9OxZUOMOZFd*n4vUDp37*OU!/r" alt="image text"><br>打包完成，可以看到多了个dist文件夹，里面将我们的组件打包成了一个js文件，字体图标也打包好了，以后使用的话只要用dist文件夹就行了</p><p>接下来让我们整个项目用 pc-hub 管理一下，把打包好的dist放到npm上，提醒一下在index里要有install，不然不能作为Vue的插件也不能全局使用</p><p>接下来将my-ui上传到github上，这个不写了，主要是如何将组件库发布到npm上，需要做一点修改，首先将package.json中的 “private”: false 其次name属性要是npm上没有的包名，main属性设置为dist文件夹中以.umd.min.js结尾的文件路径，其他随意，以我的为例是:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;syhmy-ui&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;private&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;dist/my-ui.umd.in.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;auther&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ShiYuhao&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在打包文件夹中在新建一个.npmignore，跟.gitignore功能相似，只要用到dist即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 忽略目录</span><br><span class="line">examples&#x2F;</span><br><span class="line">packages&#x2F;</span><br><span class="line">public&#x2F;</span><br><span class="line"></span><br><span class="line"># 忽略指定文件</span><br><span class="line">vue.config.js</span><br><span class="line">babel.config.js</span><br><span class="line">*.map</span><br></pre></td></tr></table></figure><p>把打包好的文件上传到npm，如果装了nrm的，需要保证当前的源是npm的源，因为有些人会把源改到taobao去，得改回来，不然就不是上传到了npm。然后需要一个npm账号，没有的话注册一个<br>如图所示登陆成功，输入命令<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEIHVCb.TebOllO6KzbuUBEKtjz4kTeREg1qthzeU0dR*cDGXDRk6ylVBRHl08.vFxjb9CwI80fKBSRweAzxkA4w!/r" alt="image text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm public</span><br></pre></td></tr></table></figure><p>即可把包发布到npm上<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEP3bE1FZLFxGVG9C3cEWxQR.l1zzRnagmp5o28cq3mrPcbRNeupht4LVLQeHc956LAO7NErrXtuKfj21X0TF.IA!/r" alt="image text"><br>以后要更新你发布的npm包的话，要在package.json中修改版本号<br>如图，npm包可以正常下载，当成插件全局注册好后就可以使用了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>把packages处理成Vue插件</title>
    <link href="http://example.com/2020/11/02/%E6%8A%8Apackages%E5%A4%84%E7%90%86%E6%88%90vue%E6%8F%92%E4%BB%B6/"/>
    <id>http://example.com/2020/11/02/%E6%8A%8Apackages%E5%A4%84%E7%90%86%E6%88%90vue%E6%8F%92%E4%BB%B6/</id>
    <published>2020-11-01T16:00:00.000Z</published>
    <updated>2021-04-11T10:37:02.754Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>封装了几个Vue组件，怎么把它们制作制作成插件呢</p><p>先新建Vue项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create my-ui</span><br></pre></td></tr></table></figure><p>在my-ui文件夹中新建packages和examples文件夹，packages用来存放我们封装的所有组件，examples用来进行测试，把src改成examples</p><p>新建vue.config.js，写入如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      entry: <span class="string">&#x27;examples/main.js&#x27;</span>,</span><br><span class="line">      template: <span class="string">&#x27;public/index.html&#x27;</span>,</span><br><span class="line">      filename: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 扩展 webpack 配置，使 packages 加入编译</span></span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.module</span><br><span class="line">      .rule(<span class="string">&#x27;js&#x27;</span>)</span><br><span class="line">      .include.add(path.resolve(__dirname, <span class="string">&#x27;packages&#x27;</span>)).end()</span><br><span class="line">      .use(<span class="string">&#x27;babel&#x27;</span>)</span><br><span class="line">      .loader(<span class="string">&#x27;babel-loader&#x27;</span>)</span><br><span class="line">      .tap(<span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 修改它的选项...</span></span><br><span class="line">        <span class="keyword">return</span> options</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将封装好的vue组件全部放到packages文件夹中，同时也要打包字体图标文件，将fonts文件夹也放到packages文件夹中</p><p>这里需要了解Vue的install方法，见Vue官方文档Vue.use(plugin)，意思是想要做一个插件，插件只要导出一个install就行，在packages文件夹中新建index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整个包的入口</span></span><br><span class="line"><span class="comment">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件搜将被注册</span></span><br><span class="line"><span class="comment">// 导入颜色选择器组件</span></span><br><span class="line"><span class="keyword">import</span> ColorPicker <span class="keyword">from</span> <span class="string">&#x27;./color-picker&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">&#x27;./button&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Dialog <span class="keyword">from</span> <span class="string">&#x27;./dialog&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Input <span class="keyword">from</span> <span class="string">&#x27;./input&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Checkbox <span class="keyword">from</span> <span class="string">&#x27;./checkbox&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Radio <span class="keyword">from</span> <span class="string">&#x27;./radio&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Switch <span class="keyword">from</span> <span class="string">&#x27;./switch&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./fonts/font.scss&#x27;</span></span><br><span class="line"><span class="comment">// 存储组件列表</span></span><br><span class="line"><span class="keyword">const</span> components = [</span><br><span class="line">  ColorPicker,</span><br><span class="line">  Button,</span><br><span class="line">  Dialog,</span><br><span class="line">  Input,</span><br><span class="line">  Checkbox,</span><br><span class="line">  Radio,</span><br><span class="line">  Switch</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册</span></span><br><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历注册全局组件</span></span><br><span class="line">  components.forEach(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.component(component.name, component)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否是直接引入文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">  install(<span class="built_in">window</span>.Vue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 导出的对象必须具有 install，才能被 Vue.use() 方法安装</span></span><br><span class="line">  install,</span><br><span class="line">  <span class="comment">// 以下是具体的组件列表</span></span><br><span class="line">  ColorPicker,</span><br><span class="line">  Button,</span><br><span class="line">  Dialog,</span><br><span class="line">  Input,</span><br><span class="line">  Checkbox,</span><br><span class="line">  Radio,</span><br><span class="line">  Switch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在examples的main.js中输入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 导入组件库</span></span><br><span class="line"><span class="keyword">import</span> HmUI <span class="keyword">from</span> <span class="string">&#x27;./../packages&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(HmUI)</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这时就可以使用了，在examples中测试一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &lt;hm-button type=<span class="string">&quot;primary&quot;</span>&gt;按钮&lt;/hm-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>最后，examples文件夹是没用的，真正有用的是packages文件夹</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>“[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)” what &amp; why?</title>
    <link href="http://example.com/2020/11/01/[&#39;1&#39;,%20&#39;2&#39;,%20&#39;3&#39;].map(parseInt)%20what%20&amp;%20why/"/>
    <id>http://example.com/2020/11/01/[&#39;1&#39;,%20&#39;2&#39;,%20&#39;3&#39;].map(parseInt)%20what%20&amp;%20why/</id>
    <published>2020-10-31T16:00:00.000Z</published>
    <updated>2021-04-11T10:36:30.257Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是真正的答案是[1, NaN, NaN]。</p><p>首先回顾一下，map函数的第一个参数callback：<br>var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])<br>这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。</p><p>而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。<br>parseInt(string, radix)<br>接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。</p><p>了解这两个函数后，我们可以模拟一下运行情况</p><ol><li>parseInt(‘1’, 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1</li><li>parseInt(‘2’, 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN</li><li>parseInt(‘3’, 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN<br>map函数返回的是一个数组，所以最后结果为[1, NaN, NaN]</li></ol><p>最后附上MDN上对于这两个函数的链接，具体参数可以到里面看<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map</a></p><p>原文链接：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/4">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/4</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>图的遍历——广度优先搜索和深度优先搜索</title>
    <link href="http://example.com/2020/10/30/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://example.com/2020/10/30/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</id>
    <published>2020-10-29T16:00:00.000Z</published>
    <updated>2020-11-01T08:19:24.393Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前置知识：图的相关术语和图的表示</p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>和树数据结构类似，我们可以访问图的所有节点。由两种算法可以对图进行遍历：<strong>广度优先搜索（breadth-first search，BFS）</strong>和<strong>深度优先搜索（depth-first search，DFS）</strong>。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查路径是否相同，检查图是否有环，等等。</p><p>在实现算法之前，让我们来更好的理解一下图遍历的思想。</p><p><strong>图遍历算法</strong>的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有完全被探索，对于两种图遍历算法，都需要明确指出第一个被访问的顶点。</p><p>完全探索第一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加入待访问的定点列表中。</p><p>为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。</p><p>广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点列表的数据结构。如下表所示</p><table><thead><tr><th align="left">算法</th><th align="left">数据结构</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">深度优先搜索</td><td align="left">栈</td><td align="left">将顶点存入栈，顶点是沿着路径被探索的，存在新的相邻顶点就去访问</td></tr><tr><td align="left">广度优先搜索</td><td align="left">队列</td><td align="left">将顶点存入队列，最先入队列的顶点先被搜索</td></tr></tbody></table><p>当要标注已经访问过的顶点时，我们用三种颜色来反映它们的状态。</p><ul><li>白色：表示该顶点还没有被访问。</li><li>灰色：表示该顶点被访问过，但并未被探索过。</li><li>黑色：表示该顶点被访问过且被完全探索过。</li></ul><p>这就是之前提到的务必访问每个顶点最多两次的原因。</p><p>为了有助于在广度优先和深度优先算法中标记定点。我们要使用 Colors 变量（作为一个枚举器），声明如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Colors = &#123;</span><br><span class="line">    WHITE: <span class="number">0</span>,</span><br><span class="line">    GREY: <span class="number">1</span>,</span><br><span class="line">    BLACK: <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两个算法还需要访问一个辅助对象来帮助存储顶点是否被访问过。在每个算法的开头，所有的顶点都会被标记为未访问（白色）。我们要用下面的函数来初始化每个顶点的颜色。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initColor = <span class="function"><span class="params">vertices</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> color = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertices.length; i++</span>)</span>&#123;</span><br><span class="line">        color[vertices[i]] = Colors.WHITE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有邻点（相邻顶点），就像一次访问图的一层。换句话说，就是先宽后深的访问顶点，如下图所示<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrENvAK4hCVLHst1Ssx8xTOzSnZk4FpVPApa5BpTrf.Ojk7.j1y4mouG74Usz7fdaq8H0JlVD3*KnGxqQgxCPgClA!/r" alt="Image text"><br>以下是从顶点v开始的广度优先搜索算法所遵循的步骤。</p><p>(1) 创建一个队列 Q。<br>(2) 标注 v 为被发现的（灰色），并将 v 入队列 Q。<br>(3) 如果 Q 非空，则运行以下步骤：<br>    (a) 将 u 从 Q 中出队列；<br>    (b) 标注 u 为被发现的（灰色）；<br>    (c) 将 u 所有未被访问过的邻点（白色）入队列；<br>    (d) 标注 u 为已被探索的（黑色）。</p><p>让我们来实现广度优先搜索算法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> breathFirstSearch = <span class="function">(<span class="params">graph, startVertex, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> startVertex = graph.getVertices;</span><br><span class="line">    <span class="keyword">const</span> adjList = graph.getAdjList;</span><br><span class="line">    <span class="keyword">const</span> color = initColor(vertices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">    queue.enqueue(startVertex);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">while</span>(<span class="params">!queue.isEmpty()</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> u = queue.dequeue();</span><br><span class="line">        <span class="keyword">const</span> neighbors = adjList.get(u);</span><br><span class="line">        color[u] = Colors.GREY;</span><br><span class="line">        <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> w = neighbors[i];</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">color[w] === Colors.WHITE</span>)</span>&#123;</span><br><span class="line">                color[w] = Colors.GREY;</span><br><span class="line">                queue.enqueue(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        color[u] = Colors.BLACK;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">            callback(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="深度优先搜素"><a href="#深度优先搜素" class="headerlink" title="深度优先搜素"></a>深度优先搜素</h2><p>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条卢静最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是是先深度后广度地访问顶点，如下图所示<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEO7a7xpq*swiCvkKkkTZecTjQEoR89aVQ*WEn7KMBcryBowgzBlEHeSnKkiqeKpdq1J*fk2xlJvTX4HmbNXqrUE!/r" alt="Image text"><br>深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点 v 未访问，则访问该顶点 v。</p><p>要访问顶点 v，照如下步骤做：<br>(1) 标注 v 为未被发现的（灰色）；<br>(2) 对于 v 的所有未访问（白色）的邻点 w，访问顶点 w；<br>(3) 标注 v 为已被探索的（黑色）；</p><p>深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）。</p><p>让我们来实现一下深度优先算法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> depthFirstSearch = <span class="function">(<span class="params">graph, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> startVertex = graph.getVertices();</span><br><span class="line">    <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">    <span class="keyword">const</span> color = initColor(vertices);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">color[vertices[i]] === Colors.WHITE</span>)</span>&#123;</span><br><span class="line">            depthFirstSearchVisit(vertices[i], color, adjList, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> depthFirstSearchVisit = <span class="function">(<span class="params">u, color, adjList, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    color[u] = Colors.GRAY;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">        callback(u)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> neighbors = adjList.get(u);</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> w = neighbors[i];</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">color[w] === Colors.WHITE</span>)</span>&#123;</span><br><span class="line">            depthFirstSearchVisit(w, color, adjList, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    color[u] = Colors.BLACK;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写此文的原因是在面试时面试官看我在简历上写了数据结构与算法(Leetcode120+)，便询问做的题以哪方面为主，答曰数组和树。一面让手写了一下先序遍历，这个写出来了，二面换了个人问广度优先搜索和深度优先搜索。啊这，答不上来。因为当时是在学习图的时候看到这两个概念，但是图已经是书本介绍的最后一个数据结构了，而且感觉不怎么常见，就没把那章节看完。<del>加上当时已经学到Node.js、计网、异步等信息量比较大的知识，后续更是在学框架写东西，就没再研究数据结构与算法了</del>（解释</p><p>所以这将成为本博客第一个数据结构与算法相关的文章。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>简单的React父子组件和平级组件之间传值</title>
    <link href="http://example.com/2020/10/30/%E7%AE%80%E5%8D%95%E7%9A%84React%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%92%8C%E5%B9%B3%E7%BA%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC/"/>
    <id>http://example.com/2020/10/30/%E7%AE%80%E5%8D%95%E7%9A%84React%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%92%8C%E5%B9%B3%E7%BA%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC/</id>
    <published>2020-10-29T16:00:00.000Z</published>
    <updated>2021-04-11T10:37:18.563Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.父组件对子组件传值 利用props属性传值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;I am &#123;<span class="built_in">this</span>.props.name&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Component name=<span class="string">&#x27;cat&#x27;</span>&gt;&lt;/Component&gt;</span><br><span class="line">    &lt;h1&gt;hello world!!!&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>2.子组件对父组件传值 简单来说就是利用回调来完成，比如下面例子，子组件来改变父组件的颜色</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理父子组件间传值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.props.colorChange(<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;父组件的值  &#123;<span class="built_in">this</span>.props.bgColor&#125;&lt;/h1&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.handleClick(e)&#125;&gt;改变父组件颜色&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.state=&#123;</span><br><span class="line">        bgColor: <span class="string">&#x27;#999&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">onBgColorChange</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        bgColor: color</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123;<span class="attr">background</span>:<span class="built_in">this</span>.state.bgColor&#125;&#125;&gt;</span><br><span class="line">          &lt;Child bgColor=&#123;<span class="built_in">this</span>.state.bgColor&#125; colorChange=&#123;<span class="function">(<span class="params">color</span>)=&gt;</span>&#123;<span class="built_in">this</span>.onBgColorChange(color)&#125;&#125;&gt;&lt;/Child&gt;</span><br><span class="line">          &#123;<span class="comment">/* 子组件像父组件传值，设置回调 */</span>&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Father&gt;&lt;/Father&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>3.同一父组件下平级组件间传值 ，简单一句话 子组件先传给父组件，父组件再传给那个子组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理平级组件间传值 ，先传给父组件，父组件再传给另一个组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.props.changeChild2Color(<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;Child1：  &#123;<span class="built_in">this</span>.props.bgColor&#125;&lt;/h1&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.handleClick(e)&#125;&gt;向Child2传值，改变其颜色&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123;<span class="attr">background</span>:<span class="built_in">this</span>.props.bgColor&#125;&#125;&gt;</span><br><span class="line">            &lt;h1&gt;Child2：  &#123;<span class="built_in">this</span>.props.bgColor&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.state=&#123;</span><br><span class="line">        child2BgColor: <span class="string">&#x27;#999&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">onChild2BgColorChange</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        child2BgColor: color</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123;<span class="comment">/* 平级组件间传值*/</span>&#125;</span><br><span class="line">          &lt;Child1 changeChild2Color=&#123;<span class="function">(<span class="params">color</span>)=&gt;</span>&#123;<span class="built_in">this</span>.onChild2BgColorChange(color)&#125;&#125;&gt;&lt;/Child1&gt;</span><br><span class="line">          &lt;Child2 bgColor=&#123;<span class="built_in">this</span>.state.child2BgColor&#125;&gt;&lt;/Child2&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Father&gt;&lt;/Father&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>web通讯的四种方式：短轮询、长轮询(comet)、长连接(SSE)、WebSocket</title>
    <link href="http://example.com/2020/10/29/web%E9%80%9A%E8%AE%AF%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%9F%AD%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2(comet)%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5(SSE)%E3%80%81WebSocket/"/>
    <id>http://example.com/2020/10/29/web%E9%80%9A%E8%AE%AF%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%9F%AD%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2(comet)%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5(SSE)%E3%80%81WebSocket/</id>
    <published>2020-10-28T16:00:00.000Z</published>
    <updated>2021-04-10T19:38:32.352Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>http端轮询是服务器收到请求不管是否有数据都直接响应 http 请求;<br>其实就是普通的轮询。指在特定的的时间间隔（如每1秒），由浏览器对服务器发出 HTTP request，然后由服务器返回最新的数据给客户端的浏览器。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>传统的 web 通信模式。后台处理数据，需要一定时间，前端想要知道后端的处理结果，就要不定时的向后端发出请求以获得最新情况。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>前后端程序编写比较容易。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>请求中有大半是无用，难于维护，浪费带宽和服务器资源；<br>响应的结果没有顺序（因为是异步请求，当发送的请求没有返回结果的时候，后面的请求又被发送。而此时如果后面的请求比前面的请 求要先返回结果，那么当前面的请求返回结果数据时已经是过时无效的数据了）。</p><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><pre><code>适于小型应用。</code></pre><h2 id="前端实现："><a href="#前端实现：" class="headerlink" title="前端实现："></a>前端实现：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;/user&#x27;</span>);</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h1 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>客户端向服务器发送 Ajax 请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。</p><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>在无消息的情况下不会频繁的请求，耗费资源小。</p><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>服务器 hold 连接会消耗资源<br>返回数据顺序无保证，难于管理维护。<br>浏览器端对统一服务器同时 http 连接有最大限制, 最好同一用户只存在一个长轮询;</p><h2 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h2><p>WebQQ、Hi 网页版、Facebook IM。</p><h2 id="前端实现：-1"><a href="#前端实现：-1" class="headerlink" title="前端实现："></a>前端实现：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">       xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;/user&#x27;</span>);</span><br><span class="line">       xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             ajax();</span><br><span class="line">       &#125;;</span><br><span class="line">       xhr.send();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>长轮询和短轮询</p><ul><li>相同点：可以看出 http 长轮询和 http 短轮询的都会 hold 一段时间;</li><li>不同点：间隔发生在服务端还是浏览器端: http 长轮询在服务端会 hold 一段时间, http 短轮询在浏览器端 “hold”一段时间;</li></ul><h1 id="http-长连接"><a href="#http-长连接" class="headerlink" title="http 长连接"></a>http 长连接</h1><p>目前 http 协议普遍使用的是 1.1 版本, 之前有个 1.0 版本,两者之间的一个区别是 1.1 支持 http 长连接, 或者叫持久连接。<br>1.0 不支持 http 长连接, 每次一个 http请求响应后都关闭 tcp 连接, 下个 http 请求会重新建立 tcp 连接.</p><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>多个 http 请求共用一个 tcp 连接; 这样可以减少多次临近 http 请求导致 tcp建立关闭所产生的时间消耗.</p><p>http 1.1 中在请求头和相应头中用 connection 字段标识是否是 http长连接, connection: keep-alive, 表明是 http 长连接; connection:closed, 表明服务器关闭 tcp 连接</p><p>与 connection 对应的一个字段是 keep-live, http 响应头中出现, 他的格式是 timeout=30,max=5, timeout 是两次 http 请求保持的时间(s), , max 是这个 tcp 连接最多为几个 http请求重用</p><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><p>消息即时到达，不发无用请求；管理起来也相对方便。</p><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><p>服务器维护一个长连接会增加开销。</p><h2 id="实例：Gmail聊天"><a href="#实例：Gmail聊天" class="headerlink" title="实例：Gmail聊天"></a>实例：Gmail聊天</h2><h1 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>Websocket 是基于 HTTP 协议的，在和服务端建立了链接后，服务端有数据有了变化后会主动推送给前端。</p><h2 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h2><p>请求响应快，不浪费资源。（传统的 http 请求，其并发能力都是依赖同时发起多个 TCP 连接访问服务器实现的(因此并发数受限于浏览器允许的并发连接数)，而 websocket 则允许我们在一条 ws 连接上同时并发多个请求，即在A请求发出后A响应还未到达，就可以继续发出B请求。由于 TCP 的慢启动特性（新连接速度上来是需要时间的），以及连接本身的握手损耗，都使得 websocket 协议的这一特性有很大的效率提升；http 协议的头部太大，且每个请求携带的几百上千字节的头部大部分是重复的，websocket 则因为复用长连接而没有这一问题。）</p><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>主流浏览器支持的Web Socket 版本不一致；<br>服务端没有标准的 API。</p><h2 id="实例：实现即时通讯-如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询"><a href="#实例：实现即时通讯-如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询" class="headerlink" title="实例：实现即时通讯:如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询"></a>实例：实现即时通讯:如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询</h2><h2 id="解决：解决了http协议的两个问题。"><a href="#解决：解决了http协议的两个问题。" class="headerlink" title="解决：解决了http协议的两个问题。"></a>解决：解决了http协议的两个问题。</h2><ol><li>服务端的被动性。http 协议是只有客户端询问之后才回复。解决了同步有延迟的问题</li><li>解决了服务器上消耗资源的问题</li></ol><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要先npm install ws</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器端</span></span><br><span class="line"><span class="keyword">var</span> Server = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>).Server;</span><br><span class="line"><span class="keyword">var</span> wss = <span class="keyword">new</span> Server(&#123;</span><br><span class="line">    port:<span class="number">2000</span></span><br><span class="line">&#125;);</span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ws</span>)</span>&#123;</span><br><span class="line">    ws.on(<span class="string">&#x27;message&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        ws.send(<span class="string">&#x27;你好,客户端,我是服务器!&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//node客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:2000/&#x27;</span>);</span><br><span class="line">socket.on(<span class="string">&#x27;open&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    socket.send(<span class="string">&#x27;你好，服务器,我是客户端&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">socket.on(<span class="string">&#x27;message&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//html客户端(注:浏览器客户端与node客户端只需要一种)</span></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:2000/&#x27;</span>);</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSocket四个事件操作"><a href="#WebSocket四个事件操作" class="headerlink" title="WebSocket四个事件操作"></a>WebSocket四个事件操作</h2><ul><li>onmessage 收到服务器响应时执行</li><li>onerroe 出现异常时执行</li><li>onopen 建立起连接时执行</li><li>onclose 断开连接时执行</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="前端基础" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>扫码点餐时遇到的问题</title>
    <link href="http://example.com/2020/09/19/%E6%89%AB%E7%A0%81%E7%82%B9%E9%A4%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/09/19/%E6%89%AB%E7%A0%81%E7%82%B9%E9%A4%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-09-18T16:00:00.000Z</published>
    <updated>2021-04-11T10:37:47.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="在写个人项目——扫码点餐中碰到的一些问题"><a href="#在写个人项目——扫码点餐中碰到的一些问题" class="headerlink" title="在写个人项目——扫码点餐中碰到的一些问题"></a>在写个人项目——扫码点餐中碰到的一些问题</h1><h2 id="React报错-Objects-are-not-valid-as-a-React-Child"><a href="#React报错-Objects-are-not-valid-as-a-React-Child" class="headerlink" title="React报错: Objects are not valid as a React Child"></a>React报错: Objects are not valid as a React Child</h2><p>解决方法：标签之间的内容不能为对象，不能作为原生元素的子元素，但可以作为自定义组件的子元素</p><h2 id="React报错-props-is-not-defined-at-xxx-render"><a href="#React报错-props-is-not-defined-at-xxx-render" class="headerlink" title="React报错: props is not defined at xxx.render"></a>React报错: props is not defined at xxx.render</h2><p>解决方法：1. render中应写this.state，是否写成了props.state?</p><h2 id="Error-Request-failed-with-status-code-401"><a href="#Error-Request-failed-with-status-code-401" class="headerlink" title="Error: Request failed with status code 401"></a>Error: Request failed with status code 401</h2><p><img src="http://note.youdao.com/yws/public/resource/57483267a438c01a94484a62517b6eb4/xmlnote/DB20B89D253641DFBBE44436175CF3A9/642" alt="Image text"><br>一些前端基础功能部分抛出的错误，promise抛出的错误，不是响应体而是错误对象</p><h2 id="向后端请求餐桌信息，跨域问题"><a href="#向后端请求餐桌信息，跨域问题" class="headerlink" title="向后端请求餐桌信息，跨域问题"></a>向后端请求餐桌信息，跨域问题</h2><p><img src="http://note.youdao.com/yws/public/resource/57483267a438c01a94484a62517b6eb4/xmlnote/CAC2CD357C7F4F86AC9C8964CBDB9EEA/652" alt="Image text"><br>后端app.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(cors(&#123;</span><br><span class="line">  origin: <span class="literal">true</span>,<span class="comment">//修改这里</span></span><br><span class="line">  maxAge: <span class="number">86400</span>,</span><br><span class="line">  credentials: <span class="literal">true</span>,</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h2 id="proxy-error"><a href="#proxy-error" class="headerlink" title="proxy error"></a>proxy error</h2><p><img src="http://note.youdao.com/yws/public/resource/57483267a438c01a94484a62517b6eb4/xmlnote/9F4153617CB84496A435AD090C1DA56F/665" alt="Image text"><br>proxy代理设置 “proxy”: “<a href="http://localhost:5002&quot;">http://localhost:5002&quot;</a> 即可<br>同代表本机的10.1.1就不可以，最好各处写的一致</p><h2 id="React脚手架运行npm-start报错-webpack版本问题"><a href="#React脚手架运行npm-start报错-webpack版本问题" class="headerlink" title="React脚手架运行npm start报错 webpack版本问题"></a>React脚手架运行npm start报错 webpack版本问题</h2><p>There might be a problem with the project dependency tree.<br>It is likely not a bug in Create React App, but something you need to fix locally.<br>The react-scripts package provided by Create React App requires a dependency:<br>“webpack”: “4.42.0”<br>Don’t try to install it manually: your package manager does it automatically.<br>However, a different version of webpack was detected higher up in the tree:<br>C:\Users\lenovo\node_modules\webpack (version: 4.41.6)<br>Manually installing incompatible versions is known to cause hard-to-debug issues.<br>If you would prefer to ignore this check, add SKIP_PREFLIGHT_CHECK=true to an .env file in your project.<br>That will permanently disable this message but you might encounter other issues.<br>To fix the dependency tree, try following the steps below in the exact order:</p><ol><li>Delete package-lock.json (not package.json!) and/or yarn.lock in your project folder.</li><li>Delete node_modules in your project folder.</li><li>Remove “webpack” from dependencies and/or devDependencies in the package.json file in your project folder.</li><li>Run npm install or yarn, depending on the package manager you use.<br>In most cases, this should be enough to fix the problem.<br>If this has not helped, there are a few other things you can try:</li><li>If you used npm, install yarn (<a href="http://yarnpkg.com/">http://yarnpkg.com/</a>) and repeat the above steps with it instead.<br>This may help because npm has known issues with package hoisting which may get resolved in future versions.</li><li>Check if C:\Users\lenovo\node_modules\webpack is outside your project directory.<br>For example, you might have accidentally installed something in your home folder.</li><li>Try running npm ls webpack in your project folder.<br>This will tell you which other package (apart from the expected react-scripts) installed webpack.<br>If nothing else helps, add SKIP_PREFLIGHT_CHECK=true to an .env file in your project.<br>That would permanently disable this preflight check in case you want to proceed anyway.<br>P.S. We know this message is long but please read the steps above :-) We hope you find them helpful!</li></ol><p>解决办法：在项目文件夹下，新建一个.env文件，在其中写上如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SKIP_PREFLIGHT_CHECK&#x3D;true</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>用生成器函数和Promise改善异步流程</title>
    <link href="http://example.com/2020/08/11/%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0%E5%92%8CPromise%E6%94%B9%E5%96%84%E5%BC%82%E6%AD%A5%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2020/08/11/%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0%E5%92%8CPromise%E6%94%B9%E5%96%84%E5%BC%82%E6%AD%A5%E6%B5%81%E7%A8%8B/</id>
    <published>2020-08-11T10:51:00.000Z</published>
    <updated>2021-04-11T10:38:10.741Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在学习JavaScript异步相关的知识，在学到Generator（生成器函数）、Promise 和 async-awiat 等相关对异步优化的内容时遇到了一些一时没有理解的东西。本文仅作为学习过程中的笔记分享，第一次发文章，如果错误请不吝指出。</p><p>话不多说，进入正题，先写一下在 Generator 中要用到的函数，随便写几个就行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">val, duration</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(val);</span><br><span class="line">        &#125;, duration);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">duration</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;<span class="comment">//delay函数不resolve出任何东西，或者说resolve出undefined</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(url).then(<span class="built_in">JSON</span>.parse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是 <strong>Generator 函数主体</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">yield</span> getJSON(<span class="string">&#x27;data.json&#x27;</span>)<span class="comment">//(1)</span></span><br><span class="line">    <span class="keyword">yield</span> delay(<span class="number">1000</span>);<span class="comment">//(2)</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">yield</span> getValue(<span class="number">10</span>, <span class="number">3000</span>);<span class="comment">//(3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Generator 函数会在遇到 yield 时生成一个值并暂停执行，如果要继续执行，则要调用next()，yield 的运算结果是生成器 next() 里面的参数。</p><p>为了执行 Generator函数 f ，声明一个函数 g 作为函数 f 的调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = f();</span><br><span class="line"></span><br><span class="line">g.next().value.then(<span class="function"><span class="params">value</span> =&gt;</span>&#123;</span><br><span class="line">  g.next(value).value.then(<span class="function"><span class="params">value</span> =&gt;</span></span><br><span class="line">    g.next(value).value.then(<span class="function"><span class="params">value</span> =&gt;</span></span><br><span class="line">      g.next(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>分析一下对 g 调用 next() 的过程。</p><p>在声明完函数 g 之后。<strong>第一行</strong>的第一个 value 是 getJSON 解析好的的 promise（我们希望在 promise 在 resolve 以后恢复执行），然后通过 data 返回，但是我们也不确定什么时候能resolve，但是可以确定的是：resolve 之后恢复生成器的执行。</p><p><strong>第二行</strong>的第一个 value 是上一个 then 传入的 value（getJSON(‘data.json’) resolve 的结果），第二个 value 是 delay(1000) 的 promise 的 resolve。</p><p>接下来是<strong>第三行</strong>，很明显，next() 调用一次就恢复执行，然后暂停，再调一次就再恢复执行，这里是第三次调用，传入的 value（第二个 value）是第(2)行的返回结果，虽然 delay 并没啥返回（甚至左边没有变量接住）。这次调用将会返回第(3)行生成的 promise 对象，然后等getValue 函数 resolve 以后，再恢复执行。这时这里第三个 value 应该是10并返回给b。</p><p>最后一行，即<strong>第四行</strong> g.next(value); 这里的 value 为10。<br>&emsp;<br>&emsp;</p><h1 id="总结一下-f-函数的执行"><a href="#总结一下-f-函数的执行" class="headerlink" title="总结一下 f() 函数的执行"></a>总结一下 f() 函数的执行</h1><p>运行到<strong>第(1)行的 yield</strong> 时，在 yield 出 getJSON 的 promise 后，它执行停止了，直到 promise 的 resolve 后才恢复执行，并且恢复之后还将返回 promise 的 resolve 的值，也就是 data 将等于 data.json 解析出的内容。</p><p>然后函数运行到<strong>第(2)行</strong>，又 yield 出了 delay 的 promise，并再次等待 promise 的 resolve后才恢复执行（虽然这里的 delay 本身没求值结果所以也不 resolve 出啥），delay 在1秒后完成，所以第(2)行的 yield 也在1秒后恢复。</p><p>运行到<strong>第(3)行</strong>，又 yield 出一个promise，然后就停住了，在等待这个 promise 的 resolve 后才恢复，要恢复得调用 next()，而 next 的调用在 promise 的 resolve之后，即这时已经有resolve 的值了，把值传给 next() 即可，b 就等于这个 resolve 出的值。全程 next() 调用在那行的 promise 的 resolve之后，而且调用的时候把 promise 的 resovle 的值传给 next() 并成为yield 的返回值。</p><p>f() 这样跟同步的写法区别仅在于有没有 yield，虽然是异步的，但是写在了同一行里。(1)行的data 最终将等于 data.json 用 getJSON 请求到的真正的数据，而不是一个 promise 对象。虽然看起来像同步，但实际上代码在运行到这行的时候暂停了一定的时间，时间取决于 promise 的 resolve 的时间，在等待的这段时间，浏览器是完全空闲的。</p><p>在以上的举例分析中，我们只考虑了 promise 能正确 resolve 的情况，那么接下来再写一下出现错误的情况（拿 next() 调用 g 的第一行举例）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g.next().value.then(<span class="function"><span class="params">value</span> =&gt;</span>&#123;</span><br><span class="line">    g.next(value);<span class="comment">//成功就通过yield返回</span></span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span>&#123;</span><br><span class="line">    g.throw(reason);<span class="comment">//失败就通过yield抛出</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>如果成功的就调用这个箭头函数（第一个 value 是 promise）,then 只是挂上了两个并没有立刻得到结果的函数就结束，然后执行下一句（console.log(1);）了，注意即使在then调用时promise 已经得出结果，下一句 console.log(1); 仍然先于then里的函数执行。因为这个函数是异步调用的，里面的内容必定在 then 所在的调用栈全部清空以后执行，</p><p>另外说一下，既然有错误，就应该加上 try-catch 语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">yield</span> getJSON(<span class="string">&#x27;data.json&#x27;</span>)</span><br><span class="line">&#125;<span class="function"><span class="title">catch</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//多了yield的好处：能看出代码哪里需要等待</span></span><br></pre></td></tr></table></figure><h1 id="最后总结和补充一下-Generator-和-async-await-对于异步优化的一些知识点"><a href="#最后总结和补充一下-Generator-和-async-await-对于异步优化的一些知识点" class="headerlink" title="最后总结和补充一下 Generator 和 async-await 对于异步优化的一些知识点"></a>最后总结和补充一下 Generator 和 async-await 对于异步优化的一些知识点</h1><p>Generator可以让执行处于暂停状态，Generator 返回的是一个 Iterator 对象。<br>必要构成：1 个星号和 yield 运算符。<br>next 属性返回一个对象，里面 value 是当前 yield 后面的值，done 表示当前生成器有没有运行完。yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。yield可以生成一个值，然后恢复的话（也可以不恢复，就不返回值）又可以返回一个值，两个值可以不一样。<br>yield: yield 的运算结果是生成器 next() 里面的参数。<br>async + 生成器函数 function {await ：promise 函数}。 async 函数就是将 Generator 函数的星号替换成 async，将 yield 替换成 await。<br>async 函数对 Generator 函数的改进，配合 promise 使用(后面接返回promise的函数？)，包装原理如上。并且 function() 返回一个 promise。<strong>async-await 本质是生成器函数和yield。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>this和强制改变this指向</title>
    <link href="http://example.com/2020/04/13/this%E5%92%8C%E5%BC%BA%E5%88%B6%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91/"/>
    <id>http://example.com/2020/04/13/this%E5%92%8C%E5%BC%BA%E5%88%B6%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91/</id>
    <published>2020-04-12T16:00:00.000Z</published>
    <updated>2021-04-11T10:46:05.011Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>);<span class="comment">//[Objes y);//10,20</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>要改变它的this指向，有几种方法：<br>方法1：call<br>        格式： 函数名.call();<br>        参数：第一个参数：传入该函数this指向的对象，传入什么就强制指向什么<br>              从第二个参数开始，将原函数的参数往后顺延一位<br>        注：call主要目的是为了绑定参数，apply则是出现…运算符之前的老旧写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show.call(<span class="string">&quot;call&quot;</span>, <span class="number">20</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure><p>方法2：apply<br>        格式：函数名.apply();<br>        参数：第一个参数；传入该函数this指向的对象，传入什么就强制指向什么<br>              第二个参数：数组，放入原有的所有参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show.apply(<span class="string">&quot;call&quot;</span>, [<span class="number">20</span>, <span class="number">40</span>]);</span><br></pre></td></tr></table></figure><p>方法3：bind预设this指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>);</span><br><span class="line">            alert(x + <span class="string">&quot;,&quot;</span> + y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> res = show.bind(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="comment">//res(40, 50);</span></span><br><span class="line">        show.bind(<span class="string">&quot;bind&quot;</span>)(<span class="number">40</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>apply使用方法的小技巧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.min();</span><br><span class="line">Math.max();</span><br><span class="line">alert(Math.min(10,20,30,40,50));</span><br><span class="line">alert(Math.max(10,20,30,40,50));</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [10,20,30,40,50];</span><br><span class="line">alert(Math.min.apply(null, arr));</span><br><span class="line">alert(Math.max.apply(null, arr));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>认识闭包</title>
    <link href="http://example.com/2020/04/04/%E8%AE%A4%E8%AF%86%E9%97%AD%E5%8C%85/"/>
    <id>http://example.com/2020/04/04/%E8%AE%A4%E8%AF%86%E9%97%AD%E5%8C%85/</id>
    <published>2020-04-03T16:00:00.000Z</published>
    <updated>2021-04-11T10:37:09.075Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>满足以下特点的叫做闭包<br>    1、函数嵌套函数<br>    2、内部函数使用外部函数的形参和变量<br>    3、被引用的形参和变量不会被垃圾回收机制所回收</p><p>好处：<br>    1、希望一个变量常驻在内存当中<br>    2、避免全局变量污染 避免声明全局变量，比如在函数外声明<br>    3、可以声明私有成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">num1</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">var</span> num2 = <span class="number">10</span>;</span><br><span class="line">           <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="keyword">return</span>(num1 + <span class="string">&quot; &quot;</span> + num2);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> b;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">var</span> res = a(<span class="number">20</span>);</span><br><span class="line">       <span class="built_in">console</span>.log(res());</span><br></pre></td></tr></table></figure><p>就是一个闭包</p><p>可以实现：1、避免全局污染，2、对a进行累加<br>【注】让a变量常驻内存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cc = aa();</span><br><span class="line">    cc();</span><br><span class="line">    cc();</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>写成立即执行函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">cc();</span><br><span class="line">cc();</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>闭包的一个应用：私有变量<br>例子：A，B两同学共同开发代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleA = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">10</span>;<span class="comment">//私有变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;<span class="comment">//私有方法</span></span><br><span class="line">        count += <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        count *= <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        funcA: aaa,</span><br><span class="line">        funcB: bbb</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> moduleA = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        count += <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        count *= <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        funcA: aaa,</span><br><span class="line">        funcB: bbb</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">moduleA.funcA();</span><br><span class="line">moduleA.funcB();</span><br><span class="line"></span><br><span class="line">moduleB.funcA();</span><br><span class="line">moduleB.funcB();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端基础知识</title>
    <link href="http://example.com/2019/12/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2019/12/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2019-12-25T16:00:01.000Z</published>
    <updated>2021-04-11T10:37:27.447Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前端基础知识"><a href="#前端基础知识" class="headerlink" title="前端基础知识"></a>前端基础知识</h1><h2 id="HTML-CSS问题"><a href="#HTML-CSS问题" class="headerlink" title="HTML + CSS问题"></a>HTML + CSS问题</h2><h3 id="1-如何清除浮动？"><a href="#1-如何清除浮动？" class="headerlink" title="1. 如何清除浮动？"></a>1. 如何清除浮动？</h3><p>clear 清除浮动（添加空div法）在浮动元素下方添加空 div，并给该元素写 CSS 样式 {clear:both; height:0; overflow:hidden;}<br>给浮动元素父级设置高度<br>父级同时浮动（需要给父级同级元素添加浮动）<br>父级设置成 inline-block<br>给父级添加 overflow: hidden<br>万能清除法 after伪类 清浮动（现在主流方法，推荐使用）</p><p>BFC 触发条件<br>根元素<br>position: absolute/fixed<br>display: inline-block / table<br>float 元素<br>ovevflow 不为 visible</p><h3 id="2-行内元素和块元素有哪些，本质区别"><a href="#2-行内元素和块元素有哪些，本质区别" class="headerlink" title="2.行内元素和块元素有哪些，本质区别"></a>2.行内元素和块元素有哪些，本质区别</h3><p>行内元素：span、img、button、input、b、q、i、a、em、label<br>块元素：div、p、h1-h6、ul、ol、dl、li、header、footer、aside、section、article、form、table</p><p>区别：行内元素设置 width，height 属性无效，起边距作用的只 有margin-left、margin-right、padding-left、padding-right，其它属性不会起边距效果（可以设置 line-height），设置 margin 和 padding 的上下不会对其他元素产生影响。块级元素可以设置 width，height 属性</p><h3 id="3-水平、垂直居中"><a href="#3-水平、垂直居中" class="headerlink" title="3.水平、垂直居中"></a>3.水平、垂直居中</h3><p>水平：行内元素：父元素 text-align: center<br>块元素：宽度已知用 margin: auto，宽度未知：用 display: inline 变成行内元素后在父元素上设置 text-align: float<br>垂直：display: flex; align-item: center</p><h3 id="4-flex"><a href="#4-flex" class="headerlink" title="4. flex"></a>4. flex</h3><p>Flex 意为弹性布局，任何一个容器都可以指定为 Flex 布局。行内元素也可以使用 Flex 布局。<br>flex-direction属性 该属性定义了子元素的排列方向</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex-wrap属性 该属性称“轴线”的方向</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex-flow属性：|| ; flex-direction 和 flex-wrap 的简写，默认值为 row nowrap<br>justify-content 属性 该属性定义了子元素在主轴上的对齐方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>align-items 属性 该属性定义了项目在交叉轴上如何对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>align-content 属性，该属性定义了多跟轴线的对齐方式，如果项目只有一根轴线，该属性不起作用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-CSS让元素不可见的方法"><a href="#5-CSS让元素不可见的方法" class="headerlink" title="5. CSS让元素不可见的方法"></a>5. CSS让元素不可见的方法</h3><p>display: none | z-index: -9999（只能在定位元素上生效） | opacity:0 | position: absolute; left: -9999; top: -9999</p><h3 id="6-如何设计移动端页面和响应式界面"><a href="#6-如何设计移动端页面和响应式界面" class="headerlink" title="6. 如何设计移动端页面和响应式界面"></a>6. 如何设计移动端页面和响应式界面</h3><h3 id="7-选择器优先级"><a href="#7-选择器优先级" class="headerlink" title="7. 选择器优先级"></a>7. 选择器优先级</h3><p>!important - 内联 - id - 类 - 标签 - 通配符 - 继承</p><h3 id="8-px、em、rem、-、vw、vh、vm这些单位的区别"><a href="#8-px、em、rem、-、vw、vh、vm这些单位的区别" class="headerlink" title="8. px、em、rem、%、vw、vh、vm这些单位的区别"></a>8. px、em、rem、%、vw、vh、vm这些单位的区别</h3><p>em：参考的是父元素的 font-size，具有继承的特点，如果自身定义了 font-size 则按自身来计算（浏览器默认字体是16px），整个页面内 1em 不是一个固定的值<br>rem：相对于根元素 html，可以设置根元素 html 的 font-size 为10px，则1.2em就是12px；<br>vw：css3新单位，view width 的缩写，是指可视窗口的高度，假如宽度是1200px，则10vw就是120px；举个例子：浏览器宽度1200px， 1 vw = 1200px/100 = 12 px。<br>Vh：类似vw，指的是可视窗口的高度。<br>Vm：相对于视口的宽度或高度中较小的那个，其中最小的单位被均分为100个单位，举个例子：浏览器高度900px，宽度1200px，取最小的浏览器高度，1vm = 900px/  100 = 9 px</p><h3 id="9-说一下对HTML语义化的理解"><a href="#9-说一下对HTML语义化的理解" class="headerlink" title="9.  说一下对HTML语义化的理解"></a>9.  说一下对HTML语义化的理解</h3><p>语义化就是选择与语义相符合的标签，使代码语义化，这样不仅便于开发者进行阅读，同时也能维护和写出更优雅的代码，还能够让搜索引擎和浏览器等工具更好地解析。<br>通俗的讲语义化就是让正确的标签做正确的事情，比如段落用p标签，头部用 header 标签，主要内容用 main 标签，侧边栏用 aside 标签等等。</p><h3 id="10-meta-viewport-是做什么用的"><a href="#10-meta-viewport-是做什么用的" class="headerlink" title="10. meta viewport 是做什么用的"></a>10. meta viewport 是做什么用的</h3><p>将视口大小设置为可视区域的大小。</p><h3 id="11-两种盒模型"><a href="#11-两种盒模型" class="headerlink" title="11. 两种盒模型"></a>11. 两种盒模型</h3><p>content-box 和 border-box 的区别：计算最大尺寸时是否包含边距，border-box 最大尺寸是包含了边距的（width:100， content(80) + border(10) = 100），content-box 最大尺寸是不包含边距（width: 100， content(100) + border(10) = 120）</p><h3 id="12-响应式布局实现原理和方案"><a href="#12-响应式布局实现原理和方案" class="headerlink" title="12. 响应式布局实现原理和方案"></a>12. 响应式布局实现原理和方案</h3><p>原理：响应式开发一套界面，通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容<br>方案<br>媒体查询：@media 可以针对不同的屏幕尺寸设置不同的样式，当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。<br>百分比布局：通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果。Bootstrap 里面的栅格系统就是利用百分比来定义元素的宽高，CSS3 支持最大最小高，可以将百分比和 max(min) 一起结合使用来定义元素在不同设备下的宽高。<br>rem布局：rem 是 CSS3 新增的单位，rem 单位都是相对于根元素 html 的 font-size 来决定大小的。当页面的 size 发生变化时，只需要改变 font-size 的值，那么以 rem 为固定单位的元素的大小也会发生响应的变化（而 em 是相对于父元素的）。</p><h3 id="13-DOM和BOM是什么"><a href="#13-DOM和BOM是什么" class="headerlink" title="13. DOM和BOM是什么"></a>13. DOM和BOM是什么</h3><p>BOM是浏览器对象模型，用来获取或设置浏览器的属性、行为，例如:新建窗口、获取屏幕分辨率、浏览器版本号等。<br>DOM是文档对象模型，用来获取或设置文档中标签的属性，例如获取或者设置input表单的value值。</p><h3 id="14-CSS加载会造成阻塞吗"><a href="#14-CSS加载会造成阻塞吗" class="headerlink" title="14. CSS加载会造成阻塞吗"></a>14. CSS加载会造成阻塞吗</h3><ol><li>css 加载不会阻塞 DOM 树的解析。</li><li>css 加载会阻塞 DOM 树的渲染。</li><li>css 加载会阻塞后面 js 语句的执行。</li></ol><h3 id="15-伪类和伪元素的区别"><a href="#15-伪类和伪元素的区别" class="headerlink" title="15. 伪类和伪元素的区别"></a>15. 伪类和伪元素的区别</h3><p>都是不存在于 DOM 文档中的虚拟元素，虽然逻辑上存在，但并不实际存在于 DOM 树中。<br>伪类的效果可以通过添加实际的类来实现。<br>伪元素的效果可以通过添加实际的元素来实现。<br>所以它们的本质区别就是是否抽象创造了新元素。<br>伪类只能使用 “:”，伪元素可以使用 “:” 也可以使用 “::”。</p><h2 id="JavaScript问题"><a href="#JavaScript问题" class="headerlink" title="JavaScript问题"></a>JavaScript问题</h2><h3 id="1-JS-基本数据类型和引用数据类型"><a href="#1-JS-基本数据类型和引用数据类型" class="headerlink" title="1. JS 基本数据类型和引用数据类型"></a>1. JS 基本数据类型和引用数据类型</h3><p>基本：null、undefined、boolean、number、string、symbol<br>引用：Obect、Array、Function、Data<br>基本数据类型指的是简单的数据段，是按值访问的，因为可以直接操作保存在变量中的实际值。引用数据类型指的是有多个值构成的对象，改变引用数据类型是操作对象在栈内存中的引用地址</p><h3 id="2-原型和原型链"><a href="#2-原型和原型链" class="headerlink" title="2. 原型和原型链"></a>2. 原型和原型链</h3><p>每个”构造函数”中都有一个默认的属性， 叫做 prototype， prototype 属性保存着一个对象， 这个对象我们称之为”原型对象”， prototype 指向它的原型对象</p><p>每个”原型对象”中都有一个默认的属性， 叫做 constructor， constructor 指向当前原型对象对应的那个”构造函数”<br>通过构造函数创建出来的对象我们称之为”实例对象”， 每个”实例对象”中都有一个默认的属性， 叫做<strong>proto__， __proto</strong> 指向创建它的那个构造函数的”原型对象”</p><h3 id="3-JS-的传参"><a href="#3-JS-的传参" class="headerlink" title="3. JS 的传参"></a>3. JS 的传参</h3><p>按值传递(call by value)是最常用的求值策略：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。（深拷贝？）通过自定义函数实现深拷贝（递归遍历对象）</p><ol><li>for in 遍历对象中所有属性，取出对应值</li><li>通过 sourceValue.constructor 拿到这个对象的构造函数的类型，新建对象或数组</li><li>取值如果是引用数类型，将遍历到的属性值复制给新建的空对象或数组，否则直接复制之前属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过遍历拿到 source 中的所有属性，取出当前遍历到的属性对应的值，判断当前的取值是否是引用数据类型（对象、数组、函数，一般是对象嵌套），通过 sourceValue.constructor 拿到这个对象的构造函数的类型，然后新建这个对象或数组，再次调用深拷贝，将遍历到的属性的值拷贝给新建的对象或数组，如果不是引用数据类型，之前的属性拷贝即可</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deCopy</span>(<span class="params">target， source</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> key <span class="keyword">in</span> source</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> sourceValue = souce[key];</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">sourceValue <span class="keyword">instanceof</span> <span class="built_in">Object</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> subTarget = <span class="keyword">new</span> sourceValue.constructor;</span><br><span class="line">            deCopy(subTarget， sourceValue);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            target[key] = sourceValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>按引用传递(call by reference)时，函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。（浅拷贝？）</p><p>按引用传递会使函数调用的追踪更加困难，有时也会引起一些微妙的 BUG。按值传递由于每次都需要克隆副本，对一些复杂类型，性能较低。两种传值方式都有各自的问题。可能很多人都是做后端的，所有会想到“引用传递”，然而实际上却不是，导致了问题的产生。</p><h3 id="4-跨域"><a href="#4-跨域" class="headerlink" title="4. 跨域"></a>4. 跨域</h3><p>协议、域名、端口三者有一个不同就会引起跨域的错误问题<br>解决：JSONP：通过动态创建 script 标签，其 src 指向非同源的 url，并传递一个 callback 参数作为函数名的函数的调用和一系列参数，页面接收到响应后执行回调并对数据进行处理。CORS：服务器端操作，设置 http header</p><h3 id="5-数组去重"><a href="#5-数组去重" class="headerlink" title="5. 数组去重"></a>5. 数组去重</h3><p>方法一：倒进集合再倒出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>([<span class="number">1</span>， <span class="number">2</span>， <span class="number">2</span>， <span class="number">3</span>， <span class="number">4</span>， <span class="number">5</span>， <span class="number">5</span>])]</span><br><span class="line"><span class="comment">//[1， 2， 3， 4， 5]</span></span><br></pre></td></tr></table></figure><p>方法二：indexOf()<br>方法三：双重循环（先排序然后用 splice ）</p><h3 id="6-ES6-的symol是什么，适用场景有什么"><a href="#6-ES6-的symol是什么，适用场景有什么" class="headerlink" title="6. ES6 的symol是什么，适用场景有什么"></a>6. ES6 的symol是什么，适用场景有什么</h3><p>一种特殊的数据类型，定义不可更改，适合用来作为属性名标识独一无二的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个symbol类型的值</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s);<span class="comment">//&quot;symbol&quot;</span></span><br></pre></td></tr></table></figure><p>用作对象属性、模拟类的私有方法</p><h3 id="7-async-和-await，如何捕获异常"><a href="#7-async-和-await，如何捕获异常" class="headerlink" title="7. async 和 await，如何捕获异常"></a>7. async 和 await，如何捕获异常</h3><p>写法跟 generator 很像，就是将星号替换成 async，将 yield 替换成 await。async 函数返回一个 promise 对象，如果 async函数没有返回值，它会返回 Promise.resolve(undefined)。如果 await 等到的不是一个 promise 对象，那跟着的表达式的运算结果就是它等到的东西。<br>使用场景：需要 promise 链式调用的时候，每个步骤都是异步的，且依赖上一步的执行结果<br>try{} catch{} finally<br>try 语句：里面是填写 js 代码，里面可以接 throw 语句，抛出自己填写的报错信息（一般抛出 throw new Error(“”))，并且 try 里面的执行语句终止，catch 的变量 e 会接收这个错误；throw 会在离自己最近的 try 语句中生效.<br>catch: 如果 try 语句里面有错误，catch 会返回错误的具体信息；需要一个变量 e 来接收错误，e 只在自己的 catch 语句中生效。变量 e 有几个属性，e.stack 调用栈信息；e.message 具体的错误原因；e.name: 错误类型函数<br>finally：里面的代码永远可以运行，不管前面有没有错误。</p><h3 id="8-防抖和节流"><a href="#8-防抖和节流" class="headerlink" title="8. 防抖和节流"></a>8. 防抖和节流</h3><p>防抖是事件触发 n 秒后执行会掉，如果在这 n 秒内又被触发，则重新计时。使用场景：提交按钮时防止多次提交，只执行最后一次提交。<br>节流是 n 秒内只能触发一次函数，如果 n 秒内多次触发，只有一次生效。使用场景：拖拽在固定时间内只执行一次，防止超高频率触发位置变动；缩放时监控浏览器 resize</p><h4 id="9-类数组转换为数组的方法"><a href="#9-类数组转换为数组的方法" class="headerlink" title="9. 类数组转换为数组的方法"></a>9. 类数组转换为数组的方法</h4><p>使用 Array.from()<br>使用 Array.prototype.slice.call()<br>使用 Array.prototype.forEach() 进行遍历并生成新的数组<br>转换后数组的长度由 length 属性决定。索引不连续时转换结果是连续的，会自动补位</p><h4 id="10-ES6-新特性"><a href="#10-ES6-新特性" class="headerlink" title="10. ES6 新特性"></a>10. ES6 新特性</h4><p>const和let<br>模板字符串<br>箭头函数<br>对象和数组解构<br>对象超类：ES6 允许在对象中使用 super 方法<br>for…of 和 for…in，for…of 用于遍历一个迭代器，如数组，for…in 用来遍历对象中的属性<br>ES6中的类：ES6 中支持 class 语法，不过，ES6 的 class 不是新的对象继承模型，它只是原型链的语法糖表现形式。<br>函数的参数默认值<br>Spread / Rest 操作符<br>二进制和八进制字面量</p><h4 id="11-语句和表达式的区别"><a href="#11-语句和表达式的区别" class="headerlink" title="11. 语句和表达式的区别"></a>11. 语句和表达式的区别</h4><p>语句和表达式的区别在于，语句是为了进行某种操作，一般情况下不需要返回值，而表达式都是为了得到返回值，一定会返回一个值（这里的值不包括undefined）。<br>例如：var a = 1 + 2 是语句<br>1 + 2 是表达式</p><h4 id="12-前端模块化和组件化"><a href="#12-前端模块化和组件化" class="headerlink" title="12. 前端模块化和组件化"></a>12. 前端模块化和组件化</h4><p>我们把每一个 .js 文件都视为一个 块，模块内部有自己的作用域，不会影响到全局。并且，我们 约定一些关键词来进行依赖声明和 API 暴露。而这些约定的关键词就是通过制定一些 规范 去进行规范的。比较有名模块化规范的是 CMD、AMD、CommonJS 和 ES6 Module。Webpack 是模块化工具</p><p>将模板、样式和逻辑都抽象出来独立出来的做法称之为组件化。比如说，我们在开发 Button 组件的时候，不再需要分别在几个文件夹之间跳来跳去，去修改它们的模板、样式和逻辑。我们只需要在公共的 Button 组件的文件夹里修改就好了。Vue 和 React 也是组件化的框架</p><h4 id="13-为什么对象在JavaScript中不可迭代"><a href="#13-为什么对象在JavaScript中不可迭代" class="headerlink" title="13. 为什么对象在JavaScript中不可迭代"></a>13. 为什么对象在JavaScript中不可迭代</h4><p>直接原因：ES6中的 Object.prototype 没有实现 Symbol.iterator 属性。<br>对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。<br>部署了遍历器接口的对象其实就是 ES6 里的 Map 结构，现在 ES6 中内置了数据结构 Map，所以很方便地实现了集合对象。</p><h3 id="14-js继承方式"><a href="#14-js继承方式" class="headerlink" title="14. js继承方式"></a>14. js继承方式</h3><p>原型链继承：将父类的实例作为子类的原型<br>构造继承：使用 call()、apply() 或 bind() 方法继承父类构造函数中的属性<br>实例继承：为父类实例添加新特性，作为子类实例返回<br>组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用<br>寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p><h3 id="15-const定义的变量真的不可改变吗"><a href="#15-const定义的变量真的不可改变吗" class="headerlink" title="15. const定义的变量真的不可改变吗"></a>15. const定义的变量真的不可改变吗</h3><p>仅限于 const 定义基本数据类型</p><h3 id="16-什么是DOM事件流，如何阻止事件冒泡"><a href="#16-什么是DOM事件流，如何阻止事件冒泡" class="headerlink" title="16. 什么是DOM事件流，如何阻止事件冒泡"></a>16. 什么是DOM事件流，如何阻止事件冒泡</h3><p>一个事件的生命周期有三个阶段：捕捉，目标，冒泡。</p><ol><li>捕捉阶段<br>当某个事件被触发时，浏览器会找到涉及的元素。涉及的元素称为目标。浏览器会找出 body 元素和目标之间所有的元素并分别检查它们，看其有没有事件绑定。浏览器会先触发外层事件的处理器，最后才会轮到目标的事件处理器。</li><li>目标阶段<br>当捕捉阶段完成后，浏览器会触发目标元素上任何已添加的事件类型监听器，这里的先后顺序是按照事件定义的先后顺序来的。</li><li>冒泡阶段<br>冒泡阶段的顺序与捕捉阶段的顺序刚好相反，在此阶段，浏览器会优先处理目标的事件处理器，然后一层层往外处理其余的事件处理器。</li></ol><p>阻止事件冒泡，防止事件冒泡而带来不必要的错误和困扰。<br>这个方法就是：stopPropagation()</p><h3 id="17-事件委托"><a href="#17-事件委托" class="headerlink" title="17. 事件委托"></a>17. 事件委托</h3><p>在外部节点添加一个事件处理器，并根据 target 属性判断事件来源，这样可以把内部共用的事件绑定到外部</p><h3 id="18-事件循环"><a href="#18-事件循环" class="headerlink" title="18. 事件循环"></a>18. 事件循环</h3><p>nodejs 是单线程执行的，同时它又是基于事件驱动的非阻塞 IO 编程模型，事件循环机制是实现这一特性的原理<br>异步操作时，将任务给到另外的线程（CPU 的其它核），异步事件触发之后，就会通知主线程，主线程执行相应事件的回调。</p><p>执行顺序<br>程序运行会从上至下依次执行所有的同步代码<br>在执行的过程中如果遇到异步代码会将异步代码放到事件循环中<br>当所有同步代码都执行完毕后，JS 会不断检测 事件循环中的异步代码是否满足条件<br>一旦满足条件就执行满足条件的异步代码</p><h3 id="19-ES6的Class有什么好处"><a href="#19-ES6的Class有什么好处" class="headerlink" title="19. ES6的Class有什么好处"></a>19. ES6的Class有什么好处</h3><p>lass 是 ES6 提供的更接近于传统语言的的写法，作为对象的模板.通过 class关键字，可以定义类<br>class 写法只是一个语法糖，它只是让对象原型的写法更加清晰，更像面向对象编程的语法</p><h3 id="18-全局作用域和函数作用域"><a href="#18-全局作用域和函数作用域" class="headerlink" title="18. 全局作用域和函数作用域"></a>18. 全局作用域和函数作用域</h3><p>全局作用域在页面打开时被创建，页面关闭时被销毁<br>编写在script标签中的变量和函数，作用域为全局，在页面的任意位置都可以访问到<br>在全局作用域中有全局对象window，代表一个浏览器窗口，由浏览器创建，可以直接调用<br>全局作用域中声明的变量和函数会作为window对象的属性和方法保存</p><p>调用函数时，函数作用域被创建，函数执行完毕，函数作用域被销毁<br>每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的<br>在函数作用域中可以访问到全局作用域的变量，在函数外无法访问到函数作用域内的变量<br>在函数作用域中访问变量、函数时，会先在自身作用域中寻找，若没有找到，则会到函数的上一级作用域中寻找，一直到全局作用域<br>在函数作用域中也有声明提前的特性，对于变量和函数都起作用，此时函数作用域相当于一个小的全局作用域，详细声明提前请看声明提前部分</p><h3 id="19-forEach-和-map"><a href="#19-forEach-和-map" class="headerlink" title="19. forEach 和 map"></a>19. forEach 和 map</h3><p>共同点<br>只能遍历数组<br>都是循环遍历数组中的每一项<br>每一次执行匿名函数都支持三个参数，数组中的当前项 item，当前项的索引 index ，原始数组 input<br>匿名函数中的 this 都是指 window</p><p>不同点<br>forEach 没有返回值，不能 return；map 有返回值，可以 return</p><h3 id="20-this"><a href="#20-this" class="headerlink" title="20. this"></a>20. this</h3><p>this指向什么取决函数的调用形式，而不取决于函数的在哪调用，也不取决于在哪定义。<br>当一个函数以方法的形式被调用时，如 array.length，函数的 this 就是调用它的对象。<br>以纯函数形式调用时，this 就是 window，但用 new 来调用 this 时，this 就是那个新建的对象，如构造函数。<br>this 永远不能被赋值，即 this 不能写在等号左边。</p><h3 id="21-图片懒加载原理"><a href="#21-图片懒加载原理" class="headerlink" title="21. 图片懒加载原理"></a>21. 图片懒加载原理</h3><p>一张图片就是一个 img 标签，浏览器是否发起请求图片是根据 img 的 src 属性，所以实现懒加载的关键就是，在图片没有进入可视区域时，先不给 img 的 src 赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给 src 赋值。<br>实现懒加载有四个步骤，如下：<br>1.加载loading图片<br>2.判断哪些图片要加载【重点】<br>3.隐形加载图片<br>4.替换真图片</p><h3 id="22-垃圾回收机制"><a href="#22-垃圾回收机制" class="headerlink" title="22. 垃圾回收机制"></a>22. 垃圾回收机制</h3><p>调用函数的时候，系统会分配对应的空间给这个函数使用（空间大小的情况一般由这个函数的变量和形参决定），当函数试用完毕以后，这个内存空间要释放，还给系统，在函数内部声明的变量和形参是属于当前函数的内存空间的</p><h3 id="23-浏览器不同页面之间怎么传递消息"><a href="#23-浏览器不同页面之间怎么传递消息" class="headerlink" title="23. 浏览器不同页面之间怎么传递消息"></a>23. 浏览器不同页面之间怎么传递消息</h3><ol><li>通过 form 表单传递参数：注意表单元素隐藏按钮的使用</li><li>通过带参数的 url 传递：url?参数名1=值1&amp;参数名2=值2</li><li>请求 request 对象：将数据绑定到 request 对象上，通过 request 对象 getAttribute 和 setAttribute 方法读写</li><li>用户会话 session 对象：将数据绑定到 session 对象上，通过 session 对象 getAttribute 和 setAttribute 方法读写</li><li>application 对象：将数据绑定到 application 对象上，通过 application 对象 getAttribute 和 setAttribute 方法读写</li><li>cookie 对象：将数据写到到客户端浏览器 cookie 文件中<br>其中方式一、方式二只能实现字符串参数的传递，方式三、四、五、六可以实现对象的传递（方式六需要对象序列化后进行存储）。<br>方式一、方式二、方式三数据传递只能请求页面获取数据，而方式四、五、六可以在多个不同页面获取数据对象。<br>方式四和六保存的数据对象都是和某个用户相关的信息，不同的是方式四将数据保存到服务器内存中，方式六将数据保存到客户端内存中。<br>方式五保存的数据对象都是和所有用户相关的信息，数据也是保存到服务器内存中。</li></ol><h3 id="24-如果一个地区的页面加载特别慢，是因为什么原因，该怎么处理"><a href="#24-如果一个地区的页面加载特别慢，是因为什么原因，该怎么处理" class="headerlink" title="24. 如果一个地区的页面加载特别慢，是因为什么原因，该怎么处理"></a>24. 如果一个地区的页面加载特别慢，是因为什么原因，该怎么处理</h3><p>使用cdn，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率</p><h3 id="25-预检请求和简单请求"><a href="#25-预检请求和简单请求" class="headerlink" title="25. 预检请求和简单请求"></a>25. 预检请求和简单请求</h3><p>对那些可能对服务器数据产生副作用的 HTTP 请求方法，浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。</p><p>按照预检请求的理解，简单请求就是对服务器无副作用的请求。</p><h3 id="26-箭头函数没有arguments，怎么获取不知道数量的参数"><a href="#26-箭头函数没有arguments，怎么获取不知道数量的参数" class="headerlink" title="26. 箭头函数没有arguments，怎么获取不知道数量的参数"></a>26. 箭头函数没有arguments，怎么获取不知道数量的参数</h3><p>可以使用 ES6 的解构语法来代替。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;函数的参数是：&#x27;</span>， args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 函数的参数是： [1， 2， 3]</span></span><br></pre></td></tr></table></figure><h3 id="27-promise如何执行？promise-all和promise-race"><a href="#27-promise如何执行？promise-all和promise-race" class="headerlink" title="27. promise如何执行？promise.all和promise.race"></a>27. promise如何执行？promise.all和promise.race</h3><p>异步函数返回一个 promise，一个 promise 对象代表一个异步操作结果</p><ul><li>promise.then(f1，f2)<pre><code>如果异步函数状态为 resolved 执行 f1，状态为 rejected 执行 f2;f1 或者 f2 的参数是 promise 的 [[PromiseValue]]f1 和 f2 函数调用结果都要有返回值promise.then 的返回值是一个新的 promise 对象</code></pre><ul><li>promise1 = promise.then(f1，f2)<br>如果 f1 或者 f2 正常执行，那么 promise1 的状态就是 resolve，promise1.then(f3，f4) 会执行 f3<br>如果 f1 或者 f2 抛出了一个错误（throw），那么 promise1 的状态就是 reject，promise1.then(f3，f4) 会执行 f4<br>如果 f1 或者 f2 返回了一个新的 promise，那么 promise1 就是返回的新的 promise 对象，promise1.then(f3，f4) 的执行方式取决于新 promise 对象的状态</li><li>如果 promise.then() 里面没有传递参数<br>promise2  = promise1.then() 相当于下面<br>promise2 = promise1.then(val=&gt;val，reason=&gt;{throw reason})</li><li>如果 promise.then() 里面没有传递第一个参数，可以用 catch 代替 then<br>promise2  = p1.then(null，f1) 相当于下面<br>promise2  = p1.catch(f1)</li><li>promise 的链式跳转<br>promise1.then(f1).catch(f2).then(f3).catch(f4)，promise 状态为 resolve 直接可以跳转执行 then，为 reject 可以跳转执行 catch</li><li>Promise.resolve(val)<br>创建一个 [[PromiseStatus]]: “resolved”，[[PromiseValue]]: val 的 promise<br>Promise.reject(val)<br>创建一个 [[PromiseStatus]]: “rejected”，[[PromiseValue]]: val 的 promise</li></ul></li></ul><p>Promise.race(values)，返回一个在迭代器中遇到的第一个状态确定（settled）的 promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race=<span class="function"><span class="keyword">function</span>(<span class="params">values</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve，reject</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span> ; i&lt; values.length;i++</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(values[i]).then(resolve，reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>Promise.all(values)，返回一个 promise 实例。如果迭代器中所有的 promise 参数状态都是 resolved， 则 promise 实例的状态为 resolved，其 [[PromiseValue]] 为每个参数的 [[PromiseValue]] 组成的数组；<br>如果参数中的 promise 有一个失败（rejected），此实例的状态为 rejected，其 [[PromiseValue]] 为是第一个失败 promise 的 [[PromiseValue]]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">values</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve， reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = []</span><br><span class="line">    <span class="keyword">var</span> resolvedCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (value.length == <span class="number">0</span>) &#123;</span><br><span class="line">    resolve([])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(values[i]).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        result[i] = val</span><br><span class="line">        resolvedCount++</span><br><span class="line">        <span class="keyword">if</span> (resolvedCount == values.length) &#123;</span><br><span class="line">        resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;， reason =&gt; &#123;</span><br><span class="line">        reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="28-JS面向对象编程的理解"><a href="#28-JS面向对象编程的理解" class="headerlink" title="28. JS面向对象编程的理解"></a>28. JS面向对象编程的理解</h3><ol><li>抽象性：抽取核心数据,剔除无关属性和行为组成一个对象</li><li>封装性：封装就是隐藏内部的实现细节</li><li>继承性：所谓继承即为自己没有的继承别人有的，即在已有的对象的基础上进行拓展从而得到一个新的对象。</li><li>多态性：即同一操作对于不同的对象会有不同的结果。</li></ol><h3 id="29-SEO是什么"><a href="#29-SEO是什么" class="headerlink" title="29. SEO是什么"></a>29. SEO是什么</h3><p>搜索引擎优化，提高网站在搜索引擎里面的自然排名</p><h3 id="30-箭头函数和普通函数的区别"><a href="#30-箭头函数和普通函数的区别" class="headerlink" title="30. 箭头函数和普通函数的区别"></a>30. 箭头函数和普通函数的区别</h3><ol><li>外形不同：箭头函数使用箭头定义，普通函数中没有</li><li>箭头函数都是匿名函数。普通函数可以有匿名函数，也可以有具体名函数，但是箭头函数都是匿名函数。</li><li>箭头函数不能用于构造函数，不能使用 new。普通函数可以用于构造函数，以此创建对象实例。</li><li>箭头函数中 this 的指向不同。在普通函数中，this 总是指向调用它的对象，如果用作构造函数，this 指向创建的对象实例。箭头函数本身没有 this，但是它在声明时可以捕获其所在作用域的 this 供自己使用。call()、bind()、apply() 均不能改变其指向</li><li>箭头函数不绑定 arguments，取而代之用 rest 参数 … 解决</li><li>其他区别：<br>箭头函数不能 Generator 函数，不能使用 yeild 关键字。<br>箭头函数不具有 prototype 原型对象。<br>箭头函数不具有 super。<br>箭头函数不具有 new.target。</li></ol><h3 id="31-对fetch的理解"><a href="#31-对fetch的理解" class="headerlink" title="31. 对fetch的理解"></a>31. 对fetch的理解</h3><p>fetch() 方法是比 XMLHttpRequest 更简洁的 Ajax 请求。fetch 是全局量 window 的一个方法，第一个参数为 URL。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url (必须), options (可选)</span></span><br><span class="line">fetch(<span class="string">&#x27;/some/url&#x27;</span>, &#123;</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 出错了;等价于 then 的第二个参数,但这样更好用更直观 :(</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>见 CSDN 收藏夹</p><h2 id="计算机网络问题"><a href="#计算机网络问题" class="headerlink" title="计算机网络问题"></a>计算机网络问题</h2><h3 id="1-http-和-https"><a href="#1-http-和-https" class="headerlink" title="1. http 和 https"></a>1. http 和 https</h3><p>http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp），使浏览器更加高效，使网络传输减少<br>https：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版本，通过 SSL 加密</p><h3 id="2-http1-0-和-http2-0"><a href="#2-http1-0-和-http2-0" class="headerlink" title="2. http1.0 和 http2.0"></a>2. http1.0 和 http2.0</h3><p>HTTP1.x 的解析是基于文本。HTTP2.0 的协议解析采用二进制格式<br>HTTP2.0 比HTTP1.0 有多路复用，一个连接可以并发处理多个请求<br>header压缩，HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用encoder来减少需要传输的header大小<br>服务器推送：我们对支持 HTTP2.0 的 web server 请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源</p><h3 id="3-Cookie、SessionStronge、LocalStronge的区别"><a href="#3-Cookie、SessionStronge、LocalStronge的区别" class="headerlink" title="3. Cookie、SessionStronge、LocalStronge的区别"></a>3. Cookie、SessionStronge、LocalStronge的区别</h3><h4 id="在同一浏览器下有效期不同"><a href="#在同一浏览器下有效期不同" class="headerlink" title="在同一浏览器下有效期不同"></a>在同一浏览器下有效期不同</h4><p>Cookie:         默认是关闭浏览器后失效， 但是也可以设置过期时间<br>SessionStorage: 仅在当前会话(窗口)下有效，关闭窗口或浏览器后被清除， 不能设置过期时间<br>LocalStorage:   除非被清除，否则永久保存</p><h4 id="容量不同"><a href="#容量不同" class="headerlink" title="容量不同"></a>容量不同</h4><p>Cookie 容量限制: 大小(4KB左右)和个数(20~50)<br>SessionStorage 和 LocalStorage 容量限制: 大小(5M左右)</p><h4 id="网络请求不同"><a href="#网络请求不同" class="headerlink" title="网络请求不同"></a>网络请求不同</h4><p>Cookie 网络请求:每次都会携带在 HTTP 请求头中，如果使用 cookie 保存过多数据会带来性能问题<br>SessionStorage 和 LocalStorage 网络请求: 仅在浏览器中保存，不参与和服务器的通信</p><h4 id="应用场景不同"><a href="#应用场景不同" class="headerlink" title="应用场景不同"></a>应用场景不同</h4><p>Cookie:         判断用户是否登录<br>sessionStorage: 表单数据<br>LocalStorage:   购物车</p><h4 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h4><p>Express 中使用 res.cookie() 一个验证身份的字符串，网站在用户验证成功之后都会设置一个 cookie，只要 cookie 没有过期，用户就可以自由浏览这个网站的任意页面不需要再次登录<br>localStorage.setItem(item，value)<br>localStorage.getItem(item)<br>localStorage.removeItem(item)<br>sessionStorage 和 localStorage 用法一样，但是它只保存数据到浏览器关闭，不会触发 onstorage 事件</p><h4 id="4-强缓存和协商缓存"><a href="#4-强缓存和协商缓存" class="headerlink" title="4. 强缓存和协商缓存"></a>4. 强缓存和协商缓存</h4><p>强缓存：服务器通知浏览器一个缓存时间，在缓存时间内的请求会直接实用缓存，不在执行比较缓存策略<br>协商缓存：让客户端和服务器之间实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息种的 Etag 和 Last-Modified 通过请求发送给服务器，由服务器校验，返回304时直接使用缓存</p><h3 id="5-进程和线程"><a href="#5-进程和线程" class="headerlink" title="5. 进程和线程"></a>5. 进程和线程</h3><p>进程是资源分配的最小单位，线程是 CPU 调度的最小单位。一个进程里面可以有多个线程，线程是共享了进程的上下文环境，的更为细小的 CPU 时间段。CPU 运行一个软件相当于打开一个了进程，执行该软件里面的 1 个功能相当于打开一个线程</p><h3 id="6-https加密原理"><a href="#6-https加密原理" class="headerlink" title="6. https加密原理"></a>6. https加密原理</h3><ol><li><p>HTTPS 对称加密<br>服务器每次发送真实数据前，会先生成一把密钥传输（以明文方式传输密钥容易被劫持）给客户端，服务器给客户端发送的真实数据会先用这把密钥进行加密，客户端收到加密数据后再用密钥进行解密（客户端给服务器发送数据同理）</p></li><li><p>HTTPS 非对称加密<br>客户端和服务器都有两把密钥，一把公钥一把私钥（公钥加密的数据只有私钥才能解密，私钥加密的数据只有公钥才能解密），服务器在给客户端发送真实数据前，先用客户端明文传输给服务器的公钥进行加密，客户端收到后用自己的私钥进行解密，反之同理</p></li><li><p>HTTPS 对称加密 + 非对称加密<br>鉴于 HTTPS 非对称加密在加密时速度特别慢，可使用 HTTPS 对称加密 + 非对称加密（以非对称加密的方式传输对称加密密钥），接着就可使用对称加密的密钥传输数据。非对称加密之所以不安全是因为客户端不知道接收的公钥是否属于服务器</p></li><li><p>HTTPS 数字证书<br>核心在于证明客户端接收的公钥是属于服务器的，解决这个问题方法是使用数字证书（即找到一个大家都认可的认证中心 CA）<br>服务器在给客户端传输公钥的过程中，会将公钥+服务器个人信息通过 hash 算法生成信息摘要，为防止信息摘要被掉包服务器会用 CA 提供的私钥对信息摘要加密形成数字签名。最后还会将没有进行 hash 算法计算的服务器个人信息+公钥和数字签名合并在一起形成数字证书。<br>客户端拿到数字证书后，用 CA 提供的公钥对数字签名进行解密得到信息摘要，然后对数字证书中服务器个人信息+公钥进行hash 得到另一份信息摘要，两份信息摘要进行比对，若一样则是目标服务器，否则不是。<br>服务器会申请证书，客户端会内置证书。</p></li></ol><h3 id="7-安全管理"><a href="#7-安全管理" class="headerlink" title="7. 安全管理"></a>7. 安全管理</h3><ul><li>XSS 注入：往 web 页面插入恶意的 html 标签或者 js 代码。对用户输入的内容，需要转码（大部分时候要服务端来处理，偶尔也需要前端处理），禁止使用 eval 函数，尽量采用 post 而不使用 get 提交表单；</li><li>https：这个显然是必须的，好处非常多；</li><li>CSRF：通过伪装来自受信任用户的请求。要求服务端加入 CSRF 的处理方法（至少在关键页面加入），添加校验 token 等；</li></ul><h2 id="数据结构与算法问题"><a href="#数据结构与算法问题" class="headerlink" title="数据结构与算法问题"></a>数据结构与算法问题</h2><h3 id="栈-stack-和堆-heap-的区别"><a href="#栈-stack-和堆-heap-的区别" class="headerlink" title="栈(stack)和堆(heap)的区别"></a>栈(stack)和堆(heap)的区别</h3><ol><li>空间分配：栈由操作系统自动分配释放；堆需要由程序员释放或程序结束时由 OS 回收</li><li>结构区别：堆类似于一棵树，如堆排序；栈是一种先进后出的数据结构，类似于往箱子里放书取书，最先放进去的书在最底，拿出来时最后拿</li><li>缓存方式：堆使用二级缓存，生命周期由虚拟机的垃圾回收算法决定；栈使用的是一级缓存，调用时处于存储空间中，调用完毕立刻释放</li></ol><h3 id="递归求斐波那契数列"><a href="#递归求斐波那契数列" class="headerlink" title="递归求斐波那契数列"></a>递归求斐波那契数列</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归方式求1到100的和"><a href="#递归方式求1到100的和" class="headerlink" title="递归方式求1到100的和"></a>递归方式求1到100的和</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n， m</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = n + m;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">m + <span class="number">1</span> &gt; <span class="number">100</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(n， m + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = add(<span class="number">1</span>， <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="数组有哪些方法"><a href="#数组有哪些方法" class="headerlink" title="数组有哪些方法"></a>数组有哪些方法</h3><p>对象继承方法：数组是一种特殊的对象，继承了 Object 的这三个方法<br>toString()       返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串<br>toLocaleString() 是 toString() 方法的本地化版本，经常返回与 toString() 方法相同的值，但也不总如此<br>valueOf()        返回数组对象本身</p><p>转换方法：<br>concat()        连接两个或更多的数组，并返回结果。<br>copyWithin()    从数组的指定位置拷贝元素到数组的另一个指定位置中。<br>entries()        返回数组的可迭代对象。<br>every()            检测数值元素的每个元素是否都符合条件。<br>fill()            使用一个固定值来填充数组。<br>filter()        检测数值元素，并返回符合条件所有元素的数组。<br>find()            返回符合传入测试（函数）条件的数组元素。<br>findIndex()        返回符合传入测试（函数）条件的数组元素索引。<br>forEach()        数组每个元素都执行一次回调函数。<br>from()            通过给定的对象中创建一个数组。<br>includes()        判断一个数组是否包含一个指定的值。<br>indexOf()        搜索数组中的元素，并返回它所在的位置。<br>isArray()        判断对象是否为数组。<br>join()            把数组的所有元素放入一个字符串。<br>keys()            返回数组的可迭代对象，包含原始数组的键(key)。<br>lastIndexOf()    搜索数组中的元素，并返回它最后出现的位置。<br>map()            通过指定函数处理数组的每个元素，并返回处理后的数组。<br>pop()            删除数组的最后一个元素并返回删除的元素。<br>push()            向数组的末尾添加一个或更多元素，并返回新的长度。<br>reduce()        将数组元素计算为一个值（从左到右）。<br>reduceRight()    将数组元素计算为一个值（从右到左）。<br>reverse()        反转数组的元素顺序。<br>shift()            删除并返回数组的第一个元素。<br>slice()            选取数组的一部分，并返回一个新数组。<br>some()            检测数组元素中是否有元素符合指定条件。<br>sort()            对数组的元素进行排序。<br>splice()        从数组中添加或删除元素。<br>toString()        把数组转换为字符串，并返回结果。<br>unshift()        向数组的开头添加一个或更多元素，并返回新的长度。<br>valueOf()        返回数组对象的原始值。</p><h3 id="遍历栈和树的时间复杂度"><a href="#遍历栈和树的时间复杂度" class="headerlink" title="遍历栈和树的时间复杂度"></a>遍历栈和树的时间复杂度</h3><p>树的四种遍历方式时间复杂度和空间复杂度都为O(N)<br>栈遍历的时间复杂度是O(N)</p><h3 id="JS怎么遍历字符串"><a href="#JS怎么遍历字符串" class="headerlink" title="JS怎么遍历字符串"></a>JS怎么遍历字符串</h3><p>可以用 for 循环配合 charAt 函数遍历字符串。循环从 0 开始，循环次数为 str.length ，在for循环中添加 str.charAt(i) ，charAt 中的值为循环中的次数，然后将结果输出，这样字符串就被遍历出来了</p><h2 id="性能优化问题"><a href="#性能优化问题" class="headerlink" title="性能优化问题"></a>性能优化问题</h2><h3 id="1-让加载更快"><a href="#1-让加载更快" class="headerlink" title="1. 让加载更快"></a>1. 让加载更快</h3><p>减少资源体积：压缩代码<br>减少访问次数：合并代码、SSR服务器端渲染，缓存<br>使用更快的网络：CDN</p><h3 id="2-让渲染更快"><a href="#2-让渲染更快" class="headerlink" title="2. 让渲染更快"></a>2. 让渲染更快</h3><p>CSS 放在 head，JS 放在 body 最下面<br>尽早开始执行 JS，用 DOMContentLoaded 触发<br>懒加载（图片懒加载、下滑加载更多、分页器）<br>对 DOM 查询进行缓存<br>将频繁的 DOM 操作，合并到一起插入到 DOM 结构<br>节流、防抖等常用性能优化方法</p><h3 id="3-Webpack"><a href="#3-Webpack" class="headerlink" title="3. Webpack"></a>3. Webpack</h3><p>loader 将除 js 以外的其它资源也当成 require 的资源，如图片，CSS， json， svg，字体，通过把这些非 js 资源转化为等价的 js 文件来实现<br>plugin 在 webpack 则是对整体的打包结果进行处理的一种插件机制（如混淆和压缩代码、编译时配置全局变量、自动加载模块、单独抽离样式等）<br>babel-loader 将 ES6 转化为 ES5<br>file-loader 将文件输出到一个文件夹中，在代码中通过相对URL去引用<br>url-loader 与 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中</p><h3 id="3-有哪些常见的-loader-和-plugin"><a href="#3-有哪些常见的-loader-和-plugin" class="headerlink" title="3. 有哪些常见的 loader 和 plugin"></a>3. 有哪些常见的 loader 和 plugin</h3><p>Loader:</p><ul><li>babel-loader：把 ES6 转换成 ES5</li><li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li><li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。<br>Plugin:</li><li>define-plugin：定义环境变量</li><li>commons-chunk-plugin：提取公共代码</li><li>uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</li></ul><h3 id="4-如何实现按需加载"><a href="#4-如何实现按需加载" class="headerlink" title="4. 如何实现按需加载"></a>4. 如何实现按需加载</h3><p>见CSDN收藏夹</p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="1-Vuex作用"><a href="#1-Vuex作用" class="headerlink" title="1. Vuex作用"></a>1. Vuex作用</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。可以将共享的数据保存到 Vuex 中，方便整个程序中的任何组件都可以获取和修改 Vuex 中保存的公共数据</p><p>每个 Vuex 应用的核心是 store，store 基本上是一个容器，包含着应用中的大部分状态。Vuex 的状态存储是响应式的，当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么响应的组件也会得到更新</p><p>改变 store 中状态的唯一途径是提交 mutation。这样可以方便的跟踪每个状态的变化</p><ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 Store 中获取数据。mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation： 唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 Mutation，而不是直接更改状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</li></ul><h3 id="2-Vue的双向绑定原理"><a href="#2-Vue的双向绑定原理" class="headerlink" title="2. Vue的双向绑定原理"></a>2. Vue的双向绑定原理</h3><p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><p>实现数据监听器 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者<br>实现一个指令解析器 Compile<br>实现一个 Watcher，作为 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图<br>Mvvm 入口函数，整合以上三者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;userName&quot;</span> /&gt;</span><br><span class="line">&lt;input v-bind:value=<span class="string">&quot;userName&quot;</span> v-on:input=<span class="string">&quot;userName = $event.target.value&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>第一行的代码其实只是第二行的语法糖。input 元素本身有个 oninput 属性，这是 HTML5 新增的，类似 onchange，每当输入框的内容发生变化，就会触发 oninput</p><h3 id="3-Vue生命周期"><a href="#3-Vue生命周期" class="headerlink" title="3. Vue生命周期"></a>3. Vue生命周期</h3><p>beforeCreate 阶段：vue 实例的挂载元素 el 和数据对象 data 都是 undefined，还没有初始化。<br>create d阶段：vue 实例的数据对象 data 有了，可以访问里面的数据和方法，未挂载到 DOM，el 还没有<br>beforeMount 阶段：vue 实例的 el 和 data 都初始化了，但是挂载之前为虚拟的dom节点<br>mounted 阶段：vue 实例挂载到真实 DOM 上，就可以通过 DOM 获取 DOM 节点<br>beforeUpdate 阶段：响应式数据更新时调用，发生在虚拟 DOM 打补丁之前，适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器<br>updated 阶段：虚拟 DOM 重新渲染和打补丁之后调用，组成新的 DOM 已经更新，避免在这个钩子函数中操作数据，防止死循环<br>beforeDestroy 阶段：实例销毁前调用，实例还可以用，this 能获取到实例，常用于销毁定时器，解绑事件<br>destroyed 阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁</p><h3 id="4-keep-alive做了什么，对生命周期有什么影响"><a href="#4-keep-alive做了什么，对生命周期有什么影响" class="headerlink" title="4. keep alive做了什么，对生命周期有什么影响"></a>4. keep alive做了什么，对生命周期有什么影响</h3><p>keep-alive 是 vue 内置的一个组件，可以被包含的组件保留状态，或避免重新渲染。</p><p>activated 和 deactivated<br>keep-alive 的生命周期</p><ol><li>activated： 页面第一次进入的时候，钩子触发的顺序是 created-&gt;mounted-&gt;activated</li><li>deactivated: 页面退出的时候会触发 deactivated，当再次前进或者后退的时候只触发 activated</li></ol><h3 id="5-父子组件怎么传值"><a href="#5-父子组件怎么传值" class="headerlink" title="5. 父子组件怎么传值"></a>5. 父子组件怎么传值</h3><ol><li>父向子传值 props</li><li>子组件向父组件传值 $emit</li><li>父组件调用子组件的方法通过 ref，在 DOM 元素上使用 $refs 可以迅速进行 dom 定位，类似于 \$(“selectId”)，使用 this.$refs.paramsName 能更快的获取操作子组件属性值或函数</li><li>可以通过 $parent 和 $children 获取父子组件的参数，我们可以使用 \$children[i].paramsName 来获取某个子组件的属性值或函数，\$children 返回的是一个子组件数组</li><li>vue 全局事件 (eventBus)，在 main.js 里：window.eventBus = new Vue(); // 注册全局事件对象</li><li>兄弟之间的传值Vuex，在 state 里定义数据和属性，在 mutations 里定义函数 fn，在页面通过 this.$store.commit(‘fn’，params) 来触发函数</li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="1-Redux-介绍和如何使用"><a href="#1-Redux-介绍和如何使用" class="headerlink" title="1. Redux 介绍和如何使用"></a>1. Redux 介绍和如何使用</h3><p>redux 是为了解决 react 中组件与组件之间数据传递的问题。是一个全局的数据中心，监听 state 变更并将数据传递给下层组件<br>组建于组件之间的传递有三种情况：</p><ol><li>父组件传递数据给子组件：由于 redux 是一个单向数据流的框架，所以它的 props 就只能由父组件传递给子组件；</li><li>子组件传递给父组件：而子组件想父组件的传值的话则需要使用回调函数，</li><li>子组件与子组件：那么子组件与子组件之间的传递则相当麻烦，需要先将子组件的值传递给父组件，然后再由父组件在分发给指定的子组件，而 redux 则是解决这种问题的。<br>使用情况：非父子组件之间需要共享一些状态。需要将状态提升到最近的祖先</li></ol><p>用法<br>引入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/redux@4.0.4/dist/redux.js&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创造一个 store</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = Redux.createStore(<span class="function">(<span class="params">state， action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;，state)</span><br></pre></td></tr></table></figure><p>第一个参数是一个 reducer 函数，函数有 2 个参数，state 表示储存的数据，action 是一个对象，子组件里面通过 dispatch 函数来传递这个对象，这个 reducer 函数通过 action 的信息来触发对 state 的相关操作，返回一个新的 state<br>创建的 store 上面有两个常用的方法，dispatch 和 subscribe 方法<br>dispatch， 传递给下层组件，下层组件利用这个方法操作 state 触发更新<br>subscribe， 用来监听 state 变更<br>var unSubscribe = store.subscribe(fn)<br>数据变更时 fn 会运行，这个 fn 不接参数，并返回一个函数 unSubscribe<br>调用 unSubscribe 就会把这次的监听函数 subscribe 解绑</p><h3 id="2-React-如何实现数据绑定"><a href="#2-React-如何实现数据绑定" class="headerlink" title="2. React 如何实现数据绑定"></a>2. React 如何实现数据绑定</h3><p>在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。可以通过 shouldComponentUpdate 这个生命周期进行控制 pureRender<br>通过 JSX 中标签加属性实现视图和数据的绑定，类组件中 render 里的大括号动态传递 state，this.state 记录数据状态，函数组件中则使用 hooks 管理状态（个人理解，不知道对不对）<br>Vue 实现数据绑定考的是数据劫持（Object.defineProperty()） + 发布-订阅模式。在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件需要被被重新渲染。可以理解为每一个组件都已经自动获得了 shouldComponentUpdate，并且没有上面的子树问题限制</p><h3 id="3-React如何在重新加载页面时保留数据？"><a href="#3-React如何在重新加载页面时保留数据？" class="headerlink" title="3. React如何在重新加载页面时保留数据？"></a>3. React如何在重新加载页面时保留数据？</h3><p>使用浏览器 localstorage 来保存应用程序的状态。我们将整个存储数据保存在 localstorage 中，每当有页面刷新或重新加载时，我们从 localstorage 加载状态。</p><h3 id="4-state-和-props-的区别"><a href="#4-state-和-props-的区别" class="headerlink" title="4. state 和 props 的区别"></a>4. state 和 props 的区别</h3><p>state 是组件自己管理数据，控制自己的状态，可变，必须通过 setState 更改。<br>props 是外部传入的数据参数，不可变，父组件通过传递 props 给子组件来更新视图，子组件不能将 prop 送回父组件。这有助于维护单向数据流，通常用于呈现动态生成的数据。</p><h3 id="5-简述虚拟DOM和diff算法"><a href="#5-简述虚拟DOM和diff算法" class="headerlink" title="5. 简述虚拟DOM和diff算法"></a>5. 简述虚拟DOM和diff算法</h3><p>如果两棵树的根元素类型不同，React 会销毁旧树，创建新树。<br>对于类型相同的 React DOM 元素，只更新不同的属性，如果类型不同，直接替换。<br>当处理完这个 DOM 节点，React 就会递归处理子节点。<br>比较内容，如果有不同直接替换。</p><p>虚拟 DOM 是 JS 和真实 DOM 之间的一个缓存，利用 diff 算法比较虚拟 DOM 和真实 DOM 的不同后根据 diff 算法的替换规则更改真实 DOM，因为操作 DOM 非常耗费性能，所以虚拟 DOM 和 diff 算法是提高性能的一个重要方法</p><h3 id="6-函数组件和类组件"><a href="#6-函数组件和类组件" class="headerlink" title="6. 函数组件和类组件"></a>6. 函数组件和类组件</h3><p>函数组件是一个纯函数，接收参数并返回 React元素，并且没有任何副作用。没有生命周期函数和 state。<br>通过 class xx extends React.Component 这类组件可以通过 setState() 来改变组件的状态，并且可以使用生命周期函数</p><p>定义组件时，复杂场景用类组件，简单场景用函数组件。<br>简单：一个组件仅仅是为了展示数据。<br>复杂：一个组件中有一定业务逻辑，需要操作数据，并且此时需要使用 state。</p><h3 id="7-受控组件和非受控组件"><a href="#7-受控组件和非受控组件" class="headerlink" title="7. 受控组件和非受控组件"></a>7. 受控组件和非受控组件</h3><p>在 HTML 当中，像 input，textarea 和 select 这类表单元素会维持自身状态，并根据用户输入进行更新。 在 React 中，可变的状态通常保存在组件的 state 中，并且只能用 setState() 方法进行更新. React 根据初始状态渲染表单组件，接受用户后续输入，改变表单组件内部的状态。因此，将那些值由 React 控制的表单元素称为受控组件。</p><p>受控组件的特点：</p><ol><li>表单元素</li><li>由 React 通过 JSX 渲染出来</li><li>由 React 控制值的改变，想要改变元素的值，只能通过 React 提供的方法来修改</li></ol><p>非受控组件的状态是不受 React 控制的，而是组件本身具有的</p><p>非受控-&gt;受控组件的转化<br>首先把状态绑定到非受控组件的 value、checked 上。<br>然后监听该组件的 onChange 事件 用 e.target 获取 input 上面的数据 然后通过 setState 设置数据给 state 内的数据。</p><h3 id="8-Hooks及常用API"><a href="#8-Hooks及常用API" class="headerlink" title="8. Hooks及常用API"></a>8. Hooks及常用API</h3><ol><li>基础API<br> useState：通过在函数组件里调用它来给组件添加一些内部 state。React 会在重复渲染时保留这<br> state。useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并。<br> useEffect：在函数组件中执行副作用操作（副作用：和函数业务主逻辑关联不大，特定时间或事件中执行的动作，比如Ajax 请求后端数据，添加登录监听或取消登录、手动修改DOM等），useEffect 在每次 state 更新时执行，主要用来代替常用的生命周期函数。<br> useContext：与 Context 一样，是 React Hooks 中提供的更加高级的一种组件中传递值的方式，不再需要一层一层的向下传递 props，而是可以隔层传递。</li><li>其他的API<br> useReducer<br> useCallback<br> useMemo<br> useRef<br> useImperativeMethods<br> useLayoutEffect</li></ol><h3 id="9-useState、useEffect、useContext怎么用"><a href="#9-useState、useEffect、useContext怎么用" class="headerlink" title="9. useState、useEffect、useContext怎么用"></a>9. useState、useEffect、useContext怎么用</h3><ol><li>useState 函数（状态钩子），接收的参数会设置为 state 的初始值，返回一个数组 [state, 操作 state 的函数 setState]</li><li>useEffect 函数（生命周期钩子），相当于一个生命周期函数 componentDidMount 或 componentDidUpdate，直接在函数组件内部使用，每次渲染时都会调用。<br>第一个参数是一个函数，可以挂载 componentDidMount 或 componentDidUpdate 阶段需要的操作。这个函数可以有一个返回值函数，返回值函数会在函数组件 componentWillUnmount 阶段运行，可有挂载一些解绑操作；对于函数组件来讲，每次更新都会卸载再挂载；所以每次更新都会运行这个返回值函数。第二个参数见下面</li><li>useContext 先在外部创建一个 context 实例 var ColorContext = React.createContext()，Context 实例对象上面有个 ColorContext.Provider 组件开始向下传递数据，用于组件内部，如 &lt;ColorContext.Provider value={color}&gt;<br>接收数据方法<br>在后代组件中直接使用 useContext(Context 实例对象）接收数据。var color = useContext(ColorContext) 接收数据</li></ol><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>避免在 循环/条件判断/嵌套函数 中调用 hooks，保证调用顺序的稳定；<br>不能在 useEffect 中使用 useState，React 会报错提示；<br>类组件不会被替换或废弃，不需要强制改造类组件，两种方式能并存</p><h3 id="10-useEffect无限调用、第二个参数是什么"><a href="#10-useEffect无限调用、第二个参数是什么" class="headerlink" title="10. useEffect无限调用、第二个参数是什么"></a>10. useEffect无限调用、第二个参数是什么</h3><p>当你在 useEffect 中监听对象或数组的时候，它会无条件无限执行.你可以理解为引用数据类型数据在监听时每次都生成了一个新的数据.所以必定会执行。要监听的对象修改后的值不同于修改前的就会执行，但是每次执行时监听对象都会变化，将会无限次执行。</p><p>解决办法</p><ol><li>同步更新一个可检测的数据，然后监听这个数据</li><li>假如知道数据的走向，并且可以准确找到临界点，可以通过判断来打断无限更新的流程</li><li>对象监听，通过监听对象属性来判断对象变化，不符合监听规则就不无限执行</li></ol><p>第二个可选参数是一个数组，是要监听的数据，当组件刷新时如果发现数组的内容和上一次一样，那么就不会运行这个 useEffect 函数，用于性能优化；要确保数组中包含了外部作用域中会随时间变化并且在 effect 中使用的变量，否则你的代码会引用到先前渲染中的旧变量，如果是空数组表示每次都是完全一样的内容，不运行</p><h3 id="11-useEffect的作用，为什么在组件内部调用useEffect"><a href="#11-useEffect的作用，为什么在组件内部调用useEffect" class="headerlink" title="11. useEffect的作用，为什么在组件内部调用useEffect"></a>11. useEffect的作用，为什么在组件内部调用useEffect</h3><ol><li>通过调用 useEffect，你可以告诉 React 组件需要在渲染后执行某些操作。React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。在这个 effect 中，我们设置了 document 的 title 属性，不过我们也可以执行数据获取或调用其他命令式的 API。</li><li>与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。</li></ol><h3 id="12-useEffect什么时候会执行"><a href="#12-useEffect什么时候会执行" class="headerlink" title="12. useEffect什么时候会执行"></a>12. useEffect什么时候会执行</h3><p>在默认情况下、useEffect 在第一次渲染之后和每次更新之后都会执行。你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。</p><h3 id="13-useState"><a href="#13-useState" class="headerlink" title="13. useState"></a>13. useState</h3><p>在使用 useState 时，修改值时传入同样的值，组件不会重新渲染。<br>只会在当前组件的第一次渲染执行 useState 函数。<br>setUseState 时获取上一轮的值：我们在使用 useState 的第二个参数时，我们想要获取上一轮该 state 的值的话，只需要在 useState 返回的第二个参数，也就是我们上面的例子中的 setCount 使用时，传入一个参数，该函数的参数就是上一轮的 state 的值。</p><h3 id="14-Hooks相对普通Class有什么优势"><a href="#14-Hooks相对普通Class有什么优势" class="headerlink" title="14. Hooks相对普通Class有什么优势"></a>14. Hooks相对普通Class有什么优势</h3><p>简化代码：声明一个简单的组件只要简单的几行代码；<br>容易上手：对于初学者来说，相对复杂的 class 的声明周期，hooks 的钩子函数更好理解；<br>简化业务：充分利用组件化的思想把业务拆分成多个组件，便于维护；<br>方便数据管理：相当于三种的提升，各个组件不用通过非常复杂的 props 多层传输，解耦操作；<br>便于重构：业务改变或者接手别人的代码，代码都是比较容易读懂；</p><h3 id="15-什么情况下使用Class，什么情况下使用Hooks"><a href="#15-什么情况下使用Class，什么情况下使用Hooks" class="headerlink" title="15. 什么情况下使用Class，什么情况下使用Hooks"></a>15. 什么情况下使用Class，什么情况下使用Hooks</h3><h3 id="16-React-怎么获取到组件的-DOM"><a href="#16-React-怎么获取到组件的-DOM" class="headerlink" title="16. React 怎么获取到组件的 DOM"></a>16. React 怎么获取到组件的 DOM</h3><p>获取 DOM 是 ReactDOM.findDOMNode(this.refs.box_table)；<br>而 this.refs.box_table 直接取到的是组件，可以直接调用其内部的方法。</p><h3 id="17-React的生命周期方法有哪些"><a href="#17-React的生命周期方法有哪些" class="headerlink" title="17. React的生命周期方法有哪些"></a>17. React的生命周期方法有哪些</h3><p>componentWillMount:在渲染之前执行，用于根组件中的 App 级配置。<br>componentDidMount：在第一次渲染之后执行，可以在这里做 AJAX 请求，DOM 的操作或状态更新以及设置事件监听器。<br>componentWillReceiveProps：在初始化 render 的时候不会执行，它会在组件接受到新的 Props 时被触发，一般用于组件状态更新时子组件的重新渲染<br>shouldComponentUpdate：确定是否更新组件。默认情况下，它返回 true。如果确定在 state 或 props 更新后组件在重新渲染，则可以返回false，这是一个提高性能的方法。<br>componentWillUpdate：在 shouldComponentUpdate 返回 true 确定要更新组件之前件之前执行。<br>componentDidUpdate：它主要用于更新 DOM 以响应 props 或 state 更改。<br>componentWillUnmount：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器</p><h3 id="18-JXS是什么，有什么优势"><a href="#18-JXS是什么，有什么优势" class="headerlink" title="18. JXS是什么，有什么优势"></a>18. JXS是什么，有什么优势</h3><p>JSX 是 JavaScript 的语法扩展<br>增强 js 语义、结构清晰、抽象程度高（诞生了跨平台 React Native）、代码模块化</p><h3 id="19-setState有哪些使用方式"><a href="#19-setState有哪些使用方式" class="headerlink" title="19. setState有哪些使用方式"></a>19. setState有哪些使用方式</h3><ol><li>传入新的 state 对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  age: <span class="number">2</span>，</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>传入回调函数，并在回调函数里面返回新的 state 对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">prevState， props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age: prevState.age + props.age，</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="20-可以在Class组件里写Hook吗"><a href="#20-可以在Class组件里写Hook吗" class="headerlink" title="20. 可以在Class组件里写Hook吗"></a>20. 可以在Class组件里写Hook吗</h3><h3 id="21-React组件间的通信"><a href="#21-React组件间的通信" class="headerlink" title="21. React组件间的通信"></a>21. React组件间的通信</h3><p>父组件向子组件通信：props<br>子组件向父组件通信：回调函数<br>跨级组件通信：context、useContext、redux<br>没有嵌套关系的组件通信：eventEmitter，利用全局对象来保存事件，用广播的方式去处理事件。</p><h3 id="22-原生事件和React事件的区别"><a href="#22-原生事件和React事件的区别" class="headerlink" title="22. 原生事件和React事件的区别"></a>22. 原生事件和React事件的区别</h3><ul><li>React 事件使用驼峰命名，而不是全部小写。</li><li>通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串。</li><li>在 React 中你不能通过返回 false 来阻止默认行为。必须明确调用 preventDefault。</li></ul><h3 id="23-什么是HOC，有什么好处和应用场景"><a href="#23-什么是HOC，有什么好处和应用场景" class="headerlink" title="23. 什么是HOC，有什么好处和应用场景"></a>23. 什么是HOC，有什么好处和应用场景</h3><p>高阶组件和高阶函数相同。我们实现一个函数，传入一个组件，然后在函数内部再实现一个函数去扩展传入的组件，最后返回一个新的组件，这就是高阶组件的概念，作用就是为了更好的复用代码。<br>常用场景：权限控制、组件性能渲染追踪、页面复用</p><h3 id="24-useInterval和useDebounce"><a href="#24-useInterval和useDebounce" class="headerlink" title="24. useInterval和useDebounce"></a>24. useInterval和useDebounce</h3><p>useDebounce 钩子可让你消除任何快速变化的值。当在指定的时间段内未调用 useDebounce 钩子时，去抖动的值将仅反映最新的值。 你可以轻松地确保诸如 API 调用之类的昂贵操作不会过于频繁地执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDebounce</span>(<span class="params">value, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [debouncedValue, setDebouncedValue] = useState(value);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setDebouncedValue(value);</span><br><span class="line">    &#125;, delay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(handler);</span><br><span class="line">    &#125;;</span><br><span class="line">    &#125;, [value, delay]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> debouncedValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useInterval 设置了一个计时器，并且在组件 unmount 的时候清理掉了。 这是通过组件生命周期上绑定 setInterval 与 clearInterval 的组合完成的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useInterval</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> savedCallback = useRef();</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// Remember the latest callback.</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    savedCallback.current = callback;</span><br><span class="line">  &#125;);</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// Set up the interval.</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      savedCallback.current();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (delay !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> id = <span class="built_in">setInterval</span>(tick, delay);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [delay]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-你遇到最难的问题是怎样的？"><a href="#1-你遇到最难的问题是怎样的？" class="headerlink" title="1. 你遇到最难的问题是怎样的？"></a>1. 你遇到最难的问题是怎样的？</h3><h3 id="2-你在团队的突出贡献是什么？"><a href="#2-你在团队的突出贡献是什么？" class="headerlink" title="2. 你在团队的突出贡献是什么？"></a>2. 你在团队的突出贡献是什么？</h3><h3 id="3-最近在关注什么新技术"><a href="#3-最近在关注什么新技术" class="headerlink" title="3. 最近在关注什么新技术"></a>3. 最近在关注什么新技术</h3><h3 id="4-lodash有什么印象深刻的"><a href="#4-lodash有什么印象深刻的" class="headerlink" title="4. lodash有什么印象深刻的"></a>4. lodash有什么印象深刻的</h3><p>chunk，将数组进行切分<br>compact，去除假值（将所有的空值，0，NaN过滤掉）<br>uniq，数组去重。（将数组中的对象去重，只能去重数组不能去重对象）<br>merge，参数合并</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2019/12/25/hello-world/"/>
    <id>http://example.com/2019/12/25/hello-world/</id>
    <published>2019-12-24T16:00:00.000Z</published>
    <updated>2020-11-03T18:30:19.887Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
</feed>
