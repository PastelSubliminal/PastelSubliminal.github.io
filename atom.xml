<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>埃斯佩拉某处</title>
  
  <subtitle>刹那之拳的博客</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-11-15T17:33:30.845Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Zero_warmwine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>扫码点餐各个页面的制作过程</title>
    <link href="http://example.com/2020/11/15/%E6%89%AB%E7%A0%81%E7%82%B9%E8%8F%9C%E4%B8%80%E4%BA%9B%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2020/11/15/%E6%89%AB%E7%A0%81%E7%82%B9%E8%8F%9C%E4%B8%80%E4%BA%9B%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/</id>
    <published>2020-11-14T16:00:00.000Z</published>
    <updated>2020-11-15T17:33:30.845Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="扫码点餐各个页面是如何实现的"><a href="#扫码点餐各个页面是如何实现的" class="headerlink" title="扫码点餐各个页面是如何实现的"></a>扫码点餐各个页面是如何实现的</h1><h2 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h2><p>首先用到的模块是 ‘react-router-dom’ 的 withRouter 和封装好的 axios API。整个登录逻辑写在 withRouter中，在 jsx 里使用 ref 获得输入的用户名、密码、验证码，登录先 preventDefault 然后用户名密码验证码分别是 ref 获取到的当前输入值，使用 try-catch 用 post 请求发送给后端，如果成功就用 history.push 给 url 传值转跳页面，不然就 alert 后端设定好的错误信息。</p><h2 id="点餐界面："><a href="#点餐界面：" class="headerlink" title="点餐界面："></a>点餐界面：</h2><p>首先用到的模块是 ‘prop-types’，’immer’，’history’，’socket.io-client’。</p><p>菜单内容是一个函数组件，参数是 food，onupdate 和 amount，返回的 jsx 是一个菜单列表，列表里的每个菜都有按钮可以增减选择数量，使用 onupdate 来控制点击按钮时的菜品数量增减。<br>随后用到了 React 的属性验证功能 要求菜单内容这个函数组件必须要传参数且必须要传指定类型的参数。calTotaoPrice 是一个用 reduce 来计算下单总价的函数，初始值为 0 元。</p><p>购物车状态是一个函数组件，返回的 jsx 显示了当前下单总价，以及展开收起按钮，使用 useState 来控制是否展开，默认 false。</p><p>点餐主界面是一个类组件，state 里有三个属性：cart 数组里放当前点了的菜，foodMenu 数组里放当前提供可选的菜品列表，deskInfo 对象里是当前的餐桌号，顾客数，总价，点了的菜。</p><p>接下来是各个生命周期里做的事情：在 componentDidMount 中，首先用 props.match.params 拿到路由传递过来的参数 params，然后用 get 请求到当前餐桌 id 和菜单信息用 setState 设置为当前餐桌和当前菜单信息。为了同步同一餐桌不同用户间的点单，设置 socket 的路径和请求，在接入餐桌连接时用 socket.on 在 ‘cart food’ 时向后端发送字符串命令和餐桌 id。后端发回此桌面已点菜单，这里用到了 immer 的 produce：先定义一个变更，有数据时再执行这个变更，然后用 socket.on 在 ‘new food’ 时调用 foodChange 函数变更菜品和数量，下单成功时用 socket.on 在 ‘placeorder success’ 时用路由 push 点餐成功页面的路径并将订单状态设置为 order。componentWillUnmount 中关闭 socket 链接。</p><p>cartChange 函数用 socket.emit 在 ‘new food’ 时向后端发送当前餐桌 id，所点食物和数量。placeOrder 函数用于下单，用 post 请求向后端发送路径和当前订单信息后转跳到成功界面，state 设置为 res.data。</p><p>最后点餐主界面 render 了菜单列表，返回的菜单列表用 map 渲染，返回的是当前能点的菜的列表。</p><h2 id="菜品管理："><a href="#菜品管理：" class="headerlink" title="菜品管理："></a>菜品管理：</h2><p>列表中每个菜是一个函数组件，可以进行菜品的删改增查，使用了三个 hook 来管理状态：setFoodInfo、setIsModify、setFoodProps，默认分别是food、false、和属性是菜品各项信息的对象。save 函数 new 一个 FormDate 后将遍历到的菜品属性键值对插入进去，然后用 put 请求向后端放松当前菜品 id 和属性后将菜品信息设置为当前菜品信息。</p><p>change 和 imgChange 函数用于重新设置菜品信息，使用 setFoodProps 将菜品信息设置为当前传入事件参数的值即可。然后是菜品的删除、设置是否提供，用put请求向后端发送状态后使用 hook 变更菜品属性即可。最后 jsx 返回的是修改界面，根据是修改将对应的 html 样式返回即可。最后整个函数组件返回的是菜品展示图和一些功能按钮（修改、保存、下架、上架、删除）。</p><h2 id="订单管理："><a href="#订单管理：" class="headerlink" title="订单管理："></a>订单管理：</h2><p>首先用到的模块是 ‘socket.io-client’，’immer’ 和封装好的 axios API。订单状态用 hook 的 useState 管理。订单列表使用函数组件。</p><p>然后是实现各个逻辑的函数。使订单状态变为确认：用 put 请求向后端发送当前订单 id 的状态变更为 confirmed，然后用 setOrder 将订单的属性设置为当前属性为 confirmed，setComplete 同理。</p><p>删除订单则是直接向后端发送对应订单 id 的 delete 请求即可。最后订单列表返回显示总价格、人数、订单状态、打印、确认、完成、删除功能的 jsx。</p><p>订单管理使用类组件，state 为由 orders 组成的数组。</p><p>在订单管理的生命周期中，componentDidMount 首先获取参数，定义 socket 的路径和请求，在 on ‘connect’ 是向后端发送当前加入餐厅 id，在 on ‘new order’ 时发送在当前页面新增一个订单。用 get 请求获取当前订单。componentWillUnmount 中关闭 socket 连接，和删除订单的函数。最后 render 的是订单管理页面，根据订单长度 map 一个订单项列表。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>组件库的制作</title>
    <link href="http://example.com/2020/11/02/%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/"/>
    <id>http://example.com/2020/11/02/%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/</id>
    <published>2020-11-01T16:00:10.000Z</published>
    <updated>2020-11-01T19:12:14.237Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>提示，这里需要先学习一下Vue插件的API： <a href="https://cn.vuejs.org/v2/api/#Vue-use">https://cn.vuejs.org/v2/api/#Vue-use</a></p><p>在package.json中加一条命令，用于指定打包目标为库</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">       <span class="attr">&quot;lib&quot;</span>: <span class="string">&quot;vue-cli-service build --target lib packages/index.js&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令行输入 yarn lib<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEJTGN48rsMPNqepV548w.aV9yCjuYp5H*nXXXoZKA9OQcAEwBbHw6gozXNJsP3Bj03vyMNg8plvqrq.EVb1XGEc!/r" alt="image text"><br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEBfbeH.4zaLcWgHcrz4RpoL**GaE7I*bgaozV6IH8I7TX5KTg2xhcBQBejx.mi6v9OxZUOMOZFd*n4vUDp37*OU!/r" alt="image text"><br>打包完成，可以看到多了个dist文件夹，里面将我们的组件打包成了一个js文件，字体图标也打包好了，以后使用的话只要用dist文件夹就行了</p><p>接下来让我们整个项目用 pc-hub 管理一下，把打包好的dist放到npm上，提醒一下在index里要有install，不然不能作为Vue的插件也不能全局使用</p><p>接下来将my-ui上传到github上，这个不写了，主要是如何将组件库发布到npm上，需要做一点修改，首先将package.json中的 “private”: false 其次name属性要是npm上没有的包名，main属性设置为dist文件夹中以.umd.min.js结尾的文件路径，其他随意，以我的为例是:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;syhmy-ui&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;private&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;dist/my-ui.umd.in.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;auther&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ShiYuhao&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在打包文件夹中在新建一个.npmignore，跟.gitignore功能相似，只要用到dist即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 忽略目录</span><br><span class="line">examples&#x2F;</span><br><span class="line">packages&#x2F;</span><br><span class="line">public&#x2F;</span><br><span class="line"></span><br><span class="line"># 忽略指定文件</span><br><span class="line">vue.config.js</span><br><span class="line">babel.config.js</span><br><span class="line">*.map</span><br></pre></td></tr></table></figure><p>把打包好的文件上传到npm，如果装了nrm的，需要保证当前的源是npm的源，因为有些人会把源改到taobao去，得改回来，不然就不是上传到了npm。然后需要一个npm账号，没有的话注册一个<br>如图所示登陆成功，输入命令<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEIHVCb.TebOllO6KzbuUBEKtjz4kTeREg1qthzeU0dR*cDGXDRk6ylVBRHl08.vFxjb9CwI80fKBSRweAzxkA4w!/r" alt="image text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm public</span><br></pre></td></tr></table></figure><p>即可把包发布到npm上<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEP3bE1FZLFxGVG9C3cEWxQR.l1zzRnagmp5o28cq3mrPcbRNeupht4LVLQeHc956LAO7NErrXtuKfj21X0TF.IA!/r" alt="image text"><br>以后要更新你发布的npm包的话，要在package.json中修改版本号<br>如图，npm包可以正常下载，当成插件全局注册好后就可以使用了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>把packages处理成Vue插件</title>
    <link href="http://example.com/2020/11/02/%E6%8A%8Apackages%E5%A4%84%E7%90%86%E6%88%90vue%E6%8F%92%E4%BB%B6/"/>
    <id>http://example.com/2020/11/02/%E6%8A%8Apackages%E5%A4%84%E7%90%86%E6%88%90vue%E6%8F%92%E4%BB%B6/</id>
    <published>2020-11-01T16:00:00.000Z</published>
    <updated>2020-11-01T19:12:28.882Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>封装了几个Vue组件，怎么把它们制作制作成插件呢</p><p>先新建Vue项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create my-ui</span><br></pre></td></tr></table></figure><p>在my-ui文件夹中新建packages和examples文件夹，packages用来存放我们封装的所有组件，examples用来进行测试，把src改成examples</p><p>新建vue.config.js，写入如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      entry: <span class="string">&#x27;examples/main.js&#x27;</span>,</span><br><span class="line">      template: <span class="string">&#x27;public/index.html&#x27;</span>,</span><br><span class="line">      filename: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 扩展 webpack 配置，使 packages 加入编译</span></span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.module</span><br><span class="line">      .rule(<span class="string">&#x27;js&#x27;</span>)</span><br><span class="line">      .include.add(path.resolve(__dirname, <span class="string">&#x27;packages&#x27;</span>)).end()</span><br><span class="line">      .use(<span class="string">&#x27;babel&#x27;</span>)</span><br><span class="line">      .loader(<span class="string">&#x27;babel-loader&#x27;</span>)</span><br><span class="line">      .tap(<span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 修改它的选项...</span></span><br><span class="line">        <span class="keyword">return</span> options</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将封装好的vue组件全部放到packages文件夹中，同时也要打包字体图标文件，将fonts文件夹也放到packages文件夹中</p><p>这里需要了解Vue的install方法，见Vue官方文档Vue.use(plugin)，意思是想要做一个插件，插件只要导出一个install就行，在packages文件夹中新建index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整个包的入口</span></span><br><span class="line"><span class="comment">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件搜将被注册</span></span><br><span class="line"><span class="comment">// 导入颜色选择器组件</span></span><br><span class="line"><span class="keyword">import</span> ColorPicker <span class="keyword">from</span> <span class="string">&#x27;./color-picker&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">&#x27;./button&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Dialog <span class="keyword">from</span> <span class="string">&#x27;./dialog&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Input <span class="keyword">from</span> <span class="string">&#x27;./input&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Checkbox <span class="keyword">from</span> <span class="string">&#x27;./checkbox&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Radio <span class="keyword">from</span> <span class="string">&#x27;./radio&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Switch <span class="keyword">from</span> <span class="string">&#x27;./switch&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./fonts/font.scss&#x27;</span></span><br><span class="line"><span class="comment">// 存储组件列表</span></span><br><span class="line"><span class="keyword">const</span> components = [</span><br><span class="line">  ColorPicker,</span><br><span class="line">  Button,</span><br><span class="line">  Dialog,</span><br><span class="line">  Input,</span><br><span class="line">  Checkbox,</span><br><span class="line">  Radio,</span><br><span class="line">  Switch</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册</span></span><br><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历注册全局组件</span></span><br><span class="line">  components.forEach(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.component(component.name, component)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否是直接引入文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">  install(<span class="built_in">window</span>.Vue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 导出的对象必须具有 install，才能被 Vue.use() 方法安装</span></span><br><span class="line">  install,</span><br><span class="line">  <span class="comment">// 以下是具体的组件列表</span></span><br><span class="line">  ColorPicker,</span><br><span class="line">  Button,</span><br><span class="line">  Dialog,</span><br><span class="line">  Input,</span><br><span class="line">  Checkbox,</span><br><span class="line">  Radio,</span><br><span class="line">  Switch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在examples的main.js中输入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 导入组件库</span></span><br><span class="line"><span class="keyword">import</span> HmUI <span class="keyword">from</span> <span class="string">&#x27;./../packages&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(HmUI)</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这时就可以使用了，在examples中测试一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &lt;hm-button type=<span class="string">&quot;primary&quot;</span>&gt;按钮&lt;/hm-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>最后，examples文件夹是没用的，真正有用的是packages文件夹</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="前端基础" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>“[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)” what &amp; why?</title>
    <link href="http://example.com/2020/11/01/[&#39;1&#39;,%20&#39;2&#39;,%20&#39;3&#39;].map(parseInt)%20what%20&amp;%20why/"/>
    <id>http://example.com/2020/11/01/[&#39;1&#39;,%20&#39;2&#39;,%20&#39;3&#39;].map(parseInt)%20what%20&amp;%20why/</id>
    <published>2020-10-31T16:00:00.000Z</published>
    <updated>2020-11-03T19:20:20.219Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是真正的答案是[1, NaN, NaN]。</p><p>首先回顾一下，map函数的第一个参数callback：<br>var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])<br>这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。</p><p>而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。<br>parseInt(string, radix)<br>接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。</p><p>了解这两个函数后，我们可以模拟一下运行情况</p><ol><li>parseInt(‘1’, 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1</li><li>parseInt(‘2’, 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN</li><li>parseInt(‘3’, 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN<br>map函数返回的是一个数组，所以最后结果为[1, NaN, NaN]</li></ol><p>最后附上MDN上对于这两个函数的链接，具体参数可以到里面看<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map</a></p><p>原文链接：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/4">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/4</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="前端基础" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    <category term="习题" scheme="http://example.com/tags/%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>图的遍历——广度优先搜索和深度优先搜索</title>
    <link href="http://example.com/2020/10/30/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://example.com/2020/10/30/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</id>
    <published>2020-10-29T16:00:00.000Z</published>
    <updated>2020-11-01T08:19:24.393Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前置知识：图的相关术语和图的表示</p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>和树数据结构类似，我们可以访问图的所有节点。由两种算法可以对图进行遍历：<strong>广度优先搜索（breadth-first search，BFS）</strong>和<strong>深度优先搜索（depth-first search，DFS）</strong>。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查路径是否相同，检查图是否有环，等等。</p><p>在实现算法之前，让我们来更好的理解一下图遍历的思想。</p><p><strong>图遍历算法</strong>的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有完全被探索，对于两种图遍历算法，都需要明确指出第一个被访问的顶点。</p><p>完全探索第一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加入待访问的定点列表中。</p><p>为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。</p><p>广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点列表的数据结构。如下表所示</p><table><thead><tr><th align="left">算法</th><th align="left">数据结构</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">深度优先搜索</td><td align="left">栈</td><td align="left">将顶点存入栈，顶点是沿着路径被探索的，存在新的相邻顶点就去访问</td></tr><tr><td align="left">广度优先搜索</td><td align="left">队列</td><td align="left">将顶点存入队列，最先入队列的顶点先被搜索</td></tr></tbody></table><p>当要标注已经访问过的顶点时，我们用三种颜色来反映它们的状态。</p><ul><li>白色：表示该顶点还没有被访问。</li><li>灰色：表示该顶点被访问过，但并未被探索过。</li><li>黑色：表示该顶点被访问过且被完全探索过。</li></ul><p>这就是之前提到的务必访问每个顶点最多两次的原因。</p><p>为了有助于在广度优先和深度优先算法中标记定点。我们要使用 Colors 变量（作为一个枚举器），声明如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Colors = &#123;</span><br><span class="line">    WHITE: <span class="number">0</span>,</span><br><span class="line">    GREY: <span class="number">1</span>,</span><br><span class="line">    BLACK: <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两个算法还需要访问一个辅助对象来帮助存储顶点是否被访问过。在每个算法的开头，所有的顶点都会被标记为未访问（白色）。我们要用下面的函数来初始化每个顶点的颜色。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initColor = <span class="function"><span class="params">vertices</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> color = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertices.length; i++</span>)</span>&#123;</span><br><span class="line">        color[vertices[i]] = Colors.WHITE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有邻点（相邻顶点），就像一次访问图的一层。换句话说，就是先宽后深的访问顶点，如下图所示<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrENvAK4hCVLHst1Ssx8xTOzSnZk4FpVPApa5BpTrf.Ojk7.j1y4mouG74Usz7fdaq8H0JlVD3*KnGxqQgxCPgClA!/r" alt="Image text"><br>以下是从顶点v开始的广度优先搜索算法所遵循的步骤。</p><p>(1) 创建一个队列 Q。<br>(2) 标注 v 为被发现的（灰色），并将 v 入队列 Q。<br>(3) 如果 Q 非空，则运行以下步骤：<br>    (a) 将 u 从 Q 中出队列；<br>    (b) 标注 u 为被发现的（灰色）；<br>    (c) 将 u 所有未被访问过的邻点（白色）入队列；<br>    (d) 标注 u 为已被探索的（黑色）。</p><p>让我们来实现广度优先搜索算法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> breathFirstSearch = <span class="function">(<span class="params">graph, startVertex, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> startVertex = graph.getVertices;</span><br><span class="line">    <span class="keyword">const</span> adjList = graph.getAdjList;</span><br><span class="line">    <span class="keyword">const</span> color = initColor(vertices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">    queue.enqueue(startVertex);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">while</span>(<span class="params">!queue.isEmpty()</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> u = queue.dequeue();</span><br><span class="line">        <span class="keyword">const</span> neighbors = adjList.get(u);</span><br><span class="line">        color[u] = Colors.GREY;</span><br><span class="line">        <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> w = neighbors[i];</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">color[w] === Colors.WHITE</span>)</span>&#123;</span><br><span class="line">                color[w] = Colors.GREY;</span><br><span class="line">                queue.enqueue(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        color[u] = Colors.BLACK;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">            callback(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="深度优先搜素"><a href="#深度优先搜素" class="headerlink" title="深度优先搜素"></a>深度优先搜素</h2><p>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条卢静最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是是先深度后广度地访问顶点，如下图所示<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEO7a7xpq*swiCvkKkkTZecTjQEoR89aVQ*WEn7KMBcryBowgzBlEHeSnKkiqeKpdq1J*fk2xlJvTX4HmbNXqrUE!/r" alt="Image text"><br>深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点 v 未访问，则访问该顶点 v。</p><p>要访问顶点 v，照如下步骤做：<br>(1) 标注 v 为未被发现的（灰色）；<br>(2) 对于 v 的所有未访问（白色）的邻点 w，访问顶点 w；<br>(3) 标注 v 为已被探索的（黑色）；</p><p>深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）。</p><p>让我们来实现一下深度优先算法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> depthFirstSearch = <span class="function">(<span class="params">graph, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> startVertex = graph.getVertices();</span><br><span class="line">    <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">    <span class="keyword">const</span> color = initColor(vertices);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">color[vertices[i]] === Colors.WHITE</span>)</span>&#123;</span><br><span class="line">            depthFirstSearchVisit(vertices[i], color, adjList, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> depthFirstSearchVisit = <span class="function">(<span class="params">u, color, adjList, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    color[u] = Colors.GRAY;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">        callback(u)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> neighbors = adjList.get(u);</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> w = neighbors[i];</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">color[w] === Colors.WHITE</span>)</span>&#123;</span><br><span class="line">            depthFirstSearchVisit(w, color, adjList, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    color[u] = Colors.BLACK;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写此文的原因是在面试时面试官看我在简历上写了数据结构与算法(Leetcode120+)，便询问做的题以哪方面为主，答曰数组和树。一面让手写了一下先序遍历，这个写出来了，二面换了个人问广度优先搜索和深度优先搜索。啊这，答不上来。因为当时是在学习图的时候看到这两个概念，但是图已经是书本介绍的最后一个数据结构了，而且感觉不怎么常见，就没把那章节看完。<del>加上当时已经学到Node.js、计网、异步等信息量比较大的知识，后续更是在学框架写东西，就没再研究数据结构与算法了</del>（解释</p><p>所以这将成为本博客第一个数据结构与算法相关的文章。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>简单的React父子组件和平级组件之间传值</title>
    <link href="http://example.com/2020/10/30/%E7%AE%80%E5%8D%95%E7%9A%84React%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%92%8C%E5%B9%B3%E7%BA%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC/"/>
    <id>http://example.com/2020/10/30/%E7%AE%80%E5%8D%95%E7%9A%84React%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%92%8C%E5%B9%B3%E7%BA%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC/</id>
    <published>2020-10-29T16:00:00.000Z</published>
    <updated>2020-10-31T16:55:53.193Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.父组件对子组件传值 利用props属性传值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;I am &#123;<span class="built_in">this</span>.props.name&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Component name=<span class="string">&#x27;cat&#x27;</span>&gt;&lt;/Component&gt;</span><br><span class="line">    &lt;h1&gt;hello world!!!&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>2.子组件对父组件传值 简单来说就是利用回调来完成，比如下面例子，子组件来改变父组件的颜色</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理父子组件间传值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.props.colorChange(<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;父组件的值  &#123;<span class="built_in">this</span>.props.bgColor&#125;&lt;/h1&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.handleClick(e)&#125;&gt;改变父组件颜色&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.state=&#123;</span><br><span class="line">        bgColor: <span class="string">&#x27;#999&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">onBgColorChange</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        bgColor: color</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123;<span class="attr">background</span>:<span class="built_in">this</span>.state.bgColor&#125;&#125;&gt;</span><br><span class="line">          &lt;Child bgColor=&#123;<span class="built_in">this</span>.state.bgColor&#125; colorChange=&#123;<span class="function">(<span class="params">color</span>)=&gt;</span>&#123;<span class="built_in">this</span>.onBgColorChange(color)&#125;&#125;&gt;&lt;/Child&gt;</span><br><span class="line">          &#123;<span class="comment">/* 子组件像父组件传值，设置回调 */</span>&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Father&gt;&lt;/Father&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>3.同一父组件下平级组件间传值 ，简单一句话 子组件先传给父组件，父组件再传给那个子组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理平级组件间传值 ，先传给父组件，父组件再传给另一个组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.props.changeChild2Color(<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;Child1：  &#123;<span class="built_in">this</span>.props.bgColor&#125;&lt;/h1&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.handleClick(e)&#125;&gt;向Child2传值，改变其颜色&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123;<span class="attr">background</span>:<span class="built_in">this</span>.props.bgColor&#125;&#125;&gt;</span><br><span class="line">            &lt;h1&gt;Child2：  &#123;<span class="built_in">this</span>.props.bgColor&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.state=&#123;</span><br><span class="line">        child2BgColor: <span class="string">&#x27;#999&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">onChild2BgColorChange</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        child2BgColor: color</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123;<span class="comment">/* 平级组件间传值*/</span>&#125;</span><br><span class="line">          &lt;Child1 changeChild2Color=&#123;<span class="function">(<span class="params">color</span>)=&gt;</span>&#123;<span class="built_in">this</span>.onChild2BgColorChange(color)&#125;&#125;&gt;&lt;/Child1&gt;</span><br><span class="line">          &lt;Child2 bgColor=&#123;<span class="built_in">this</span>.state.child2BgColor&#125;&gt;&lt;/Child2&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Father&gt;&lt;/Father&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="前端基础" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>web通讯的四种方式：短轮询、长轮询(comet)、长连接(SSE)、WebSocket</title>
    <link href="http://example.com/2020/10/29/web%E9%80%9A%E8%AE%AF%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%9F%AD%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2(comet)%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5(SSE)%E3%80%81WebSocket/"/>
    <id>http://example.com/2020/10/29/web%E9%80%9A%E8%AE%AF%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%9F%AD%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2(comet)%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5(SSE)%E3%80%81WebSocket/</id>
    <published>2020-10-28T16:00:00.000Z</published>
    <updated>2020-10-31T16:56:04.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>http端轮询是服务器收到请求不管是否有数据都直接响应 http 请求;<br>其实就是普通的轮询。指在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客户端的浏览器。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>传统的web通信模式。后台处理数据，需要一定时间，前端想要知道后端的处理结果，就要不定时的向后端发出请求以获得最新情况。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>前后端程序编写比较容易。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>请求中有大半是无用，难于维护，浪费带宽和服务器资源；<br>响应的结果没有顺序（因为是异步请求，当发送的请求没有返回结果的时候，后面的请求又被发送。而此时如果后面的请求比前面的请 求要先返回结果，那么当前面的请求返回结果数据时已经是过时无效的数据了）。</p><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><pre><code>适于小型应用。</code></pre><h2 id="前端实现："><a href="#前端实现：" class="headerlink" title="前端实现："></a>前端实现：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;/user&#x27;</span>);</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h1 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。</p><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>在无消息的情况下不会频繁的请求，耗费资源小。</p><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>服务器hold连接会消耗资源<br>返回数据顺序无保证，难于管理维护。<br>浏览器端对统一服务器同时 http 连接有最大限制, 最好同一用户只存在一个长轮询;</p><h2 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h2><p>WebQQ、Hi网页版、Facebook IM。</p><h2 id="前端实现：-1"><a href="#前端实现：-1" class="headerlink" title="前端实现："></a>前端实现：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">       xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;/user&#x27;</span>);</span><br><span class="line">       xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             ajax();</span><br><span class="line">       &#125;;</span><br><span class="line">       xhr.send();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>长轮询和短轮询</p><ul><li>相同点：可以看出 http 长轮询和 http 短轮询的都会 hold 一段时间;</li><li>不同点：间隔发生在服务端还是浏览器端: http 长轮询在服务端会 hold 一段时间, http 短轮询在浏览器端 “hold”一段时间;</li></ul><h1 id="http-长连接"><a href="#http-长连接" class="headerlink" title="http 长连接"></a>http 长连接</h1><p>目前 http 协议普遍使用的是 1.1 版本, 之前有个 1.0 版本,两者之间的一个区别是 1.1 支持 http 长连接, 或者叫持久连接。<br>1.0 不支持 http 长连接, 每次一个 http请求响应后都关闭 tcp 连接, 下个 http 请求会重新建立 tcp 连接.</p><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>多个 http 请求共用一个 tcp 连接; 这样可以减少多次临近 http 请求导致 tcp建立关闭所产生的时间消耗.</p><p>http 1.1 中在请求头和相应头中用 connection字段标识是否是 http长连接, connection: keep-alive, 表明是 http 长连接; connection:closed, 表明服务器关闭 tcp 连接</p><p>与 connection 对应的一个字段是 keep-live, http 响应头中出现, 他的格式是 timeout=30,max=5, timeout 是两次 http 请求保持的时间(s), , max 是这个 tcp 连接最多为几个 http请求重用</p><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><p>消息即时到达，不发无用请求；管理起来也相对方便。</p><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><p>服务器维护一个长连接会增加开销。</p><h2 id="实例：Gmail聊天"><a href="#实例：Gmail聊天" class="headerlink" title="实例：Gmail聊天"></a>实例：Gmail聊天</h2><h1 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>Websocket是基于HTTP协议的，在和服务端建立了链接后，服务端有数据有了变化后会主动推送给前端。</p><h2 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h2><p>请求响应快，不浪费资源。（传统的http请求，其并发能力都是依赖同时发起多个TCP连接访问服务器实现的(因此并发数受限于浏览器允许的并发连接数)，而websocket则允许我们在一条ws连接上同时并发多个请求，即在A请求发出后A响应还未到达，就可以继续发出B请求。由于TCP的慢启动特性（新连接速度上来是需要时间的），以及连接本身的握手损耗，都使得websocket协议的这一特性有很大的效率提升；http协议的头部太大，且每个请求携带的几百上千字节的头部大部分是重复的，websocket则因为复用长连接而没有这一问题。）</p><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>主流浏览器支持的Web Socket版本不一致；<br>服务端没有标准的API。</p><h2 id="实例：实现即时通讯-如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询"><a href="#实例：实现即时通讯-如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询" class="headerlink" title="实例：实现即时通讯:如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询"></a>实例：实现即时通讯:如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询</h2><h2 id="解决：解决了http协议的两个问题。"><a href="#解决：解决了http协议的两个问题。" class="headerlink" title="解决：解决了http协议的两个问题。"></a>解决：解决了http协议的两个问题。</h2><ol><li>服务端的被动性。http协议是只有客户端询问之后才回复。解决了同步有延迟的问题</li><li>解决了服务器上消耗资源的问题</li></ol><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要先npm install ws</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器端</span></span><br><span class="line"><span class="keyword">var</span> Server = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>).Server;</span><br><span class="line"><span class="keyword">var</span> wss = <span class="keyword">new</span> Server(&#123;</span><br><span class="line">    port:<span class="number">2000</span></span><br><span class="line">&#125;);</span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ws</span>)</span>&#123;</span><br><span class="line">    ws.on(<span class="string">&#x27;message&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        ws.send(<span class="string">&#x27;你好,客户端,我是服务器!&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//node客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:2000/&#x27;</span>);</span><br><span class="line">socket.on(<span class="string">&#x27;open&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    socket.send(<span class="string">&#x27;你好，服务器,我是客户端&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">socket.on(<span class="string">&#x27;message&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//html客户端(注:浏览器客户端与node客户端只需要一种)</span></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:2000/&#x27;</span>);</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSocket四个事件操作"><a href="#WebSocket四个事件操作" class="headerlink" title="WebSocket四个事件操作"></a>WebSocket四个事件操作</h2><ul><li>onmessage收到服务器响应时执行</li><li>onerroe 出现异常时执行</li><li>onopen 建立起连接时执行</li><li>onclose 断开连接时执行</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="前端基础" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>扫码点餐时遇到的问题</title>
    <link href="http://example.com/2020/09/19/%E6%89%AB%E7%A0%81%E7%82%B9%E9%A4%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/09/19/%E6%89%AB%E7%A0%81%E7%82%B9%E9%A4%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-09-18T16:00:00.000Z</published>
    <updated>2020-10-31T16:21:24.815Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="在写个人项目——扫码点餐中碰到的一些问题"><a href="#在写个人项目——扫码点餐中碰到的一些问题" class="headerlink" title="在写个人项目——扫码点餐中碰到的一些问题"></a>在写个人项目——扫码点餐中碰到的一些问题</h1><h2 id="React报错-Objects-are-not-valid-as-a-React-Child"><a href="#React报错-Objects-are-not-valid-as-a-React-Child" class="headerlink" title="React报错: Objects are not valid as a React Child"></a>React报错: Objects are not valid as a React Child</h2><p>解决方法：标签之间的内容不能为对象，不能作为原生元素的子元素，但可以作为自定义组件的子元素</p><h2 id="React报错-props-is-not-defined-at-xxx-render"><a href="#React报错-props-is-not-defined-at-xxx-render" class="headerlink" title="React报错: props is not defined at xxx.render"></a>React报错: props is not defined at xxx.render</h2><p>解决方法：1. render中应写this.state，是否写成了props.state?</p><h2 id="Error-Request-failed-with-status-code-401"><a href="#Error-Request-failed-with-status-code-401" class="headerlink" title="Error: Request failed with status code 401"></a>Error: Request failed with status code 401</h2><p><img src="http://note.youdao.com/yws/public/resource/57483267a438c01a94484a62517b6eb4/xmlnote/DB20B89D253641DFBBE44436175CF3A9/642" alt="Image text"><br>一些前端基础功能部分抛出的错误，promise抛出的错误，不是响应体而是错误对象</p><h2 id="向后端请求餐桌信息，跨域问题"><a href="#向后端请求餐桌信息，跨域问题" class="headerlink" title="向后端请求餐桌信息，跨域问题"></a>向后端请求餐桌信息，跨域问题</h2><p><img src="http://note.youdao.com/yws/public/resource/57483267a438c01a94484a62517b6eb4/xmlnote/CAC2CD357C7F4F86AC9C8964CBDB9EEA/652" alt="Image text"><br>后端app.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(cors(&#123;</span><br><span class="line">  origin: <span class="literal">true</span>,<span class="comment">//修改这里</span></span><br><span class="line">  maxAge: <span class="number">86400</span>,</span><br><span class="line">  credentials: <span class="literal">true</span>,</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h2 id="proxy-error"><a href="#proxy-error" class="headerlink" title="proxy error"></a>proxy error</h2><p><img src="http://note.youdao.com/yws/public/resource/57483267a438c01a94484a62517b6eb4/xmlnote/9F4153617CB84496A435AD090C1DA56F/665" alt="Image text"><br>proxy代理设置 “proxy”: “<a href="http://localhost:5002&quot;">http://localhost:5002&quot;</a> 即可<br>同代表本机的10.1.1就不可以，最好各处写的一致</p><h2 id="React脚手架运行npm-start报错-webpack版本问题"><a href="#React脚手架运行npm-start报错-webpack版本问题" class="headerlink" title="React脚手架运行npm start报错 webpack版本问题"></a>React脚手架运行npm start报错 webpack版本问题</h2><p>There might be a problem with the project dependency tree.<br>It is likely not a bug in Create React App, but something you need to fix locally.<br>The react-scripts package provided by Create React App requires a dependency:<br>“webpack”: “4.42.0”<br>Don’t try to install it manually: your package manager does it automatically.<br>However, a different version of webpack was detected higher up in the tree:<br>C:\Users\lenovo\node_modules\webpack (version: 4.41.6)<br>Manually installing incompatible versions is known to cause hard-to-debug issues.<br>If you would prefer to ignore this check, add SKIP_PREFLIGHT_CHECK=true to an .env file in your project.<br>That will permanently disable this message but you might encounter other issues.<br>To fix the dependency tree, try following the steps below in the exact order:</p><ol><li>Delete package-lock.json (not package.json!) and/or yarn.lock in your project folder.</li><li>Delete node_modules in your project folder.</li><li>Remove “webpack” from dependencies and/or devDependencies in the package.json file in your project folder.</li><li>Run npm install or yarn, depending on the package manager you use.<br>In most cases, this should be enough to fix the problem.<br>If this has not helped, there are a few other things you can try:</li><li>If you used npm, install yarn (<a href="http://yarnpkg.com/">http://yarnpkg.com/</a>) and repeat the above steps with it instead.<br>This may help because npm has known issues with package hoisting which may get resolved in future versions.</li><li>Check if C:\Users\lenovo\node_modules\webpack is outside your project directory.<br>For example, you might have accidentally installed something in your home folder.</li><li>Try running npm ls webpack in your project folder.<br>This will tell you which other package (apart from the expected react-scripts) installed webpack.<br>If nothing else helps, add SKIP_PREFLIGHT_CHECK=true to an .env file in your project.<br>That would permanently disable this preflight check in case you want to proceed anyway.<br>P.S. We know this message is long but please read the steps above :-) We hope you find them helpful!</li></ol><p>解决办法：在项目文件夹下，新建一个.env文件，在其中写上如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SKIP_PREFLIGHT_CHECK&#x3D;true</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>用生成器函数和Promise改善异步流程</title>
    <link href="http://example.com/2020/08/11/%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0%E5%92%8CPromise%E6%94%B9%E5%96%84%E5%BC%82%E6%AD%A5%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2020/08/11/%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0%E5%92%8CPromise%E6%94%B9%E5%96%84%E5%BC%82%E6%AD%A5%E6%B5%81%E7%A8%8B/</id>
    <published>2020-08-11T10:51:00.000Z</published>
    <updated>2020-10-31T16:21:26.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在学习JavaScript异步相关的知识，在学到Generator（生成器函数）、Promise 和 async-awiat 等相关对异步优化的内容时遇到了一些一时没有理解的东西。本文仅作为学习过程中的笔记分享，第一次发文章，如果错误请不吝指出。</p><p>话不多说，进入正题，先写一下在 Generator 中要用到的函数，随便写几个就行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">val, duration</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(val);</span><br><span class="line">        &#125;, duration);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">duration</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;<span class="comment">//delay函数不resolve出任何东西，或者说resolve出undefined</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(url).then(<span class="built_in">JSON</span>.parse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是 <strong>Generator 函数主体</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">yield</span> getJSON(<span class="string">&#x27;data.json&#x27;</span>)<span class="comment">//(1)</span></span><br><span class="line">    <span class="keyword">yield</span> delay(<span class="number">1000</span>);<span class="comment">//(2)</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">yield</span> getValue(<span class="number">10</span>, <span class="number">3000</span>);<span class="comment">//(3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Generator 函数会在遇到 yield 时生成一个值并暂停执行，如果要继续执行，则要调用next()，yield 的运算结果是生成器 next() 里面的参数。</p><p>为了执行 Generator函数 f ，声明一个函数 g 作为函数 f 的调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = f();</span><br><span class="line"></span><br><span class="line">g.next().value.then(<span class="function"><span class="params">value</span> =&gt;</span>&#123;</span><br><span class="line">  g.next(value).value.then(<span class="function"><span class="params">value</span> =&gt;</span></span><br><span class="line">    g.next(value).value.then(<span class="function"><span class="params">value</span> =&gt;</span></span><br><span class="line">      g.next(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>分析一下对 g 调用 next() 的过程。</p><p>在声明完函数 g 之后。<strong>第一行</strong>的第一个 value 是 getJSON 解析好的的 promise（我们希望在 promise 在 resolve 以后恢复执行），然后通过 data 返回，但是我们也不确定什么时候能resolve，但是可以确定的是：resolve 之后恢复生成器的执行。</p><p><strong>第二行</strong>的第一个 value 是上一个 then 传入的 value（getJSON(‘data.json’) resolve 的结果），第二个 value 是 delay(1000) 的 promise 的 resolve。</p><p>接下来是<strong>第三行</strong>，很明显，next() 调用一次就恢复执行，然后暂停，再调一次就再恢复执行，这里是第三次调用，传入的 value（第二个 value）是第(2)行的返回结果，虽然 delay 并没啥返回（甚至左边没有变量接住）。这次调用将会返回第(3)行生成的 promise 对象，然后等getValue 函数 resolve 以后，再恢复执行。这时这里第三个 value 应该是10并返回给b。</p><p>最后一行，即<strong>第四行</strong> g.next(value); 这里的 value 为10。<br>&emsp;<br>&emsp;</p><h1 id="总结一下-f-函数的执行"><a href="#总结一下-f-函数的执行" class="headerlink" title="总结一下 f() 函数的执行"></a>总结一下 f() 函数的执行</h1><p>运行到<strong>第(1)行的 yield</strong> 时，在 yield 出 getJSON 的 promise 后，它执行停止了，直到 promise 的 resolve 后才恢复执行，并且恢复之后还将返回 promise 的 resolve 的值，也就是 data 将等于 data.json 解析出的内容。</p><p>然后函数运行到<strong>第(2)行</strong>，又 yield 出了 delay 的 promise，并再次等待 promise 的 resolve后才恢复执行（虽然这里的 delay 本身没求值结果所以也不 resolve 出啥），delay 在1秒后完成，所以第(2)行的 yield 也在1秒后恢复。</p><p>运行到<strong>第(3)行</strong>，又 yield 出一个promise，然后就停住了，在等待这个 promise 的 resolve 后才恢复，要恢复得调用 next()，而 next 的调用在 promise 的 resolve之后，即这时已经有resolve 的值了，把值传给 next() 即可，b 就等于这个 resolve 出的值。全程 next() 调用在那行的 promise 的 resolve之后，而且调用的时候把 promise 的 resovle 的值传给 next() 并成为yield 的返回值。</p><p>f() 这样跟同步的写法区别仅在于有没有 yield，虽然是异步的，但是写在了同一行里。(1)行的data 最终将等于 data.json 用 getJSON 请求到的真正的数据，而不是一个 promise 对象。虽然看起来像同步，但实际上代码在运行到这行的时候暂停了一定的时间，时间取决于 promise 的 resolve 的时间，在等待的这段时间，浏览器是完全空闲的。</p><p>在以上的举例分析中，我们只考虑了 promise 能正确 resolve 的情况，那么接下来再写一下出现错误的情况（拿 next() 调用 g 的第一行举例）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g.next().value.then(<span class="function"><span class="params">value</span> =&gt;</span>&#123;</span><br><span class="line">    g.next(value);<span class="comment">//成功就通过yield返回</span></span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span>&#123;</span><br><span class="line">    g.throw(reason);<span class="comment">//失败就通过yield抛出</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>如果成功的就调用这个箭头函数（第一个 value 是 promise）,then 只是挂上了两个并没有立刻得到结果的函数就结束，然后执行下一句（console.log(1);）了，注意即使在then调用时promise 已经得出结果，下一句 console.log(1); 仍然先于then里的函数执行。因为这个函数是异步调用的，里面的内容必定在 then 所在的调用栈全部清空以后执行，</p><p>另外说一下，既然有错误，就应该加上 try-catch 语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">yield</span> getJSON(<span class="string">&#x27;data.json&#x27;</span>)</span><br><span class="line">&#125;<span class="function"><span class="title">catch</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//多了yield的好处：能看出代码哪里需要等待</span></span><br></pre></td></tr></table></figure><h1 id="最后总结和补充一下-Generator-和-async-await-对于异步优化的一些知识点"><a href="#最后总结和补充一下-Generator-和-async-await-对于异步优化的一些知识点" class="headerlink" title="最后总结和补充一下 Generator 和 async-await 对于异步优化的一些知识点"></a>最后总结和补充一下 Generator 和 async-await 对于异步优化的一些知识点</h1><p>Generator可以让执行处于暂停状态，Generator 返回的是一个 Iterator 对象。<br>必要构成：1 个星号和 yield 运算符。<br>next 属性返回一个对象，里面 value 是当前 yield 后面的值，done 表示当前生成器有没有运行完。yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。yield可以生成一个值，然后恢复的话（也可以不恢复，就不返回值）又可以返回一个值，两个值可以不一样。<br>yield: yield 的运算结果是生成器 next() 里面的参数。<br>async + 生成器函数 function {await ：promise 函数}。 async 函数就是将 Generator 函数的星号替换成 async，将 yield 替换成 await。<br>async 函数对 Generator 函数的改进，配合 promise 使用(后面接返回promise的函数？)，包装原理如上。并且 function() 返回一个 promise。<strong>async-await 本质是生成器函数和yield。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="前端基础" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>this和强制改变this指向</title>
    <link href="http://example.com/2020/04/13/this%E5%92%8C%E5%BC%BA%E5%88%B6%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91/"/>
    <id>http://example.com/2020/04/13/this%E5%92%8C%E5%BC%BA%E5%88%B6%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91/</id>
    <published>2020-04-12T16:00:00.000Z</published>
    <updated>2020-10-31T16:21:27.681Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>);<span class="comment">//[Objes y);//10,20</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>要改变它的this指向，有几种方法：<br>方法1：call<br>        格式： 函数名.call();<br>        参数：第一个参数：传入该函数this指向的对象，传入什么就强制指向什么<br>              从第二个参数开始，将原函数的参数往后顺延一位<br>        注：call主要目的是为了绑定参数，apply则是出现…运算符之前的老旧写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show.call(<span class="string">&quot;call&quot;</span>, <span class="number">20</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure><p>方法2：apply<br>        格式：函数名.apply();<br>        参数：第一个参数；传入该函数this指向的对象，传入什么就强制指向什么<br>              第二个参数：数组，放入原有的所有参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show.apply(<span class="string">&quot;call&quot;</span>, [<span class="number">20</span>, <span class="number">40</span>]);</span><br></pre></td></tr></table></figure><p>方法3：bind预设this指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>);</span><br><span class="line">            alert(x + <span class="string">&quot;,&quot;</span> + y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> res = show.bind(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="comment">//res(40, 50);</span></span><br><span class="line">        show.bind(<span class="string">&quot;bind&quot;</span>)(<span class="number">40</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>apply使用方法的小技巧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.min();</span><br><span class="line">Math.max();</span><br><span class="line">alert(Math.min(10,20,30,40,50));</span><br><span class="line">alert(Math.max(10,20,30,40,50));</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [10,20,30,40,50];</span><br><span class="line">alert(Math.min.apply(null, arr));</span><br><span class="line">alert(Math.max.apply(null, arr));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="前端基础" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>认识闭包</title>
    <link href="http://example.com/2020/04/04/%E8%AE%A4%E8%AF%86%E9%97%AD%E5%8C%85/"/>
    <id>http://example.com/2020/04/04/%E8%AE%A4%E8%AF%86%E9%97%AD%E5%8C%85/</id>
    <published>2020-04-03T16:00:00.000Z</published>
    <updated>2020-10-31T16:21:23.928Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>满足以下特点的叫做闭包<br>    1、函数嵌套函数<br>    2、内部函数使用外部函数的形参和变量<br>    3、被引用的形参和变量不会被垃圾回收机制所回收</p><p>好处：<br>    1、希望一个变量常驻在内存当中<br>    2、避免全局变量污染 避免声明全局变量，比如在函数外声明<br>    3、可以声明私有成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">num1</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">var</span> num2 = <span class="number">10</span>;</span><br><span class="line">           <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="keyword">return</span>(num1 + <span class="string">&quot; &quot;</span> + num2);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> b;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">var</span> res = a(<span class="number">20</span>);</span><br><span class="line">       <span class="built_in">console</span>.log(res());</span><br></pre></td></tr></table></figure><p>就是一个闭包</p><p>可以实现：1、避免全局污染，2、对a进行累加<br>【注】让a变量常驻内存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cc = aa();</span><br><span class="line">    cc();</span><br><span class="line">    cc();</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>写成立即执行函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">cc();</span><br><span class="line">cc();</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>闭包的一个应用：私有变量<br>例子：A，B两同学共同开发代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleA = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">10</span>;<span class="comment">//私有变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;<span class="comment">//私有方法</span></span><br><span class="line">        count += <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        count *= <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        funcA: aaa,</span><br><span class="line">        funcB: bbb</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> moduleA = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        count += <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        count *= <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        funcA: aaa,</span><br><span class="line">        funcB: bbb</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">moduleA.funcA();</span><br><span class="line">moduleA.funcB();</span><br><span class="line"></span><br><span class="line">moduleB.funcA();</span><br><span class="line">moduleB.funcB();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="前端基础" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>题集</title>
    <link href="http://example.com/2019/12/26/%E9%A2%98%E9%9B%86/"/>
    <id>http://example.com/2019/12/26/%E9%A2%98%E9%9B%86/</id>
    <published>2019-12-25T16:00:01.000Z</published>
    <updated>2020-11-15T17:04:44.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="根据情况收集一些题目-amp-合适的回答"><a href="#根据情况收集一些题目-amp-合适的回答" class="headerlink" title="根据情况收集一些题目&amp;合适的回答"></a>根据情况收集一些题目&amp;合适的回答</h1><h2 id="HTML-CSS问题"><a href="#HTML-CSS问题" class="headerlink" title="HTML + CSS问题"></a>HTML + CSS问题</h2><h3 id="1-如何清除浮动？"><a href="#1-如何清除浮动？" class="headerlink" title="1. 如何清除浮动？"></a>1. 如何清除浮动？</h3><p>clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写CSS样式 {clear:both; height:0; overflow:hidden;}<br>给浮动元素父级设置高度<br>父级同时浮动（需要给父级同级元素添加浮动）<br>父级设置成 inline-block<br>给父级添加 overflow: hidden<br>万能清除法 after伪类 清浮动（现在主流方法，推荐使用）</p><p>BFC 触发条件<br>根元素<br>position: absolute/fixed<br>display: inline-block / table<br>float 元素<br>ovevflow 不为 visible</p><h3 id="2-行内元素和块元素有哪些，本质区别"><a href="#2-行内元素和块元素有哪些，本质区别" class="headerlink" title="2.行内元素和块元素有哪些，本质区别"></a>2.行内元素和块元素有哪些，本质区别</h3><p>行内元素：span、img、button、input、b、q、i、a、em、label<br>块元素：div、p、h1-h6、ul、ol、dl、li、header、footer、aside、section、article、form、table</p><p>区别：行内元素设置 width，height 属性无效，起边距作用的只 有margin-left、margin-right、padding-left、padding-right，其它属性不会起边距效果（可以设置 line-height），设置 margin 和 padding 的上下不会对其他元素产生影响。块级元素可以设置 width，height 属性</p><h3 id="3-水平居中"><a href="#3-水平居中" class="headerlink" title="3.水平居中"></a>3.水平居中</h3><p>行内元素：父元素 text-align: center<br>块元素：宽度已知用 margin: auto，宽度未知：用 display: inline 变成行内元素后在父元素上设置 text-align: float</p><h3 id="4-flex"><a href="#4-flex" class="headerlink" title="4. flex"></a>4. flex</h3><p>flex-direction属性 该属性定义了子元素的排列方向</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex-wrap属性 该属性称“轴线”</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex-flow属性：|| ; flex-direction 和 flex-wrap 的简写，默认值为 row nowrap<br>justify-content 属性 该属性定义了子元素在主轴上的对齐方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>align-items 属性 该属性定义了项目在交叉轴上如何对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>align-content 属性，该属性定义了多跟轴线的对齐方式，如果项目只有一根轴线，该属性不起作用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-CSS让元素不可见的方法"><a href="#5-CSS让元素不可见的方法" class="headerlink" title="5. CSS让元素不可见的方法"></a>5. CSS让元素不可见的方法</h3><p>display | z-index: -9999 | opacity:0 | position: absolute; left: -9999; top: -9999</p><h3 id="6-如何设计移动端页面和响应式界面"><a href="#6-如何设计移动端页面和响应式界面" class="headerlink" title="6. 如何设计移动端页面和响应式界面"></a>6. 如何设计移动端页面和响应式界面</h3><h2 id="JavaScript问题"><a href="#JavaScript问题" class="headerlink" title="JavaScript问题"></a>JavaScript问题</h2><h3 id="1-原型和原型链"><a href="#1-原型和原型链" class="headerlink" title="1. 原型和原型链"></a>1. 原型和原型链</h3><p>每个”构造函数”中都有一个默认的属性, 叫做 prototype, prototype 属性保存着一个对象, 这个对象我们称之为”原型对象”, prototype 指向它的原型对象</p><p>每个”原型对象”中都有一个默认的属性, 叫做 constructor, constructor 指向当前原型对象对应的那个”构造函数”<br>通过构造函数创建出来的对象我们称之为”实例对象”, 每个”实例对象”中都有一个默认的属性, 叫做<strong>proto</strong>, <strong>proto</strong> 指向创建它的那个构造函数的”原型对象”</p><h3 id="2-JS的传参"><a href="#2-JS的传参" class="headerlink" title="2. JS的传参"></a>2. JS的传参</h3><p>按值传递(call by value)是最常用的求值策略：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。（深拷贝？）通过自定义函数实现深拷贝（递归遍历对象）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过遍历拿到 source 中的所有属性，取出当前遍历到的属性对应的值，判断当前的取值是否是引用数据类型（对象、数组、函数，一般是对象嵌套），通过 sourceValue.constructor 拿到这个对象的构造函数的类型，然后新建这个对象或数组，再次调用深拷贝，将遍历到的属性的值拷贝给新建的对象或数组，如果不是引用数据类型，之前的属性拷贝即可</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deCopy</span>(<span class="params">target, source</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> key <span class="keyword">in</span> source</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> sourceValue = souce[key];</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">sourceValue <span class="keyword">instanceof</span> <span class="built_in">Object</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> subTarget = <span class="keyword">new</span> sourceValue.constructor;</span><br><span class="line">            deCopy(subTarget, sourceValue);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            target[key] = sourceValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按引用传递(call by reference)时，函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。（浅拷贝？）</p><p>按引用传递会使函数调用的追踪更加困难，有时也会引起一些微妙的 BUG。按值传递由于每次都需要克隆副本，对一些复杂类型，性能较低。两种传值方式都有各自的问题。可能很多人都是做后端的，所有会想到“引用传递”，然而实际上却不是，导致了问题的产生。</p><h3 id="3-跨域"><a href="#3-跨域" class="headerlink" title="3. 跨域"></a>3. 跨域</h3><p>协议、域名、端口三者有一个不同就会引起跨域的错误问题<br>解决：JSONP：通过动态创建script标签，其 src 指向非同源的 url，并传递一个 callback 参数作为函数名的函数的调用和一系列参数，页面接收到响应后执行回调并对数据进行处理。CORS：服务器端操作，设置 http header</p><h3 id="4-数组去重"><a href="#4-数组去重" class="headerlink" title="4. 数组去重"></a>4. 数组去重</h3><p>方法一：倒进集合再倒出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>])]</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>方法二：indexOf()<br>方法三：双重循环</p><h3 id="5-ES6-的symol是什么，适用场景有什么"><a href="#5-ES6-的symol是什么，适用场景有什么" class="headerlink" title="5. ES6 的symol是什么，适用场景有什么"></a>5. ES6 的symol是什么，适用场景有什么</h3><p>一种特殊的数据类型，定义不可更改，适合用来作为属性名标识独一无二的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个symbol类型的值</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s);<span class="comment">//&quot;symbol&quot;</span></span><br></pre></td></tr></table></figure><p>用作对象属性、模拟类的私有方法</p><h3 id="6-async-和-await"><a href="#6-async-和-await" class="headerlink" title="6. async 和 await"></a>6. async 和 await</h3><p>写法跟 generator 很像，就是将星号替换成 async，将 yield 替换成 await。async 函数返回一个 promise 对象，如果 async函数没有返回值，它会返回 Promise.resolve(undefined)。如果 await 等到的不是一个 promise 对象，那跟着的表达式的运算结果就是它等到的东西。<br>使用场景：需要 promise 链式调用的时候，每个步骤都是异步的，且依赖上一步的执行结果</p><h3 id="7-防抖和节流"><a href="#7-防抖和节流" class="headerlink" title="7. 防抖和节流"></a>7. 防抖和节流</h3><p>防抖是事件触发 n 秒后执行会掉，如果在这 n 秒内又被触发，则重新计时。使用场景：提交按钮时防止多次提交，只执行最后一次提交。<br>节流是 n 秒内只能触发一次函数，如果 n 秒内多次触发，只有一次生效。使用场景：拖拽在固定时间内只执行一次，防止超高频率触发位置变动；缩放时监控浏览器 resize</p><h4 id="8-类数组转换为数组的方法"><a href="#8-类数组转换为数组的方法" class="headerlink" title="8. 类数组转换为数组的方法"></a>8. 类数组转换为数组的方法</h4><p>使用 Array.from()<br>使用 Array.prototype.slice.call()<br>使用 Array.prototype.forEach() 进行遍历并生成新的数组<br>转换后数组的长度由 length 属性决定。索引不连续时转换结果是连续的，会自动补位</p><h2 id="计算机网络问题"><a href="#计算机网络问题" class="headerlink" title="计算机网络问题"></a>计算机网络问题</h2><h3 id="1-http-和-https"><a href="#1-http-和-https" class="headerlink" title="1. http 和 https"></a>1. http 和 https</h3><p>http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少<br>https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密</p><h3 id="2-http1-0-和-http2-0"><a href="#2-http1-0-和-http2-0" class="headerlink" title="2. http1.0 和 http2.0"></a>2. http1.0 和 http2.0</h3><p>HTTP1.x 的解析是基于文本。HTTP2.0 的协议解析采用二进制格式<br>HTTP2.0 比HTTP1.0 有多路复用，一个连接可以并发处理多个请求<br>header压缩，HTTP1.x 的header带有大量信息，而且每次都要重复发送，HTTP2.0 使用encoder来减少需要传输的header大小<br>服务器推送：我们对支持 HTTP2.0 的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源</p><h3 id="3-Cookie、SessionStronge、LocalStronge的区别"><a href="#3-Cookie、SessionStronge、LocalStronge的区别" class="headerlink" title="3. Cookie、SessionStronge、LocalStronge的区别"></a>3. Cookie、SessionStronge、LocalStronge的区别</h3><h4 id="在同一浏览器下有效期不同"><a href="#在同一浏览器下有效期不同" class="headerlink" title="在同一浏览器下有效期不同"></a>在同一浏览器下有效期不同</h4><p>Cookie:         默认是关闭浏览器后失效, 但是也可以设置过期时间<br>SessionStorage: 仅在当前会话(窗口)下有效，关闭窗口或浏览器后被清除, 不能设置过期时间<br>LocalStorage:   除非被清除，否则永久保存</p><h4 id="容量不同"><a href="#容量不同" class="headerlink" title="容量不同"></a>容量不同</h4><p>Cookie 容量限制: 大小(4KB左右)和个数(20~50)<br>SessionStorage 和 LocalStorage 容量限制: 大小(5M左右)</p><h4 id="网络请求不同"><a href="#网络请求不同" class="headerlink" title="网络请求不同"></a>网络请求不同</h4><p>Cookie 网络请求:每次都会携带在 HTTP 请求头中，如果使用 cookie 保存过多数据会带来性能问题<br>SessionStorage 和 LocalStorage 网络请求: 仅在浏览器中保存，不参与和服务器的通信</p><h4 id="应用场景不同"><a href="#应用场景不同" class="headerlink" title="应用场景不同"></a>应用场景不同</h4><p>Cookie:         判断用户是否登录<br>sessionStorage: 表单数据<br>LocalStorage:   购物车</p><h4 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h4><p>Express 中使用 res.cookie() 一个验证身份的字符串，网站在用户验证成功之后都会设置一个 cookie，只要 cookie 没有过期，用户就可以自由浏览这个网站的任意页面不需要再次登录<br>localStorage.setItem(item,value)<br>localStorage.getItem(item)<br>localStorage.removeItem(item)<br>sessionStorage 和 localStorage 用法一样，但是它只保存数据到浏览器关闭，不会触发 onstorage 事件</p><h4 id="4-强缓存和协商缓存"><a href="#4-强缓存和协商缓存" class="headerlink" title="4. 强缓存和协商缓存"></a>4. 强缓存和协商缓存</h4><p>强缓存：服务器通知浏览器一个缓存时间，在缓存时间内的请求会直接实用缓存，不在执行比较缓存策略<br>协商缓存：让客户端和服务器之间实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息种的 Etag 和 Last-Modified 通过请求发送给服务器，由服务器校验，返回304时直接使用缓存</p><h3 id="5-进程和线程"><a href="#5-进程和线程" class="headerlink" title="5. 进程和线程"></a>5. 进程和线程</h3><p>进程是资源分配的最小单位，线程是 CPU 调度的最小单位。一个进程里面可以有多个线程，线程是共享了进程的上下文环境，的更为细小的 CPU 时间段。CPU 运行一个软件相当于打开一个了进程，执行该软件里面的 1 个功能相当于打开一个线程</p><h2 id="数据结构与算法问题"><a href="#数据结构与算法问题" class="headerlink" title="数据结构与算法问题"></a>数据结构与算法问题</h2><h3 id="栈-stack-和堆-heap-的区别"><a href="#栈-stack-和堆-heap-的区别" class="headerlink" title="栈(stack)和堆(heap)的区别"></a>栈(stack)和堆(heap)的区别</h3><ol><li>空间分配：栈由操作系统自动分配释放；堆需要由程序员释放或程序结束时由OS回收</li><li>结构区别：堆类似于一棵树，如堆排序；栈是一种先进后出的数据结构，类似于往箱子里放书取书，最先放进去的书在最底，拿出来时最后拿</li><li>缓存方式：堆使用二级缓存，生命周期由虚拟机的垃圾回收算法决定；栈使用的是一级缓存，调用时处于存储空间中，调用完毕立刻释放</li></ol><h3 id="递归求斐波那契数列"><a href="#递归求斐波那契数列" class="headerlink" title="递归求斐波那契数列"></a>递归求斐波那契数列</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归方式求1到100的和"><a href="#递归方式求1到100的和" class="headerlink" title="递归方式求1到100的和"></a>递归方式求1到100的和</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n, m</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = n + m;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">m + <span class="number">1</span> &gt; <span class="number">100</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(n, m + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = add(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="数组有哪些方法"><a href="#数组有哪些方法" class="headerlink" title="数组有哪些方法"></a>数组有哪些方法</h3><h3 id="遍历栈和树的时间复杂度"><a href="#遍历栈和树的时间复杂度" class="headerlink" title="遍历栈和树的时间复杂度"></a>遍历栈和树的时间复杂度</h3><p>树的四种遍历方式时间复杂度和空间复杂度都为O(N)<br>栈遍历的时间复杂度是O(N)</p><h2 id="性能优化问题"><a href="#性能优化问题" class="headerlink" title="性能优化问题"></a>性能优化问题</h2><h3 id="1-让加载更快"><a href="#1-让加载更快" class="headerlink" title="1. 让加载更快"></a>1. 让加载更快</h3><p>减少资源体积：压缩代码<br>减少访问次数：合并代码、SSR服务器端渲染，缓存<br>使用更快的网络：CDN</p><h3 id="2-让渲染更快"><a href="#2-让渲染更快" class="headerlink" title="2. 让渲染更快"></a>2. 让渲染更快</h3><p>CSS放在head，JS放在body最下面<br>尽早开始执行JS，用DOMContentLoaded触发<br>懒加载（图片懒加载、下滑加载更多、分页器）<br>对DOM查询进行缓存<br>将频繁的DOM操作，合并到一起插入到DOM结构<br>节流、防抖等常用性能优化方法</p><h3 id="3-Webpack"><a href="#3-Webpack" class="headerlink" title="3. Webpack"></a>3. Webpack</h3><p>loader 将除 js 以外的其它资源也当成 require 的资源，如图片，CSS, json, svg，字体，通过把这些非 js 资源转化为等价的 js 文件来实现<br>plugin 在 webpack 则是对整体的打包结果进行处理的一种插件机制<br>babel-loader 将 ES6 转化为 ES5<br>file-loader 将文件输出到一个文件夹中，在代码中通过相对URL去引用<br>url-loader 与 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中</p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="1-Vuex作用"><a href="#1-Vuex作用" class="headerlink" title="1. Vuex作用"></a>1. Vuex作用</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。可以将共享的数据保存到 Vuex 中，方便整个程序中的任何组件都可以获取和修改 Vuex 中保存的公共数据</p><p>每个 Vuex 应用的核心是 store，store 基本上是一个容器，包含着应用中的大部分状态。Vuex 的状态存储是响应式的，当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么响应的组件也会得到更新</p><p>改变 store 中状态的唯一途径是提交 mutation。这样可以方便的跟踪每个状态的变化</p><ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 Store 中获取数据。mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation： 唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 Mutation，而不是直接更改状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</li></ul><h3 id="2-Vue的双向绑定原理"><a href="#2-Vue的双向绑定原理" class="headerlink" title="2. Vue的双向绑定原理"></a>2. Vue的双向绑定原理</h3><p>Vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><p>实现数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者<br>实现一个指令解析器Compile<br>实现一个Watcher，作为Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图<br>Mvvm入口函数，整合以上三者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;userName&quot;</span> /&gt;</span><br><span class="line">&lt;input v-bind:value=<span class="string">&quot;userName&quot;</span> v-on:input=<span class="string">&quot;userName = $event.target.value&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>第一行的代码其实只是第二行的语法糖。input 元素本身有个 oninput 属性，这是 HTML5 新增的，类似 onchange，每当输入框的内容发生变化，就会触发 oninput</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="1-Redux-介绍和如何使用"><a href="#1-Redux-介绍和如何使用" class="headerlink" title="1. Redux 介绍和如何使用"></a>1. Redux 介绍和如何使用</h3><p>redux是为了解决react中组件与组件之间数据传递的问题。<br>组建于组件之间的传递有三种情况：<br>1、父组件传递数据给子组件：由于redux是一个单向数据流的框架，所以它的数据就只能由父组件传递给子组件（props）；<br>2、子组件传递给父组件：而子组件想父组件的传值的话则需要使用回调函数，<br>3、子组件与子组件：那么子组件与子组件之间的传递则相当麻烦，需要先将子组件的值传递给父组件，然后再由父组件在分发给指定的子组件，而redux则是解决这种问题的。</p><p>用法<br>引入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/redux@4.0.4/dist/redux.js&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创造一个 store</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = Redux.createStore(<span class="function">(<span class="params">state, action</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;,state)</span><br></pre></td></tr></table></figure><p>第一个参数是一个 reducer 函数，函数有 2 个参数，state 表示储存的数据，action 是一个对象，子组件里面通过 dispatch 函数来传递这个对象，这个 reducer 函数通过 action 的信息来触发对 state 的相关操作，返回一个新的 state<br>创建的 store 上面有两个常用的方法，dispatch 和 subscribe 方法<br>dispatch, 传递给下层组件，下层组件利用这个方法操作 state 触发更新<br>subscribe, 用来监听 state 变更<br>var unSubscribe = store.subscribe(fn)<br>数据变更时 fn 会运行，这个 fn 不接参数，并返回一个函数 unSubscribe<br>调用 unSubscribe 就会把这次的监听函数 subscribe 解绑</p><h3 id="2-React-如何实现数据绑定"><a href="#2-React-如何实现数据绑定" class="headerlink" title="2. React 如何实现数据绑定"></a>2. React 如何实现数据绑定</h3><p>在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。可以通过 shouldComponentUpdate 这个生命周期进行控制 pureRender<br>通过 JSX 中标签加属性实现视图和数据的绑定，类组件中 render 里的大括号动态传递 state，this.state 记录数据状态，函数组件中则使用 hooks 管理状态（个人理解，不知道对不对）<br>Vue 实现数据绑定考的是数据劫持（Object.defineProperty()） + 发布-订阅模式。在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件需要被被重新渲染。可以理解为每一个组件都已经自动获得了 shouldComponentUpdate，并且没有上面的子树问题限制</p><h3 id="3-React如何在重新加载页面时保留数据？"><a href="#3-React如何在重新加载页面时保留数据？" class="headerlink" title="3. React如何在重新加载页面时保留数据？"></a>3. React如何在重新加载页面时保留数据？</h3><p>使用浏览器localstorage来保存应用程序的状态。我们将整个存储数据保存在localstorage中，每当有页面刷新或重新加载时，我们从localstorage加载状态。</p><h3 id="4-state-和-props-的区别"><a href="#4-state-和-props-的区别" class="headerlink" title="4. state 和 props 的区别"></a>4. state 和 props 的区别</h3><p>state 是组件自己管理数据，控制自己的状态，可变，必须通过 setState 更改。<br>props 是外部传入的数据参数，不可变，父组件通过传递 props 给子组件来更新视图，子组件不能将 prop 送回父组件。这有助于维护单向数据流，通常用于呈现动态生成的数据。</p><h3 id="5-简述-diff-算法"><a href="#5-简述-diff-算法" class="headerlink" title="5. 简述 diff 算法"></a>5. 简述 diff 算法</h3><p>如果两棵树的根元素类型不同，React会销毁旧树，创建新树。<br>对于类型相同的 React DOM 元素，只更新不同的属性<br>当处理完这个DOM节点，React就会递归处理子节点。<br>比较内容，如果有不同直接替换。</p><h3 id="6-函数组件和类组件"><a href="#6-函数组件和类组件" class="headerlink" title="6. 函数组件和类组件"></a>6. 函数组件和类组件</h3><p>函数组件是一个纯函数，接收参数并返回 React元素，并且没有任何副作用。没有生命周期函数和 state。<br>通过 class xx extends React.Component这类组件可以通过setState()来改变组件的状态，并且可以使用生命周期函数</p><p>定义组件时，复杂场景用类组件，简单场景用函数组件。<br>简单：一个组件仅仅是为了展示数据。<br>复杂：一个组件中有一定业务逻辑，需要操作数据，并且此时需要使用 state。</p><h3 id="7-受控组件和非受控组件"><a href="#7-受控组件和非受控组件" class="headerlink" title="7. 受控组件和非受控组件"></a>7. 受控组件和非受控组件</h3><p>在HTML当中，像input,textarea和select这类表单元素会维持自身状态，并根据用户输入进行更新。 在React中，可变的状态通常保存在组件的state中，并且只能用 setState() 方法进行更新. React根据初始状态渲染表单组件，接受用户后续输入，改变表单组件内部的状态。因此，将那些值由React控制的表单元素称为受控组件。</p><p>受控组件的特点：</p><ol><li>表单元素</li><li>由React通过JSX渲染出来</li><li>由React控制值的改变，想要改变元素的值，只能通过React提供的方法来修改</li></ol><p>非受控组件的状态是不受 React 控制的，而是组件本身具有的</p><p>非受控-&gt;受控组件的转化</p><p>首先把状态绑定到非受控组件的value、checked上。<br>然后监听该组件的onChange事件 用e.target 获取 input 上面的数据 然后通过 setState 设置数据给 state 内的数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="前端基础" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    <category term="习题" scheme="http://example.com/tags/%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2019/12/25/hello-world/"/>
    <id>http://example.com/2019/12/25/hello-world/</id>
    <published>2019-12-24T16:00:00.000Z</published>
    <updated>2020-11-03T18:30:19.887Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
</feed>
