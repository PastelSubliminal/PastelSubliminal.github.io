<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6中的import as</title>
    <url>/2020/11/27/ES6%E4%B8%AD%E7%9A%84import%20as/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>import * as xxx from ‘xxx’  会将 “xxx” 中所有 export 导出的内容组合成一个对象返回(或import * as obj from ‘xx’  这种写法是把所有的输出包裹到obj对象里);</p>
<p>eg：</p>
<p>xxx里中：</p>
<p>export function test(){</p>
<pre><code>return &#39;返回是test 内容&#39;;</code></pre>
<p> }</p>
<p>export function login(){</p>
<pre><code>return &#39;返回login 内容&#39;;</code></pre>
<p> }</p>
<p>调用test 函数，即obj.test();</p>
<p>调用login 函数，即obj.login();</p>
<p>扩展：那不带*as(即import xxx from ‘xxx’)</p>
<p><img src="https://img1.sycdn.imooc.com/5c9458a3000186e409180058.jpg" alt="image text"></p>
<p><img src="https://img1.sycdn.imooc.com/5c946ada000142c421721538.jpg" alt="image text"></p>
<p>总结：</p>
<p>import * as xxx from ‘xxx’: 会将若干export导出的内容组合成一个对象返回；</p>
<p>import xxx from ‘xxx’：（export default Din）只会导出这个默认的对象作为一个对象。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6的Map在实际中的应用</title>
    <url>/2021/06/26/ES6%E7%9A%84Map%E5%9C%A8%E5%AE%9E%E9%99%85%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在实际项目中，有时会遇到后端传的字段值需要通过字典转换，比如这样一个字典</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    res:</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            code: <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">            codeName: <span class="string">&#x27;苹果&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            code: <span class="string">&#x27;banana&#x27;</span>,</span><br><span class="line">            codeName: <span class="string">&#x27;香蕉&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            code: <span class="string">&#x27;watermalon&#x27;</span>,</span><br><span class="line">            codeName: <span class="string">&#x27;西瓜&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当后端存储和返回的是 code 的时候，为了在页面上展示对应的中文名称，可以通过 Map 数据结构来进行高效的键值转换。具体要如何使用 Map 呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过接口获取的字典</span></span><br><span class="line"><span class="keyword">const</span> fruit = [</span><br><span class="line">        &#123;</span><br><span class="line">            code: <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">            codeName: <span class="string">&#x27;苹果&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            code: <span class="string">&#x27;banana&#x27;</span>,</span><br><span class="line">            codeName: <span class="string">&#x27;香蕉&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            code: <span class="string">&#x27;watermalon&#x27;</span>,</span><br><span class="line">            codeName: <span class="string">&#x27;西瓜&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 get(key) 就可以获 code 对应的值</span></span><br><span class="line"><span class="keyword">get</span> <span class="title">fruitMap</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="built_in">this</span>.fruit) &#123;</span><br><span class="line">        map.set(item.code, item.codeName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fruitMap.get(<span class="string">&#x27;watermalon&#x27;</span>)); <span class="comment">// &#x27;西瓜&#x27;</span></span><br></pre></td></tr></table></figure>
<p>获得了需要的 Map 对象后，除了使用 get 获取值对应的名称，也可以进行其他操作<br>put(key, value)：向散列表添加一个新的项（也能更新散列表）。<br>remove(key)：根据键值从散列表中移除值。<br>get(key)：返回根据键值检索到的特定的值。<br>entries()：返回散列表中的所有键值对。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中的Set和Map数据结构</title>
    <url>/2021/01/28/ES6%E7%9A%84Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>集合（Set）是由一组无序且唯一的项组成的，该数据结构使用了和有限集合相同的数学概念，但应用在计算机科学的数据结构中。</p>
<p>可以把集合想象成一个既没有重复元素，也没有顺序概念的数组</p>
<p>一些集合可用的方法：<br>add(element)：向集合添加一个新元素。<br>delete(element)：从集合移除一个元素。<br>has(element)：如果元素在集合中，返回 true ，否则返回 false。<br>clear()：移除集合中的所有元素。<br>size()：返回集合所包含元素的数量。它与数组的 length 属性类似。<br>keys()：返回一个包含集合中所有键名的数组。<br>values()：返回一个包含集合中所有值（元素）的数组。</p>
<p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例</span></span><br><span class="line">    <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">//2,3,5,4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</span></span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure>

<p>可以利用set没有重复的值这一特性, 实现数组去重<br>不考虑兼容性，这种去重的方法代码最少。但这种方法无法去掉“{}”空对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"> <span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;]</span></span><br></pre></td></tr></table></figure>

<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<p>为了解决这个问题，ES6 提供了 散列表（Map） 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;, <span class="number">1</span>], [<span class="string">&quot;aa&quot;</span>, <span class="number">2</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br></pre></td></tr></table></figure>


<p>一些散列表可用的基本方法，散列表也可以使用 Set 的方法：<br>put(key, value)：向散列表添加一个新的项（也能更新散列表）。<br>remove(key)：根据键值从散列表中移除值。<br>get(key)：返回根据键值检索到的特定的值。<br>entries()：返回散列表中的所有键值对。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的作用域</title>
    <url>/2021/02/08/JS%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>在介绍 JS 的作用域之前，先介绍一下编译原理。</p>
<p>JavaScript引擎进行编译的步骤和传统编译语言比较相似，但在某些环节比预想的复杂。</p>
<p>在传统的编译语言中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。</p>
<ul>
<li>分词/词法分析：将有字符组成的字符串分解成（对编程语言来说）有意义的代码块。</li>
<li>解析/语法分析：将词法单元流（数组）转换成一个有元素逐级嵌套所形成的代表了程序与法结构的树。这个数被称为“抽象语法树”（Abstract Syntax Tree, AST）。</li>
<li>代码生成：将 AST 转换为可执行代码的过程。</li>
</ul>
<h1 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h1><p>如 var a = 2，变量的复制操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能找到就对它进行赋值。</p>
<h2 id="LHS-和-RHS"><a href="#LHS-和-RHS" class="headerlink" title="LHS 和 RHS"></a>LHS 和 RHS</h2><p>引擎会为变量 a 进行 LHS 查询，另外一个查询的类型叫做 RHS。含义分别为 Left Hand Side 和 Right Hand Side。</p>
<p>即变量出现在复制操作左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。RHS 查询与简单的查找某个变量的值无异，LHS 则试图找到变量的容器本身。从而可以对其赋值。准确的说，所有“非左侧”都是 RHS。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>
<p>其中对 a 的引用是一个 RHS 引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>这里对 a 的引用是一个 LHS 引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>最后一行 foo(2) 函数的调用需要对 foo 进行 RHS 引用<br>代码中隐式的 a = 2 的操作需要进行一次 LHS 查询<br>将得到的值传给 console.log()，需要对 a 进行一次 RHS 引用</p>
<h1 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h1><p>作用域是根据名称查找变凉的一套规则。当在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，知道找到该变量或抵达全局作用域为止。</p>
<p>LHS 和 RHS 引用都会在当前作用域进行查找，如果没有找到，就往上一层作用域，直到找到或者抵达全局作用域后停止查找。</p>
<p>如果 RHS 查询在所有嵌套的作用域中都找不到所需的变量，引擎就会抛出 ReferenceError 异常；如果 LHS 查询在全局作用域中也无法找到目标变量，则会隐式地在全局作用域创建这个变量（非严格模式下）并作为这次 LHS 查询的目标，或者抛出 ReferenceError。</p>
<p>如果试图对 RHS 查询到的变量的值进行不合理的操作，如调用非函数类型的值或引用 null 或 undefined 中的属性，则会抛出 TypeError。</p>
<p>ReferenceError 和作用域判别失败有关， TypeError 则是判别成功了，但是对结果的操作是非法的。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的事件循环</title>
    <url>/2021/12/29/JavaScript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程(执行栈)，异步的进入 Event Table 并注册函数。当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。<br>主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的 Event Loop(事件循环)。<br>这里异步任务的 Event Queue 分两种情况的，即宏任务 (macrotask) 和微任务 (microtask)，当主线程任务完成为空去 Event Quenu 读取函数的时候，是先读取的微任务，当微任务执行完毕之后，才会继续执行宏任务。<br>综上事件循环为：同步 &gt; 异步   微任务 &gt; 宏任务<br>那么微任务和宏任务都有什么呢，简单总结下就是：<br>宏任务：整体代码 script，setTimeout，setInterval<br>微任务：原生 Promise 相关，process.nextTick</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);&#125;, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">    arr.push(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;start&quot;</span></span><br><span class="line"><span class="string">&quot;async1 start&quot;</span></span><br><span class="line"><span class="string">&quot;async2&quot;</span></span><br><span class="line"><span class="string">&quot;promise1&quot;</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="string">&quot;end&quot;</span></span><br><span class="line"><span class="string">&quot;async1 end&quot;</span></span><br><span class="line"><span class="string">&quot;promise2&quot;</span></span><br><span class="line"><span class="string">&quot;setTimeout&quot;</span></span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ol>
<li>主函数打印”start”。</li>
<li>执行 setTimeout，将 setTimeout 回调函数放入异步宏任务队列。</li>
<li>调用 async1，依次打印”async1 start”、”async2”，将 await 后面的回调函数放到异步微任务队列。</li>
<li>执行 new Promise，输出”promise1”,将 then 里面的回调函数放入异步微任务队列。</li>
<li>执行耗时长的循环语句并打印 arr,并且输出”end”，这时候主栈执行完毕为空。</li>
<li>将异步微任务队列里的函数按照”先进先出”的顺序依次执行，输出”async1 end”,”promise2”。</li>
<li>将异步宏任务队列里的函数按照”先进先出”的顺序依次执行，输出”setTimeOut”。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>)</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"><span class="string">&quot;8&quot;</span></span><br><span class="line"><span class="string">&quot;9&quot;</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="string">&quot;7&quot;</span></span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ol>
<li>首先浏览器执行Js代码由上至下顺序，遇到 setTimeout，把 setTimeout 分发到宏任务 Event Queue 中</li>
<li>new Promise 属于主线程任务直接执行打印 2</li>
<li>Promis 下的 then 方法属于微任务，把 then 分到微任务 Event Queue 中</li>
<li>console.log(‘4’) 属于主线程任务，直接执行打印4</li>
<li>又遇到 new Promise 也是直接执行打印 5，Promise 下到 then 分发到微任务 Event Queue中</li>
<li>又遇到 setTimouse 也是直接分发到宏任务 Event Queue中，等待执行</li>
<li>console.log(‘10’) 属于主线程任务直接执行</li>
<li>遇到 bar() 函数调用，执行构造函数内到代码，打印 8，在 bar 函数中调用 foo 函数，执行 foo 函数到中代码，打印 9</li>
<li>主线程中任务执行完后，就要执行分发到微任务 Event Queue 中代码，实行先进先出，所以依次打印 3，6</li>
<li>微任务 Event Queue 中代码执行完，就执行宏任务 Event Queue 中代码，也是先进先出，依次打印 1，7。</li>
</ol>
<p>Promise 本身是同步的立即执行函数， 当在 executor 中执行 resolve 或者 reject 的时候, 此时是异步操作， 会先执行 then/catch 等，当主栈完成后，才会去调用 resolve/reject 中存放的方法执行，打印 p 的时候，是打印的返回结果，一个 Promise 实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1 end&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序: script start -&gt; promise1 -&gt; promise1 end -&gt; script end -&gt; promise2 -&gt; settimeout</span></span><br></pre></td></tr></table></figure>
<p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序：script start -&gt; async1 start -&gt; async2 -&gt; script end -&gt; async1 end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Less和CSS的区别</title>
    <url>/2021/04/02/Less%E5%92%8CCSS%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Less和CSS介绍"><a href="#Less和CSS介绍" class="headerlink" title="Less和CSS介绍"></a>Less和CSS介绍</h1><p>Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。</p>
<p>LESS是一个 CSS 预处理器，可以为网站启用可自定义，可管理和可重用的样式表。LESS 是一种动态样式表语言，扩展了 CSS 的功能。 LESS 也是跨浏览器友好。</p>
<p>CSS预处理器是一种脚本语言，可扩展 CSS 并将其编译为常规 CSS 语法，以便可以通过 Web 浏览器读取。 它提供诸如变量，函数，mixins 和操作等功能，可以构建动态 CSS。</p>
<p>Less 允许我们定义变量，使用嵌套式声明，定义函数等。严格说 Less 包含两部分：（1）Less 的语法 （2）Less 预处理器。浏览器终究只认识 CSS，所以 Less 文件需要经过 Less 预处理器编译成为 CSS。</p>
<p>CSS：层叠样式表是一种用来表现 HTML（标准通用标记语言的一个应用）或 XML（标准通用标记语言的一个子集）等文件样式的计算机语言。</p>
<h1 id="二、Less与CSS区别总结"><a href="#二、Less与CSS区别总结" class="headerlink" title="二、Less与CSS区别总结"></a>二、Less与CSS区别总结</h1><p>1、Less 是一门 CSS 预处理语言，CSS 是一种用来表现 HTML 或 XML 等文件样式的计算机语言。</p>
<p>2、Less 扩展了 CSS 语言，增加了变量、Mixin、函数等特性。</p>
<p>3、CSS 可以被浏览器直接识别，Less 需要先编译为 CSS。</p>
]]></content>
      <tags>
        <tag>HTML+CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>TS使用初体验</title>
    <url>/2021/10/26/TS%E4%BD%BF%E7%94%A8%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今年年初的时候入职了新的公司，技术栈使用的是 Vue + Typescript，先不说 Vue，TS 之前只是看了一些文章和官方文档，只是知道能在变量后面加个类型，就可以限制变量。后来入职后，不知不觉也写了大半年 TS，对于那些变量或函数要写，为了写了返回类型，VSCode 提示返回值还是 any 类型，泛型的具体应用，接口定义怎么写之类的问题，有了一点理解。</p>
<h1 id="TS-是写给谁看-用的？"><a href="#TS-是写给谁看-用的？" class="headerlink" title="TS 是写给谁看/用的？"></a>TS 是写给谁看/用的？</h1><p>首先，TS 是定义者给使用者写的。为了让使用者更方便（VSCode 提示）以及更安全（约束）的使用他提供的方法或者类。<br>使用 TS，是有两个方式的，定义和使用。</p>
<h1 id="VSCode-提示"><a href="#VSCode-提示" class="headerlink" title="VSCode 提示"></a>VSCode 提示</h1><p>例如：定义者指定了一个方法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么作为使用者， 你会很清晰的通过 VSCode 的提示了解到该函数的参数和返回值信息：<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEChEDvmmqN8xR0uhxzpgVR9FWCCL6deT1WaBqXNqr3RIhzOEw8LAtlEdC9rBYjPolrW5oVLFSEJBZ3*Mz4ZR9nk!/r" alt="Image text"></p>
<p>而不需要去看源码，一些复杂的方法，如果没有良好的注释，即使看源码也不一定能很快的判断出来参数和返回值类型。</p>
<h1 id="VSCode-提示-1"><a href="#VSCode-提示-1" class="headerlink" title="VSCode 提示"></a>VSCode 提示</h1><p>为了提供更完美的 VSCode 提示信息，还可以给方法加一个注释：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** foo function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>count string size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候使用者看到的是：<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEHG8D4L5qlc7pdlIYIowl3yqAH82vAXNqN9ycF80qYI8mxBjqOk5p8143H6SDVEX0xwBrhACfSJaNZbgnH9xlFA!/r" alt="Image text"></p>
<p>所以，当要提供一个方法或者类给别人用的时候，就需要把类型约束好，这样才能让使用者更好的使用。这里的提供给别人使用，往大了说就是提供一个第三方类库或者框架给别人用，如：axios lodash 等，往小了说可能就是提取一个公用的方法到你的 utils 文件夹下。</p>
<h1 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h1><p>其实也不是所有的变量或者返回值都需要手动去设置类型，通过类型推断，可以少些很多代码。</p>
<p>我们看下面的例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">splitString</span>(<span class="params">str: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> separator = <span class="string">&#x27;,&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> str.split(separator)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 separator 就可以不用写成 separator:string，TS会进行类型推断。<br>进一步，返回类型我们也可以不用定义，TS 会根据 split 方法的返回类型来推断 splitString 的返回类型。</p>
<p><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEIGC0Zp.vnmMms5c4dyCNfJrNV5UlIEmKoLqYXPtJ*QEAtJgpWQbL5ODqpd..atB*rrQrGYKg10A9amREO4S2mM!/r" alt="Image text"></p>
<p>类型推论只适用于一些简单的类型，复杂的情况还是需要手动定义。可以通过 VSCode 的提示检测是否正确推断了类型。<br>说的极端一点，TS 就是为了让使用者爽，有更好的提示和约束，让你知道你是否有正确安全的使用提供的方法。而不是为了增加工作量和心智负担。</p>
<h1 id="什么时候用泛型"><a href="#什么时候用泛型" class="headerlink" title="什么时候用泛型"></a>什么时候用泛型</h1><p>要知道这个问题之前，首先要知道什么是泛型，泛型解决了什么问题。可以先看看文档。<br>在了解了泛型是让一个组件支持多种类型之后。如果还不知道什么时候用泛型，那就是还不需要用。等遇到了痛点，自然就会想到泛型了。<br>比如定义了一个方法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">arg:<span class="built_in">number</span></span>):<span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要让这个方法支持 string 类型的时候，不使用泛型的话，你可能这么写：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个问题，会出现传入 number，返回 string 这样的情况，不够严谨。<br>这个时候就会想到泛型了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，泛型的玩法不都是那么简单的，想要玩出更高阶的泛型写法，可以多看看第三方库写的类型定义文件，看看别人是怎么写各种泛型的。</p>
<h1 id="类型定义在哪？"><a href="#类型定义在哪？" class="headerlink" title="类型定义在哪？"></a>类型定义在哪？</h1><p>这个问题跟上面的问题是一样的，当你不知道这玩意什么时候用，那你应该是还用不到这个玩意儿。<br>简单的不重用的就直接写，如上面的示例方法。<br>需要重用的一般来说就在方法实现的文件夹自定义一个类型，并 export 出去，方便其他使用者使用。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> fooItem = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg: fooItem</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用一个文件夹，专门放各种公用数据类型。比如在定义前后端接口数据的时候，就可以这么干：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/model/user.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> userReq &#123;</span><br><span class="line">  username: <span class="built_in">string</span></span><br><span class="line">  password: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> userRes &#123;</span><br><span class="line">  nickname: <span class="built_in">string</span></span><br><span class="line">  avatar?: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文没有讲TS的技巧，没有讲TS的优点，就是我基于个人使用 TS 的经验进行简单的解答和讲解，讲的比较凌乱。</p>
<p>其实 TS 没有想象的那么复杂，TS 的初衷是在帮助开发者，服务开发者，要享受 TS 带来的便捷和快感。结尾用一句几乎每个用过 TS 的人都会说的话：</p>
<blockquote>
<p>用了 TS 就回不去 JS</p>
</blockquote>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/25/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>“[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)” what &amp; why?</title>
    <url>/2020/11/01/%5B&#39;1&#39;,%20&#39;2&#39;,%20&#39;3&#39;%5D.map(parseInt)%20what%20&amp;%20why/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是真正的答案是[1, NaN, NaN]。</p>
<p>首先回顾一下，map函数的第一个参数callback：<br>var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])<br>这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。</p>
<p>而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。<br>parseInt(string, radix)<br>接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。</p>
<p>了解这两个函数后，我们可以模拟一下运行情况</p>
<ol>
<li>parseInt(‘1’, 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1</li>
<li>parseInt(‘2’, 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN</li>
<li>parseInt(‘3’, 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN<br>map函数返回的是一个数组，所以最后结果为[1, NaN, NaN]</li>
</ol>
<p>最后附上MDN上对于这两个函数的链接，具体参数可以到里面看<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map</a></p>
<p>原文链接：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/4">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/4</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>this和强制改变this指向</title>
    <url>/2020/04/13/this%E5%92%8C%E5%BC%BA%E5%88%B6%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>);<span class="comment">//[Objes y);//10,20</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>要改变它的this指向，有几种方法：<br>方法1：call<br>        格式： 函数名.call();<br>        参数：第一个参数：传入该函数this指向的对象，传入什么就强制指向什么<br>              从第二个参数开始，将原函数的参数往后顺延一位<br>        注：call主要目的是为了绑定参数，apply则是出现…运算符之前的老旧写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">show.call(<span class="string">&quot;call&quot;</span>, <span class="number">20</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<p>方法2：apply<br>        格式：函数名.apply();<br>        参数：第一个参数；传入该函数this指向的对象，传入什么就强制指向什么<br>              第二个参数：数组，放入原有的所有参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">show.apply(<span class="string">&quot;call&quot;</span>, [<span class="number">20</span>, <span class="number">40</span>]);</span><br></pre></td></tr></table></figure>

<p>方法3：bind预设this指向</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>);</span><br><span class="line">            alert(x + <span class="string">&quot;,&quot;</span> + y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> res = show.bind(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="comment">//res(40, 50);</span></span><br><span class="line">        show.bind(<span class="string">&quot;bind&quot;</span>)(<span class="number">40</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>apply使用方法的小技巧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.min();</span><br><span class="line">Math.max();</span><br><span class="line">alert(Math.min(10,20,30,40,50));</span><br><span class="line">alert(Math.max(10,20,30,40,50));</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [10,20,30,40,50];</span><br><span class="line">alert(Math.min.apply(null, arr));</span><br><span class="line">alert(Math.max.apply(null, arr));</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>this绑定的四种方式</title>
    <url>/2021/06/13/this%E7%BB%91%E5%AE%9A%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h1><p>this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域。this 实际上是在函数调用时发生的绑定，它只想什么完全取决于函数在哪里被调用。</p>
<h1 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h1><p>找到函数的调用位置后，判断需要应用下面四条规则中的那一条。首先会解释这四条规则，然后解释多条规则可用湿他们的优先级如何排列</p>
<h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>首先是最常用的函数调用类型：独立函数调用。可以把这条规则看做是无法应用其他规则时的默认规则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo();<span class="comment">// 2</span></span><br><span class="line"><span class="string">``</span><span class="string">`                                                   </span></span><br><span class="line"><span class="string">当调用 foo() 时，this.a 被解析成了全局变量 a，因为在本例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">要知道是否使用了默认绑定。可以通过查看 foo() 是如何调用的。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果使用严格模式（strict mode），则不能将对象用于区默认绑定，this 会绑定到 undefined。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo();<span class="comment">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>隐式绑定需要考虑调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>调用位置会使用 obj 上下文来引用函数，因此可以说函数被调用时 obj 对象“拥有”或者“包含”函数引用。当 foo() 被调用时，它的前面确实加上了对 obj 的引用。当函数引用有上下文对象时，隐式绑定会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。</p>
<p>对象属性引用链中只有上一层或者最后一层在调用位置中起作用，举例来说</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">42</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    obj2: obj2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.obj2.foo(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<h3 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h3><p>一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是他会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。<br>思考以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数别名</span></span><br><span class="line"><span class="keyword">var</span>  a = <span class="string">&quot;oops, global&quot;</span>; <span class="comment">// a 是全局对象的属性</span></span><br><span class="line">bar(); <span class="comment">// &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure>
<p>虽然 bar 是 obj.foo 的一个引用，但是实际上它引用的是 foo 函数本身，因此此刻的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定<br>此外，回调函数有可能会丢失 this 绑定，可以通过固定 this 来解决这个问题</p>
<h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><p>使用 call() 和 apply() 方法可以直接指定 this 的绑定对象，因此称为显式绑定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj  = &#123;</span><br><span class="line">    a: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(obj); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>通过 foo.call(…)，可以在调用 foo 时将它的 this 强制绑定到 obj 上。<br>从 this 绑定的角度来说，call() 和 apply() 是一样的，区别在于 call() 的参数是依次传入的，apply() 的参数为在数组中一次性传入</p>
<h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><p>使用 new 来调用函数，会自动执行以下操作</p>
<ol>
<li>创建一个全新的对象。</li>
<li>这个新对象会被执行 Prototype 指向。</li>
<li>这个新对象会绑定到函数调用的 this。</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar.a);<span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
使用 new 调用 foo 时，会构造一个新对象并把它绑定到 foo() 调用中的 this 上。</li>
</ol>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>可以按照下面顺序来判断<br>从先到后分别为</p>
<ol>
<li>var bar = new foo()         new 绑定</li>
<li>var bar = foo.call(obj2)    call()、apply() 显式绑定</li>
<li>var bar = obj1.foo          在上下文对象中调用（隐式绑定）</li>
<li>var bar = foo()             默认绑定</li>
</ol>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>url编码及api的使用</title>
    <url>/2021/03/14/url%E7%BC%96%E7%A0%81%E5%8F%8Aapi%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在因特网上传送 URL，只能采用 ASCII 字符集，即是常说的 get 请求只能使用 ASCII 字符。</p>
<p>也就是说 URL 只能使用字母和数字[0-9a-zA-Z]、一些特殊符号$-_.+!*’()[不包括双引号]、以及某些保留字（空格转换为+），才可以不经过编码直接用于 URL。</p>
<p>Javascript 中提供了3对函数用来对 url 编码以得到合法的 url，他们分别是</p>
<ul>
<li>escape / unescape</li>
<li>encodeURI / decodeURI</li>
<li>encodeURIComponent / decodeURIComponent</li>
</ul>
<p>这三个编码的函数——escape，encodeURI，encodeURIComponent——都是用于将不安全不合法的 Url 字符转换为合法的Url字符表示，它们有以下几个不同点。</p>
<ol>
<li><p>安全字符不同：<br>下面列出了这三个函数的安全字符（即函数不会对这些字符进行编码）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">escape</span>（<span class="number">69</span>个）：    */@+-._0-<span class="number">9</span>a-zA-Z</span><br><span class="line"><span class="built_in">encodeURI</span>（<span class="number">82</span>个）：    !#$&amp;<span class="string">&#x27;()*+,/:;=?@-._~0-9a-zA-Z</span></span><br><span class="line"><span class="string">encodeURIComponent（71个）：    !&#x27;</span>()*-._~<span class="number">0</span>-<span class="number">9</span>a-zA-Z</span><br></pre></td></tr></table></figure></li>
<li><p>对 Unicode 字符的编码方式不同：<br>这三个函数对于 ASCII 字符的编码方式相同，均是使用百分号 + 两位十六进制字符来表示。但是对于 Unicode 字符，escape 的编码方式是 %uxxxx，其中的 xxxx 是用来表示 unicode 字符的4位十六进制字符。这种方式已经被 W3C 废弃了。但是在 ECMA-262 标准中仍然保留着 escape 的这种编码语法。encodeURI 和 encodeURIComponent 则使用UTF-8 对非 ASCII 字符进行编码，然后再进行百分号编码。这是 RFC 推荐的。因此建议尽可能的使用 <strong>encodeURI 和 encodeURIComponent</strong> 这两个函数替代 escape 进行编码。</p>
</li>
<li><p>适用场合不同：<br>encodeURI 被用作对一个完整的 URI 进行编码，而 encodeURIComponent 被用作对URI的一个组件进行编码。从上面提到的安全字符范围表格来看，我们会发现，encodeURIComponent 编码的字符范围要比 encodeURI 的大。</p>
</li>
</ol>
<h2 id="encodeURI-："><a href="#encodeURI-：" class="headerlink" title="encodeURI()："></a>encodeURI()：</h2><ul>
<li>encodeURI() 是 Javascript中真正用来对 URL 编码的函数。<br>它着眼于对整个URL进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp; = + $ , #”，也不进行编码。编码后，它输出符号的 utf-8 形式，并且在每个字节前加上%。</li>
</ul>
<h2 id="encodeURIComponent"><a href="#encodeURIComponent" class="headerlink" title="encodeURIComponent()"></a>encodeURIComponent()</h2><ul>
<li>它用于对 URL 的组成部分进行个别编码，而不用于对整个 URL 进行编码。<br>因此，”; / ? : @ &amp; = + $ , #”，这些在 encodeURI() 中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。</li>
</ul>
<h2 id="encodeURIComponent-和-encodeURI-的区别演示："><a href="#encodeURIComponent-和-encodeURI-的区别演示：" class="headerlink" title="encodeURIComponent() 和 encodeURI() 的区别演示："></a>encodeURIComponent() 和 encodeURI() 的区别演示：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURI</span>(<span class="string">&quot;?name=zhangsan&amp;age=21&quot;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURIComponent</span>(<span class="string">&quot;?name=zhangsan&amp;age=21&quot;</span>)) </span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020080916202843.png" alt="Image text"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>开发中大部分情况下使用 encodeURI / decodeURI 和 encodeURIComponent / decodeURIComponent 完全可以了</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的两种引用方式</title>
    <url>/2021/03/26/%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>两段代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name:<span class="string">&quot;a&quot;</span>,</span><br><span class="line">        age:<span class="number">22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = person();</span><br><span class="line"><span class="keyword">var</span> obj2 = person();</span><br><span class="line">obj1.name = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">name</span>: <span class="string">&quot;b&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;</span><br><span class="line">&#123;<span class="attr">name</span>: <span class="string">&quot;a&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name:<span class="string">&quot;a&quot;</span>,</span><br><span class="line">    age:<span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = person();</span><br><span class="line"><span class="keyword">var</span> obj2 = person();</span><br><span class="line">obj1.name = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">name</span>: <span class="string">&quot;b&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;</span><br><span class="line">&#123;<span class="attr">name</span>: <span class="string">&quot;b&quot;</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;</span><br></pre></td></tr></table></figure>
<p>结果不同的原因也可以理解为浅拷贝和深拷贝引用，第一段代码里的 obj1 和 obj2 分别是函数 person 返回的完全独立的对象，所以修改一个不会影响另一个。<br>第二段代码里的 obj1 和 obj2 是指向 obj 的指针，修改其中一个会直接修改 obj 的内容</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>web通讯的四种方式：短轮询、长轮询(comet)、长连接(SSE)、WebSocket</title>
    <url>/2020/10/29/web%E9%80%9A%E8%AE%AF%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%9F%AD%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2(comet)%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5(SSE)%E3%80%81WebSocket/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>http端轮询是服务器收到请求不管是否有数据都直接响应 http 请求;<br>其实就是普通的轮询。指在特定的的时间间隔（如每1秒），由浏览器对服务器发出 HTTP request，然后由服务器返回最新的数据给客户端的浏览器。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>传统的 web 通信模式。后台处理数据，需要一定时间，前端想要知道后端的处理结果，就要不定时的向后端发出请求以获得最新情况。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>前后端程序编写比较容易。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>请求中有大半是无用，难于维护，浪费带宽和服务器资源；<br>响应的结果没有顺序（因为是异步请求，当发送的请求没有返回结果的时候，后面的请求又被发送。而此时如果后面的请求比前面的请 求要先返回结果，那么当前面的请求返回结果数据时已经是过时无效的数据了）。</p>
<h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><pre><code>适于小型应用。</code></pre>
<h2 id="前端实现："><a href="#前端实现：" class="headerlink" title="前端实现："></a>前端实现：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;/user&#x27;</span>);</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h1 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>客户端向服务器发送 Ajax 请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。</p>
<h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>在无消息的情况下不会频繁的请求，耗费资源小。</p>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>服务器 hold 连接会消耗资源<br>返回数据顺序无保证，难于管理维护。<br>浏览器端对统一服务器同时 http 连接有最大限制, 最好同一用户只存在一个长轮询;</p>
<h2 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h2><p>WebQQ、Hi 网页版、Facebook IM。</p>
<h2 id="前端实现：-1"><a href="#前端实现：-1" class="headerlink" title="前端实现："></a>前端实现：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">       xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;/user&#x27;</span>);</span><br><span class="line">       xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             ajax();</span><br><span class="line">       &#125;;</span><br><span class="line">       xhr.send();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>长轮询和短轮询</p>
<ul>
<li>相同点：可以看出 http 长轮询和 http 短轮询的都会 hold 一段时间;</li>
<li>不同点：间隔发生在服务端还是浏览器端: http 长轮询在服务端会 hold 一段时间, http 短轮询在浏览器端 “hold”一段时间;</li>
</ul>
<h1 id="http-长连接"><a href="#http-长连接" class="headerlink" title="http 长连接"></a>http 长连接</h1><p>目前 http 协议普遍使用的是 1.1 版本, 之前有个 1.0 版本,两者之间的一个区别是 1.1 支持 http 长连接, 或者叫持久连接。<br>1.0 不支持 http 长连接, 每次一个 http请求响应后都关闭 tcp 连接, 下个 http 请求会重新建立 tcp 连接.</p>
<h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>多个 http 请求共用一个 tcp 连接; 这样可以减少多次临近 http 请求导致 tcp建立关闭所产生的时间消耗.</p>
<p>http 1.1 中在请求头和相应头中用 connection 字段标识是否是 http长连接, connection: keep-alive, 表明是 http 长连接; connection:closed, 表明服务器关闭 tcp 连接</p>
<p>与 connection 对应的一个字段是 keep-live, http 响应头中出现, 他的格式是 timeout=30,max=5, timeout 是两次 http 请求保持的时间(s), , max 是这个 tcp 连接最多为几个 http请求重用</p>
<h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><p>消息即时到达，不发无用请求；管理起来也相对方便。</p>
<h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><p>服务器维护一个长连接会增加开销。</p>
<h2 id="实例：Gmail聊天"><a href="#实例：Gmail聊天" class="headerlink" title="实例：Gmail聊天"></a>实例：Gmail聊天</h2><h1 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>Websocket 是基于 HTTP 协议的，在和服务端建立了链接后，服务端有数据有了变化后会主动推送给前端。</p>
<h2 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h2><p>请求响应快，不浪费资源。（传统的 http 请求，其并发能力都是依赖同时发起多个 TCP 连接访问服务器实现的(因此并发数受限于浏览器允许的并发连接数)，而 websocket 则允许我们在一条 ws 连接上同时并发多个请求，即在A请求发出后A响应还未到达，就可以继续发出B请求。由于 TCP 的慢启动特性（新连接速度上来是需要时间的），以及连接本身的握手损耗，都使得 websocket 协议的这一特性有很大的效率提升；http 协议的头部太大，且每个请求携带的几百上千字节的头部大部分是重复的，websocket 则因为复用长连接而没有这一问题。）</p>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>主流浏览器支持的Web Socket 版本不一致；<br>服务端没有标准的 API。</p>
<h2 id="实例：实现即时通讯-如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询"><a href="#实例：实现即时通讯-如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询" class="headerlink" title="实例：实现即时通讯:如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询"></a>实例：实现即时通讯:如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询</h2><h2 id="解决：解决了http协议的两个问题。"><a href="#解决：解决了http协议的两个问题。" class="headerlink" title="解决：解决了http协议的两个问题。"></a>解决：解决了http协议的两个问题。</h2><ol>
<li>服务端的被动性。http 协议是只有客户端询问之后才回复。解决了同步有延迟的问题</li>
<li>解决了服务器上消耗资源的问题</li>
</ol>
<h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要先npm install ws</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器端</span></span><br><span class="line"><span class="keyword">var</span> Server = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>).Server;</span><br><span class="line"><span class="keyword">var</span> wss = <span class="keyword">new</span> Server(&#123;</span><br><span class="line">    port:<span class="number">2000</span></span><br><span class="line">&#125;);</span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ws</span>)</span>&#123;</span><br><span class="line">    ws.on(<span class="string">&#x27;message&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        ws.send(<span class="string">&#x27;你好,客户端,我是服务器!&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//node客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:2000/&#x27;</span>);</span><br><span class="line">socket.on(<span class="string">&#x27;open&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    socket.send(<span class="string">&#x27;你好，服务器,我是客户端&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">socket.on(<span class="string">&#x27;message&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//html客户端(注:浏览器客户端与node客户端只需要一种)</span></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:2000/&#x27;</span>);</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WebSocket四个事件操作"><a href="#WebSocket四个事件操作" class="headerlink" title="WebSocket四个事件操作"></a>WebSocket四个事件操作</h2><ul>
<li>onmessage 收到服务器响应时执行</li>
<li>onerroe 出现异常时执行</li>
<li>onopen 建立起连接时执行</li>
<li>onclose 断开连接时执行</li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>图的遍历——广度优先搜索和深度优先搜索</title>
    <url>/2020/10/30/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前置知识：图的相关术语和图的表示</p>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>和树数据结构类似，我们可以访问图的所有节点。由两种算法可以对图进行遍历：<strong>广度优先搜索（breadth-first search，BFS）</strong>和<strong>深度优先搜索（depth-first search，DFS）</strong>。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查路径是否相同，检查图是否有环，等等。</p>
<p>在实现算法之前，让我们来更好的理解一下图遍历的思想。</p>
<p><strong>图遍历算法</strong>的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有完全被探索，对于两种图遍历算法，都需要明确指出第一个被访问的顶点。</p>
<p>完全探索第一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加入待访问的定点列表中。</p>
<p>为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。</p>
<p>广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点列表的数据结构。如下表所示</p>
<table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">数据结构</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">深度优先搜索</td>
<td align="left">栈</td>
<td align="left">将顶点存入栈，顶点是沿着路径被探索的，存在新的相邻顶点就去访问</td>
</tr>
<tr>
<td align="left">广度优先搜索</td>
<td align="left">队列</td>
<td align="left">将顶点存入队列，最先入队列的顶点先被搜索</td>
</tr>
</tbody></table>
<p>当要标注已经访问过的顶点时，我们用三种颜色来反映它们的状态。</p>
<ul>
<li>白色：表示该顶点还没有被访问。</li>
<li>灰色：表示该顶点被访问过，但并未被探索过。</li>
<li>黑色：表示该顶点被访问过且被完全探索过。</li>
</ul>
<p>这就是之前提到的务必访问每个顶点最多两次的原因。</p>
<p>为了有助于在广度优先和深度优先算法中标记定点。我们要使用 Colors 变量（作为一个枚举器），声明如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Colors = &#123;</span><br><span class="line">    WHITE: <span class="number">0</span>,</span><br><span class="line">    GREY: <span class="number">1</span>,</span><br><span class="line">    BLACK: <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>两个算法还需要访问一个辅助对象来帮助存储顶点是否被访问过。在每个算法的开头，所有的顶点都会被标记为未访问（白色）。我们要用下面的函数来初始化每个顶点的颜色。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initColor = <span class="function"><span class="params">vertices</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> color = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertices.length; i++</span>)</span>&#123;</span><br><span class="line">        color[vertices[i]] = Colors.WHITE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有邻点（相邻顶点），就像一次访问图的一层。换句话说，就是先宽后深的访问顶点，如下图所示<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrENvAK4hCVLHst1Ssx8xTOzSnZk4FpVPApa5BpTrf.Ojk7.j1y4mouG74Usz7fdaq8H0JlVD3*KnGxqQgxCPgClA!/r" alt="Image text"><br>以下是从顶点v开始的广度优先搜索算法所遵循的步骤。</p>
<p>(1) 创建一个队列 Q。<br>(2) 标注 v 为被发现的（灰色），并将 v 入队列 Q。<br>(3) 如果 Q 非空，则运行以下步骤：<br>    (a) 将 u 从 Q 中出队列；<br>    (b) 标注 u 为被发现的（灰色）；<br>    (c) 将 u 所有未被访问过的邻点（白色）入队列；<br>    (d) 标注 u 为已被探索的（黑色）。</p>
<p>让我们来实现广度优先搜索算法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> breathFirstSearch = <span class="function">(<span class="params">graph, startVertex, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> startVertex = graph.getVertices;</span><br><span class="line">    <span class="keyword">const</span> adjList = graph.getAdjList;</span><br><span class="line">    <span class="keyword">const</span> color = initColor(vertices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">    queue.enqueue(startVertex);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">while</span>(<span class="params">!queue.isEmpty()</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> u = queue.dequeue();</span><br><span class="line">        <span class="keyword">const</span> neighbors = adjList.get(u);</span><br><span class="line">        color[u] = Colors.GREY;</span><br><span class="line">        <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> w = neighbors[i];</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">color[w] === Colors.WHITE</span>)</span>&#123;</span><br><span class="line">                color[w] = Colors.GREY;</span><br><span class="line">                queue.enqueue(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        color[u] = Colors.BLACK;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">            callback(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="深度优先搜素"><a href="#深度优先搜素" class="headerlink" title="深度优先搜素"></a>深度优先搜素</h2><p>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条卢静最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是是先深度后广度地访问顶点，如下图所示<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEO7a7xpq*swiCvkKkkTZecTjQEoR89aVQ*WEn7KMBcryBowgzBlEHeSnKkiqeKpdq1J*fk2xlJvTX4HmbNXqrUE!/r" alt="Image text"><br>深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点 v 未访问，则访问该顶点 v。</p>
<p>要访问顶点 v，照如下步骤做：<br>(1) 标注 v 为未被发现的（灰色）；<br>(2) 对于 v 的所有未访问（白色）的邻点 w，访问顶点 w；<br>(3) 标注 v 为已被探索的（黑色）；</p>
<p>深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）。</p>
<p>让我们来实现一下深度优先算法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> depthFirstSearch = <span class="function">(<span class="params">graph, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> startVertex = graph.getVertices();</span><br><span class="line">    <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">    <span class="keyword">const</span> color = initColor(vertices);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">color[vertices[i]] === Colors.WHITE</span>)</span>&#123;</span><br><span class="line">            depthFirstSearchVisit(vertices[i], color, adjList, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> depthFirstSearchVisit = <span class="function">(<span class="params">u, color, adjList, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    color[u] = Colors.GRAY;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">        callback(u)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> neighbors = adjList.get(u);</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> w = neighbors[i];</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">color[w] === Colors.WHITE</span>)</span>&#123;</span><br><span class="line">            depthFirstSearchVisit(w, color, adjList, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    color[u] = Colors.BLACK;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>写此文的原因是在面试时面试官看我在简历上写了数据结构与算法(Leetcode120+)，便询问做的题以哪方面为主，答曰数组和树。一面让手写了一下先序遍历，这个写出来了，二面换了个人问广度优先搜索和深度优先搜索。啊这，答不上来。因为当时是在学习图的时候看到这两个概念，但是图已经是书本介绍的最后一个数据结构了，而且感觉不怎么常见，就没把那章节看完。<del>加上当时已经学到Node.js、计网、异步等信息量比较大的知识，后续更是在学框架写东西，就没再研究数据结构与算法了</del></p>
<p>所以这将成为本博客第一个数据结构与算法相关的文章。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>扫码点餐各个页面的制作过程</title>
    <url>/2020/11/15/%E6%89%AB%E7%A0%81%E7%82%B9%E8%8F%9C%E4%B8%80%E4%BA%9B%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="扫码点餐各个页面是如何实现的"><a href="#扫码点餐各个页面是如何实现的" class="headerlink" title="扫码点餐各个页面是如何实现的"></a>扫码点餐各个页面是如何实现的</h1><h2 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h2><p>首先用到的模块是 ‘react-router-dom’ 的 withRouter 和封装好的 axios API。整个登录逻辑写在 withRouter中，在 jsx 里使用 ref 获得输入的用户名、密码、验证码，登录先 preventDefault 然后用户名密码验证码分别是 ref 获取到的当前输入值，使用 try-catch 用 post 请求发送给后端，如果成功就用 history.push 给 url 传值转跳页面，不然就 alert 后端设定好的错误信息。</p>
<h2 id="点餐界面："><a href="#点餐界面：" class="headerlink" title="点餐界面："></a>点餐界面：</h2><p>首先用到的模块是 ‘prop-types’，’immer’，’history’，’socket.io-client’。</p>
<p>菜单内容是一个函数组件，参数是 food，onupdate 和 amount，返回的 jsx 是一个菜单列表，列表里的每个菜都有按钮可以增减选择数量，使用 onupdate 来控制点击按钮时的菜品数量增减。<br>随后用到了 React 的属性验证功能 要求菜单内容这个函数组件必须要传参数且必须要传指定类型的参数。calTotaoPrice 是一个用 reduce 来计算下单总价的函数，初始值为 0 元。</p>
<p>购物车状态是一个函数组件，返回的 jsx 显示了当前下单总价，以及展开收起按钮，使用 useState 来控制是否展开，默认 false。</p>
<p>点餐主界面是一个类组件，state 里有三个属性：cart 数组里放当前点了的菜，foodMenu 数组里放当前提供可选的菜品列表，deskInfo 对象里是当前的餐桌号，顾客数，总价，点了的菜。</p>
<p>接下来是各个生命周期里做的事情：在 componentDidMount 中，首先用 props.match.params 拿到路由传递过来的参数 params，然后用 get 请求到当前餐桌 id 和菜单信息用 setState 设置为当前餐桌和当前菜单信息。为了同步同一餐桌不同用户间的点单，设置 socket 的路径和请求，在接入餐桌连接时用 socket.on 在 ‘cart food’ 时向后端发送字符串命令和餐桌 id。后端发回此桌面已点菜单，这里用到了 immer 的 produce：先定义一个变更，有数据时再执行这个变更，然后用 socket.on 在 ‘new food’ 时调用 foodChange 函数变更菜品和数量，下单成功时用 socket.on 在 ‘placeorder success’ 时用路由 push 点餐成功页面的路径并将订单状态设置为 order。componentWillUnmount 中关闭 socket 链接。</p>
<p>cartChange 函数用 socket.emit 在 ‘new food’ 时向后端发送当前餐桌 id，所点食物和数量。placeOrder 函数用于下单，用 post 请求向后端发送路径和当前订单信息后转跳到成功界面，state 设置为 res.data。</p>
<p>最后点餐主界面 render 了菜单列表，返回的菜单列表用 map 渲染，返回的是当前能点的菜的列表。</p>
<h2 id="菜品管理："><a href="#菜品管理：" class="headerlink" title="菜品管理："></a>菜品管理：</h2><p>列表中每个菜是一个函数组件，可以进行菜品的删改增查，使用了三个 hook 来管理状态：setFoodInfo、setIsModify、setFoodProps，默认分别是food、false、和属性是菜品各项信息的对象。save 函数 new 一个 FormDate 后将遍历到的菜品属性键值对插入进去，然后用 put 请求向后端放松当前菜品 id 和属性后将菜品信息设置为当前菜品信息。</p>
<p>change 和 imgChange 函数用于重新设置菜品信息，使用 setFoodProps 将菜品信息设置为当前传入事件参数的值即可。然后是菜品的删除、设置是否提供，用put请求向后端发送状态后使用 hook 变更菜品属性即可。最后 jsx 返回的是修改界面，根据是修改将对应的 html 样式返回即可。最后整个函数组件返回的是菜品展示图和一些功能按钮（修改、保存、下架、上架、删除）。</p>
<h2 id="订单管理："><a href="#订单管理：" class="headerlink" title="订单管理："></a>订单管理：</h2><p>首先用到的模块是 ‘socket.io-client’，’immer’ 和封装好的 axios API。订单状态用 hook 的 useState 管理。订单列表使用函数组件。</p>
<p>然后是实现各个逻辑的函数。使订单状态变为确认：用 put 请求向后端发送当前订单 id 的状态变更为 confirmed，然后用 setOrder 将订单的属性设置为当前属性为 confirmed，setComplete 同理。</p>
<p>删除订单则是直接向后端发送对应订单 id 的 delete 请求即可。最后订单列表返回显示总价格、人数、订单状态、打印、确认、完成、删除功能的 jsx。</p>
<p>订单管理使用类组件，state 为由 orders 组成的数组。</p>
<p>在订单管理的生命周期中，componentDidMount 首先获取参数，定义 socket 的路径和请求，在 on ‘connect’ 是向后端发送当前加入餐厅 id，在 on ‘new order’ 时发送在当前页面新增一个订单。用 get 请求获取当前订单。componentWillUnmount 中关闭 socket 连接，和删除订单的函数。最后 render 的是订单管理页面，根据订单长度 map 一个订单项列表。</p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>扫码点餐时遇到的问题</title>
    <url>/2020/09/19/%E6%89%AB%E7%A0%81%E7%82%B9%E9%A4%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="在写个人项目——扫码点餐中碰到的一些问题"><a href="#在写个人项目——扫码点餐中碰到的一些问题" class="headerlink" title="在写个人项目——扫码点餐中碰到的一些问题"></a>在写个人项目——扫码点餐中碰到的一些问题</h1><h2 id="React报错-Objects-are-not-valid-as-a-React-Child"><a href="#React报错-Objects-are-not-valid-as-a-React-Child" class="headerlink" title="React报错: Objects are not valid as a React Child"></a>React报错: Objects are not valid as a React Child</h2><p>解决方法：标签之间的内容不能为对象，不能作为原生元素的子元素，但可以作为自定义组件的子元素</p>
<h2 id="React报错-props-is-not-defined-at-xxx-render"><a href="#React报错-props-is-not-defined-at-xxx-render" class="headerlink" title="React报错: props is not defined at xxx.render"></a>React报错: props is not defined at xxx.render</h2><p>解决方法：1. render中应写this.state，是否写成了props.state?</p>
<h2 id="Error-Request-failed-with-status-code-401"><a href="#Error-Request-failed-with-status-code-401" class="headerlink" title="Error: Request failed with status code 401"></a>Error: Request failed with status code 401</h2><p><img src="http://note.youdao.com/yws/public/resource/57483267a438c01a94484a62517b6eb4/xmlnote/DB20B89D253641DFBBE44436175CF3A9/642" alt="Image text"><br>一些前端基础功能部分抛出的错误，promise抛出的错误，不是响应体而是错误对象</p>
<h2 id="向后端请求餐桌信息，跨域问题"><a href="#向后端请求餐桌信息，跨域问题" class="headerlink" title="向后端请求餐桌信息，跨域问题"></a>向后端请求餐桌信息，跨域问题</h2><p><img src="http://note.youdao.com/yws/public/resource/57483267a438c01a94484a62517b6eb4/xmlnote/CAC2CD357C7F4F86AC9C8964CBDB9EEA/652" alt="Image text"><br>后端app.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(cors(&#123;</span><br><span class="line">  origin: <span class="literal">true</span>,<span class="comment">//修改这里</span></span><br><span class="line">  maxAge: <span class="number">86400</span>,</span><br><span class="line">  credentials: <span class="literal">true</span>,</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<h2 id="proxy-error"><a href="#proxy-error" class="headerlink" title="proxy error"></a>proxy error</h2><p><img src="http://note.youdao.com/yws/public/resource/57483267a438c01a94484a62517b6eb4/xmlnote/9F4153617CB84496A435AD090C1DA56F/665" alt="Image text"><br>proxy代理设置 “proxy”: “<a href="http://localhost:5002&quot;">http://localhost:5002&quot;</a> 即可<br>同代表本机的10.1.1就不可以，最好各处写的一致</p>
<h2 id="React脚手架运行npm-start报错-webpack版本问题"><a href="#React脚手架运行npm-start报错-webpack版本问题" class="headerlink" title="React脚手架运行npm start报错 webpack版本问题"></a>React脚手架运行npm start报错 webpack版本问题</h2><p>There might be a problem with the project dependency tree.<br>It is likely not a bug in Create React App, but something you need to fix locally.<br>The react-scripts package provided by Create React App requires a dependency:<br>“webpack”: “4.42.0”<br>Don’t try to install it manually: your package manager does it automatically.<br>However, a different version of webpack was detected higher up in the tree:<br>C:\Users\lenovo\node_modules\webpack (version: 4.41.6)<br>Manually installing incompatible versions is known to cause hard-to-debug issues.<br>If you would prefer to ignore this check, add SKIP_PREFLIGHT_CHECK=true to an .env file in your project.<br>That will permanently disable this message but you might encounter other issues.<br>To fix the dependency tree, try following the steps below in the exact order:</p>
<ol>
<li>Delete package-lock.json (not package.json!) and/or yarn.lock in your project folder.</li>
<li>Delete node_modules in your project folder.</li>
<li>Remove “webpack” from dependencies and/or devDependencies in the package.json file in your project folder.</li>
<li>Run npm install or yarn, depending on the package manager you use.<br>In most cases, this should be enough to fix the problem.<br>If this has not helped, there are a few other things you can try:</li>
<li>If you used npm, install yarn (<a href="http://yarnpkg.com/">http://yarnpkg.com/</a>) and repeat the above steps with it instead.<br>This may help because npm has known issues with package hoisting which may get resolved in future versions.</li>
<li>Check if C:\Users\lenovo\node_modules\webpack is outside your project directory.<br>For example, you might have accidentally installed something in your home folder.</li>
<li>Try running npm ls webpack in your project folder.<br>This will tell you which other package (apart from the expected react-scripts) installed webpack.<br>If nothing else helps, add SKIP_PREFLIGHT_CHECK=true to an .env file in your project.<br>That would permanently disable this preflight check in case you want to proceed anyway.<br>P.S. We know this message is long but please read the steps above :-) We hope you find them helpful!</li>
</ol>
<p>解决办法：在项目文件夹下，新建一个.env文件，在其中写上如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SKIP_PREFLIGHT_CHECK&#x3D;true</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>把packages处理成Vue插件</title>
    <url>/2020/11/02/%E6%8A%8Apackages%E5%A4%84%E7%90%86%E6%88%90vue%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>封装了几个Vue组件，怎么把它们制作制作成插件呢</p>
<p>先新建Vue项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue create my-ui</span><br></pre></td></tr></table></figure>
<p>在my-ui文件夹中新建packages和examples文件夹，packages用来存放我们封装的所有组件，examples用来进行测试，把src改成examples</p>
<p>新建vue.config.js，写入如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      entry: <span class="string">&#x27;examples/main.js&#x27;</span>,</span><br><span class="line">      template: <span class="string">&#x27;public/index.html&#x27;</span>,</span><br><span class="line">      filename: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 扩展 webpack 配置，使 packages 加入编译</span></span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.module</span><br><span class="line">      .rule(<span class="string">&#x27;js&#x27;</span>)</span><br><span class="line">      .include.add(path.resolve(__dirname, <span class="string">&#x27;packages&#x27;</span>)).end()</span><br><span class="line">      .use(<span class="string">&#x27;babel&#x27;</span>)</span><br><span class="line">      .loader(<span class="string">&#x27;babel-loader&#x27;</span>)</span><br><span class="line">      .tap(<span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 修改它的选项...</span></span><br><span class="line">        <span class="keyword">return</span> options</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将封装好的vue组件全部放到packages文件夹中，同时也要打包字体图标文件，将fonts文件夹也放到packages文件夹中</p>
<p>这里需要了解Vue的install方法，见Vue官方文档Vue.use(plugin)，意思是想要做一个插件，插件只要导出一个install就行，在packages文件夹中新建index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整个包的入口</span></span><br><span class="line"><span class="comment">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件搜将被注册</span></span><br><span class="line"><span class="comment">// 导入颜色选择器组件</span></span><br><span class="line"><span class="keyword">import</span> ColorPicker <span class="keyword">from</span> <span class="string">&#x27;./color-picker&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">&#x27;./button&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Dialog <span class="keyword">from</span> <span class="string">&#x27;./dialog&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Input <span class="keyword">from</span> <span class="string">&#x27;./input&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Checkbox <span class="keyword">from</span> <span class="string">&#x27;./checkbox&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Radio <span class="keyword">from</span> <span class="string">&#x27;./radio&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Switch <span class="keyword">from</span> <span class="string">&#x27;./switch&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./fonts/font.scss&#x27;</span></span><br><span class="line"><span class="comment">// 存储组件列表</span></span><br><span class="line"><span class="keyword">const</span> components = [</span><br><span class="line">  ColorPicker,</span><br><span class="line">  Button,</span><br><span class="line">  Dialog,</span><br><span class="line">  Input,</span><br><span class="line">  Checkbox,</span><br><span class="line">  Radio,</span><br><span class="line">  Switch</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册</span></span><br><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历注册全局组件</span></span><br><span class="line">  components.forEach(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.component(component.name, component)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否是直接引入文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">  install(<span class="built_in">window</span>.Vue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 导出的对象必须具有 install，才能被 Vue.use() 方法安装</span></span><br><span class="line">  install,</span><br><span class="line">  <span class="comment">// 以下是具体的组件列表</span></span><br><span class="line">  ColorPicker,</span><br><span class="line">  Button,</span><br><span class="line">  Dialog,</span><br><span class="line">  Input,</span><br><span class="line">  Checkbox,</span><br><span class="line">  Radio,</span><br><span class="line">  Switch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在examples的main.js中输入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 导入组件库</span></span><br><span class="line"><span class="keyword">import</span> HmUI <span class="keyword">from</span> <span class="string">&#x27;./../packages&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(HmUI)</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这时就可以使用了，在examples中测试一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &lt;hm-button type=<span class="string">&quot;primary&quot;</span>&gt;按钮&lt;/hm-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>最后，examples文件夹是没用的，真正有用的是packages文件夹</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>有难度的&#39;说一下从url输入到返回请求的过程&#39;</title>
    <url>/2022/04/18/%E6%9C%89%E9%9A%BE%E5%BA%A6%E7%9A%84&#39;%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BB%8Eurl%E8%BE%93%E5%85%A5%E5%88%B0%E8%BF%94%E5%9B%9E%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B&#39;/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="问题-从浏览器地址栏输入url到请求返回发生了什么"><a href="#问题-从浏览器地址栏输入url到请求返回发生了什么" class="headerlink" title="问题: 从浏览器地址栏输入url到请求返回发生了什么"></a>问题: 从浏览器地址栏输入url到请求返回发生了什么</h1><p>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址</p>
<h2 id="url为啥要解析，dns查询规则是什么？"><a href="#url为啥要解析，dns查询规则是什么？" class="headerlink" title="url为啥要解析，dns查询规则是什么？"></a>url为啥要解析，dns查询规则是什么？</h2><p>因为网络标准规定了URL只能是字母和数字，还有一些其它特殊符号，而且如果不转义会出现歧义</p>
<h3 id="那url编码的规则是什么呢？"><a href="#那url编码的规则是什么呢？" class="headerlink" title="那url编码的规则是什么呢？"></a>那url编码的规则是什么呢？</h3><p>utf-8</p>
<h4 id="然后怎么保证utf-8的编码？"><a href="#然后怎么保证utf-8的编码？" class="headerlink" title="然后怎么保证utf-8的编码？"></a>然后怎么保证utf-8的编码？</h4><p>可以用 encodeURIComponent</p>
<blockquote>
<p>encodeURIComponent 比 encodeURI有什么区别？<br>encodeURIComponent 编码范围更广，适合给参数编码，encodeURI 适合给 URL 本身（locaion.origin）编码，当然项目里一般都是用 qs 库去处理</p>
</blockquote>
<h2 id="然后说说dns解析流程，并且html如何做dns优化？"><a href="#然后说说dns解析流程，并且html如何做dns优化？" class="headerlink" title="然后说说dns解析流程，并且html如何做dns优化？"></a>然后说说dns解析流程，并且html如何做dns优化？</h2><ol>
<li>浏览器中输入网址域名，操作系统会先查 hosts 件是否有记录，有的话就会把相对应映射的 IP 返回。</li>
<li>hosts 文件没有就去查本地 dns 解析器有没有缓存。</li>
<li>然后就去找我们计算机上配置的 dns 服务器上有或者有缓存，就返回</li>
<li>还没有的话就去找根 DNS 服务器(全球 13 台，固定 ip 地址)，然后判断 .com 域名是哪个服务器管理，如果无法解析，就查找网址服务器是否能解析，直到查到网站的 IP 地址<blockquote>
<p>注意：dns 查询有两种模式，一种是转发模式，一种是非转发模式，我上面说的 4 是非转发模式。</p>
</blockquote>
<h3 id="前端可以做-dns-优化吗？"><a href="#前端可以做-dns-优化吗？" class="headerlink" title="前端可以做 dns 优化吗？"></a>前端可以做 dns 优化吗？</h3>前端的dns优化，可以在html页面头部写入dns缓存地址，比如<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;x-dns-prefetch-control&quot;</span> content=<span class="string">&quot;on&quot;</span> /&gt;</span><br><span class="line">&lt;link rel=<span class="string">&quot;dns-prefetch&quot;</span> href=<span class="string">&quot;http://bdimg.share.baidu.com&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
查找到 IP 之后，就是 http 协议的三次握手（以及后面会涉及到四次挥手）<h2 id="三次握手，为啥两次不行，顺便说一下3次握手发生了什么"><a href="#三次握手，为啥两次不行，顺便说一下3次握手发生了什么" class="headerlink" title="三次握手，为啥两次不行，顺便说一下3次握手发生了什么"></a>三次握手，为啥两次不行，顺便说一下3次握手发生了什么</h2></li>
</ol>
<ul>
<li>第一次握手：主机 A 发送位码 为SYN＝1 的 TCP 包给服务器，并且随机产生一个作为确认号（这是 tcp 包的一部分），主机 B 收到 SYN 码后直到 A 要求建立连接;</li>
<li>第二次握手：主机 B 收到请求后，向 A 发送确认号（主机A的seq+1），syn=1，seq = 随机数 的 TCP 包；</li>
<li>主机 A 收到后检查确认号是否正确，即第一次 A 发送的确认号是否 +1 了，以及位码 ack 是否为 1，若正确，主机 A 会再发送确认号（主机 B 的 seq+1），ack=1，主机 B 收到后确认 seq 值与 ack=1 则连接建立成功。</li>
</ul>
<p>三次握手建立链接，就该请求 html 文件了，如果 html 文件在缓存里面浏览器直接返回，如果没有，就去后台取</p>
<h2 id="解释一下缓存"><a href="#解释一下缓存" class="headerlink" title="解释一下缓存"></a>解释一下缓存</h2><p>浏览器首次加载资源成功时，服务器返回 200，此时浏览器不仅将资源下载下来，而且把 response 的 header（里面的 date 属性非常重要，用来计算第二次相同资源时当前时间和 date 的时间差）一并缓存;<br>下一次加载资源时，首先要经过强缓存的处理，cache-control 的优先级最高，比如 cache-control：no-cache,就直接进入到协商缓存的步骤了，如果 cache-control：max-age=xxx,就会先比较当前时间和上一次返回 200时的时间差，如果没有超过 max-age，命中强缓存，不发请求直接从本地缓存读取该文件（这里需要注意，如果没有 cache-control，会取 expires 的值，来对比是否过期），过期的话会进入下一个阶段，协商缓存<br>协商缓存阶段，则向服务器发送 header 带有 If-None-Match 和 If-Modified-Since 的请求，服务器会比较 Etag，如果相同，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200;<br>协商缓存第二个重要的字段是，If-Modified-Since，如果客户端发送的 If-Modified-Since 的值跟服务器端获取的文件最近改动的时间，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200;</p>
<h3 id="什么是from-disk-cache和from-memory-cache吗，什么时候会触发？"><a href="#什么是from-disk-cache和from-memory-cache吗，什么时候会触发？" class="headerlink" title="什么是from disk cache和from memory cache吗，什么时候会触发？"></a>什么是from disk cache和from memory cache吗，什么时候会触发？</h3><p>强缓存会触发，这两种，具体什么行为不知道,大概内容如下：</p>
<ol>
<li>先查找内存，如果内存中存在，从内存中加载；</li>
<li>如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载；</li>
<li>如果硬盘中未查找到，那就进行网络请求；</li>
<li>加载到的资源缓存到硬盘和内存；<h4 id="什么是启发式缓存吗，在什么条件下触发？"><a href="#什么是启发式缓存吗，在什么条件下触发？" class="headerlink" title="什么是启发式缓存吗，在什么条件下触发？"></a>什么是启发式缓存吗，在什么条件下触发？</h4>如果响应中未显示 Expires，Cache-Control：max-age或Cache-Control：s-maxage，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算新鲜度寿命。通常会根据响应头中的2个时间字段 Date 减去 Last-Modified 值的 10% 作为缓存时间。<blockquote>
<p>Date 减去 Last-Modified 值的 10% 作为缓存时间。<br>Date：创建报文的日期时间, Last-Modified 服务器声明文档最后被修改时间 response_is_fresh =  max(0,（Date -  Last-Modified)) % 10</p>
</blockquote>
</li>
</ol>
<ul>
<li>返回 html 之后，会解析 html, cssom + domTree = html，然后布局和绘制</li>
<li>构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）</li>
<li>构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树</li>
<li>执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）</li>
<li>构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)</li>
<li>渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性</li>
<li>布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置</li>
<li>绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成</li>
</ul>
<h2 id="页面渲染层有什么优化手段？"><a href="#页面渲染层有什么优化手段？" class="headerlink" title="页面渲染层有什么优化手段？"></a>页面渲染层有什么优化手段？</h2><ul>
<li>HTML 文档结构层次尽量少</li>
<li>脚本尽量后放，放在前即可</li>
<li>少量首屏样式内联放在标签内</li>
<li>样式结构层次尽量简单</li>
<li>在脚本中尽量减少 DOM 操作，尽量缓存访问 DOM 的样式信息，避免过度触发回流</li>
<li>减少通过 JavaScript 代码修改元素样式，尽量使用修改 class 名方式操作样式或动画</li>
<li>动画尽量使用在绝对定位或固定定位的元素上</li>
<li>隐藏在屏幕外，或在页面滚动时，尽量停止动画</li>
<li>尽量缓存 DOM 查找，查找器尽量简洁</li>
<li>涉及多域名的网站，可以开启域名预解析；<h4 id="如何诊断页面渲染时各个性能指标？"><a href="#如何诊断页面渲染时各个性能指标？" class="headerlink" title="如何诊断页面渲染时各个性能指标？"></a>如何诊断页面渲染时各个性能指标？</h4>通过 chrome 浏览器的工具，比如看网络请求情况的 network，还有看页面渲染情况的 perfermance<br>zhuanlan.zhihu.com/p/105561186</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>用生成器函数和Promise改善异步流程</title>
    <url>/2020/08/11/%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0%E5%92%8CPromise%E6%94%B9%E5%96%84%E5%BC%82%E6%AD%A5%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在学习JavaScript异步相关的知识，在学到Generator（生成器函数）、Promise 和 async-awiat 等相关对异步优化的内容时遇到了一些一时没有理解的东西。本文仅作为学习过程中的笔记分享，第一次发文章，如果错误请不吝指出。</p>
<p>话不多说，进入正题，先写一下在 Generator 中要用到的函数，随便写几个就行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">val, duration</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(val);</span><br><span class="line">        &#125;, duration);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">duration</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;<span class="comment">//delay函数不resolve出任何东西，或者说resolve出undefined</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(url).then(<span class="built_in">JSON</span>.parse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是 <strong>Generator 函数主体</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">yield</span> getJSON(<span class="string">&#x27;data.json&#x27;</span>)<span class="comment">//(1)</span></span><br><span class="line">    <span class="keyword">yield</span> delay(<span class="number">1000</span>);<span class="comment">//(2)</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">yield</span> getValue(<span class="number">10</span>, <span class="number">3000</span>);<span class="comment">//(3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Generator 函数会在遇到 yield 时生成一个值并暂停执行，如果要继续执行，则要调用next()，yield 的运算结果是生成器 next() 里面的参数。</p>
<p>为了执行 Generator函数 f ，声明一个函数 g 作为函数 f 的调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> g = f();</span><br><span class="line"></span><br><span class="line">g.next().value.then(<span class="function"><span class="params">value</span> =&gt;</span>&#123;</span><br><span class="line">  g.next(value).value.then(<span class="function"><span class="params">value</span> =&gt;</span></span><br><span class="line">    g.next(value).value.then(<span class="function"><span class="params">value</span> =&gt;</span></span><br><span class="line">      g.next(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>分析一下对 g 调用 next() 的过程。</p>
<p>在声明完函数 g 之后。<strong>第一行</strong>的第一个 value 是 getJSON 解析好的的 promise（我们希望在 promise 在 resolve 以后恢复执行），然后通过 data 返回，但是我们也不确定什么时候能resolve，但是可以确定的是：resolve 之后恢复生成器的执行。</p>
<p><strong>第二行</strong>的第一个 value 是上一个 then 传入的 value（getJSON(‘data.json’) resolve 的结果），第二个 value 是 delay(1000) 的 promise 的 resolve。</p>
<p>接下来是<strong>第三行</strong>，很明显，next() 调用一次就恢复执行，然后暂停，再调一次就再恢复执行，这里是第三次调用，传入的 value（第二个 value）是第(2)行的返回结果，虽然 delay 并没啥返回（甚至左边没有变量接住）。这次调用将会返回第(3)行生成的 promise 对象，然后等getValue 函数 resolve 以后，再恢复执行。这时这里第三个 value 应该是10并返回给b。</p>
<p>最后一行，即<strong>第四行</strong> g.next(value); 这里的 value 为10。<br>&emsp;<br>&emsp;</p>
<h1 id="总结一下-f-函数的执行"><a href="#总结一下-f-函数的执行" class="headerlink" title="总结一下 f() 函数的执行"></a>总结一下 f() 函数的执行</h1><p>运行到<strong>第(1)行的 yield</strong> 时，在 yield 出 getJSON 的 promise 后，它执行停止了，直到 promise 的 resolve 后才恢复执行，并且恢复之后还将返回 promise 的 resolve 的值，也就是 data 将等于 data.json 解析出的内容。</p>
<p>然后函数运行到<strong>第(2)行</strong>，又 yield 出了 delay 的 promise，并再次等待 promise 的 resolve后才恢复执行（虽然这里的 delay 本身没求值结果所以也不 resolve 出啥），delay 在1秒后完成，所以第(2)行的 yield 也在1秒后恢复。</p>
<p>运行到<strong>第(3)行</strong>，又 yield 出一个promise，然后就停住了，在等待这个 promise 的 resolve 后才恢复，要恢复得调用 next()，而 next 的调用在 promise 的 resolve之后，即这时已经有resolve 的值了，把值传给 next() 即可，b 就等于这个 resolve 出的值。全程 next() 调用在那行的 promise 的 resolve之后，而且调用的时候把 promise 的 resovle 的值传给 next() 并成为yield 的返回值。</p>
<p>f() 这样跟同步的写法区别仅在于有没有 yield，虽然是异步的，但是写在了同一行里。(1)行的data 最终将等于 data.json 用 getJSON 请求到的真正的数据，而不是一个 promise 对象。虽然看起来像同步，但实际上代码在运行到这行的时候暂停了一定的时间，时间取决于 promise 的 resolve 的时间，在等待的这段时间，浏览器是完全空闲的。</p>
<p>在以上的举例分析中，我们只考虑了 promise 能正确 resolve 的情况，那么接下来再写一下出现错误的情况（拿 next() 调用 g 的第一行举例）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">g.next().value.then(<span class="function"><span class="params">value</span> =&gt;</span>&#123;</span><br><span class="line">    g.next(value);<span class="comment">//成功就通过yield返回</span></span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span>&#123;</span><br><span class="line">    g.throw(reason);<span class="comment">//失败就通过yield抛出</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>如果成功的就调用这个箭头函数（第一个 value 是 promise）,then 只是挂上了两个并没有立刻得到结果的函数就结束，然后执行下一句（console.log(1);）了，注意即使在then调用时promise 已经得出结果，下一句 console.log(1); 仍然先于then里的函数执行。因为这个函数是异步调用的，里面的内容必定在 then 所在的调用栈全部清空以后执行，</p>
<p>另外说一下，既然有错误，就应该加上 try-catch 语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">yield</span> getJSON(<span class="string">&#x27;data.json&#x27;</span>)</span><br><span class="line">&#125;<span class="function"><span class="title">catch</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//多了yield的好处：能看出代码哪里需要等待</span></span><br></pre></td></tr></table></figure>

<h1 id="最后总结和补充一下-Generator-和-async-await-对于异步优化的一些知识点"><a href="#最后总结和补充一下-Generator-和-async-await-对于异步优化的一些知识点" class="headerlink" title="最后总结和补充一下 Generator 和 async-await 对于异步优化的一些知识点"></a>最后总结和补充一下 Generator 和 async-await 对于异步优化的一些知识点</h1><p>Generator可以让执行处于暂停状态，Generator 返回的是一个 Iterator 对象。<br>必要构成：1 个星号和 yield 运算符。<br>next 属性返回一个对象，里面 value 是当前 yield 后面的值，done 表示当前生成器有没有运行完。yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。yield可以生成一个值，然后恢复的话（也可以不恢复，就不返回值）又可以返回一个值，两个值可以不一样。<br>yield: yield 的运算结果是生成器 next() 里面的参数。<br>async + 生成器函数 function {await ：promise 函数}。 async 函数就是将 Generator 函数的星号替换成 async，将 yield 替换成 await。<br>async 函数对 Generator 函数的改进，配合 promise 使用(后面接返回promise的函数？)，包装原理如上。并且 function() 返回一个 promise。<strong>async-await 本质是生成器函数和yield。</strong></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的React父子组件和平级组件之间传值</title>
    <url>/2020/10/30/%E7%AE%80%E5%8D%95%E7%9A%84React%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%92%8C%E5%B9%B3%E7%BA%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.父组件对子组件传值 利用props属性传值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;I am &#123;<span class="built_in">this</span>.props.name&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Component name=<span class="string">&#x27;cat&#x27;</span>&gt;&lt;/Component&gt;</span><br><span class="line">    &lt;h1&gt;hello world!!!&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2.子组件对父组件传值 简单来说就是利用回调来完成，比如下面例子，子组件来改变父组件的颜色</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理父子组件间传值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.props.colorChange(<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;父组件的值  &#123;<span class="built_in">this</span>.props.bgColor&#125;&lt;/h1&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.handleClick(e)&#125;&gt;改变父组件颜色&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.state=&#123;</span><br><span class="line">        bgColor: <span class="string">&#x27;#999&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">onBgColorChange</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        bgColor: color</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123;<span class="attr">background</span>:<span class="built_in">this</span>.state.bgColor&#125;&#125;&gt;</span><br><span class="line">          &lt;Child bgColor=&#123;<span class="built_in">this</span>.state.bgColor&#125; colorChange=&#123;<span class="function">(<span class="params">color</span>)=&gt;</span>&#123;<span class="built_in">this</span>.onBgColorChange(color)&#125;&#125;&gt;&lt;/Child&gt;</span><br><span class="line">          &#123;<span class="comment">/* 子组件像父组件传值，设置回调 */</span>&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Father&gt;&lt;/Father&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>3.同一父组件下平级组件间传值 ，简单一句话 子组件先传给父组件，父组件再传给那个子组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理平级组件间传值 ，先传给父组件，父组件再传给另一个组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.props.changeChild2Color(<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;Child1：  &#123;<span class="built_in">this</span>.props.bgColor&#125;&lt;/h1&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.handleClick(e)&#125;&gt;向Child2传值，改变其颜色&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123;<span class="attr">background</span>:<span class="built_in">this</span>.props.bgColor&#125;&#125;&gt;</span><br><span class="line">            &lt;h1&gt;Child2：  &#123;<span class="built_in">this</span>.props.bgColor&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.state=&#123;</span><br><span class="line">        child2BgColor: <span class="string">&#x27;#999&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">onChild2BgColorChange</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        child2BgColor: color</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123;<span class="comment">/* 平级组件间传值*/</span>&#125;</span><br><span class="line">          &lt;Child1 changeChild2Color=&#123;<span class="function">(<span class="params">color</span>)=&gt;</span>&#123;<span class="built_in">this</span>.onChild2BgColorChange(color)&#125;&#125;&gt;&lt;/Child1&gt;</span><br><span class="line">          &lt;Child2 bgColor=&#123;<span class="built_in">this</span>.state.child2BgColor&#125;&gt;&lt;/Child2&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Father&gt;&lt;/Father&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>组件库的制作</title>
    <url>/2020/11/02/%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>提示，这里需要先学习一下Vue插件的API： <a href="https://cn.vuejs.org/v2/api/#Vue-use">https://cn.vuejs.org/v2/api/#Vue-use</a></p>
<p>在package.json中加一条命令，用于指定打包目标为库</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">       <span class="attr">&quot;lib&quot;</span>: <span class="string">&quot;vue-cli-service build --target lib packages/index.js&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在命令行输入 yarn lib<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEJTGN48rsMPNqepV548w.aV9yCjuYp5H*nXXXoZKA9OQcAEwBbHw6gozXNJsP3Bj03vyMNg8plvqrq.EVb1XGEc!/r" alt="image text"><br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEBfbeH.4zaLcWgHcrz4RpoL**GaE7I*bgaozV6IH8I7TX5KTg2xhcBQBejx.mi6v9OxZUOMOZFd*n4vUDp37*OU!/r" alt="image text"><br>打包完成，可以看到多了个dist文件夹，里面将我们的组件打包成了一个js文件，字体图标也打包好了，以后使用的话只要用dist文件夹就行了</p>
<p>接下来让我们整个项目用 pc-hub 管理一下，把打包好的dist放到npm上，提醒一下在index里要有install，不然不能作为Vue的插件也不能全局使用</p>
<p>接下来将my-ui上传到github上，这个不写了，主要是如何将组件库发布到npm上，需要做一点修改，首先将package.json中的 “private”: false 其次name属性要是npm上没有的包名，main属性设置为dist文件夹中以.umd.min.js结尾的文件路径，其他随意，以我的为例是:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;syhmy-ui&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;private&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;dist/my-ui.umd.in.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;auther&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ShiYuhao&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在打包文件夹中在新建一个.npmignore，跟.gitignore功能相似，只要用到dist即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 忽略目录</span><br><span class="line">examples&#x2F;</span><br><span class="line">packages&#x2F;</span><br><span class="line">public&#x2F;</span><br><span class="line"></span><br><span class="line"># 忽略指定文件</span><br><span class="line">vue.config.js</span><br><span class="line">babel.config.js</span><br><span class="line">*.map</span><br></pre></td></tr></table></figure>
<p>把打包好的文件上传到npm，如果装了nrm的，需要保证当前的源是npm的源，因为有些人会把源改到taobao去，得改回来，不然就不是上传到了npm。然后需要一个npm账号，没有的话注册一个<br>如图所示登陆成功，输入命令<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEIHVCb.TebOllO6KzbuUBEKtjz4kTeREg1qthzeU0dR*cDGXDRk6ylVBRHl08.vFxjb9CwI80fKBSRweAzxkA4w!/r" alt="image text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm public</span><br></pre></td></tr></table></figure>
<p>即可把包发布到npm上<br><img src="http://r.photo.store.qq.com/psc?/V51JZupb2WYeuQ2XPnHW1mg57E33YJo6/TmEUgtj9EK6.7V8ajmQrEP3bE1FZLFxGVG9C3cEWxQR.l1zzRnagmp5o28cq3mrPcbRNeupht4LVLQeHc956LAO7NErrXtuKfj21X0TF.IA!/r" alt="image text"><br>以后要更新你发布的npm包的话，要在package.json中修改版本号<br>如图，npm包可以正常下载，当成插件全局注册好后就可以使用了</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>认识闭包</title>
    <url>/2020/04/04/%E8%AE%A4%E8%AF%86%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>满足以下特点的叫做闭包<br>    1、函数嵌套函数<br>    2、内部函数使用外部函数的形参和变量<br>    3、被引用的形参和变量不会被垃圾回收机制所回收</p>
<p>好处：<br>    1、希望一个变量常驻在内存当中<br>    2、避免全局变量污染 避免声明全局变量，比如在函数外声明<br>    3、可以声明私有成员</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">num1</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">var</span> num2 = <span class="number">10</span>;</span><br><span class="line">           <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="keyword">return</span>(num1 + <span class="string">&quot; &quot;</span> + num2);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> b;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">var</span> res = a(<span class="number">20</span>);</span><br><span class="line">       <span class="built_in">console</span>.log(res());</span><br></pre></td></tr></table></figure>
<p>就是一个闭包</p>
<p>可以实现：1、避免全局污染，2、对a进行累加<br>【注】让a变量常驻内存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cc = aa();</span><br><span class="line">    cc();</span><br><span class="line">    cc();</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure>
<p>写成立即执行函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">cc();</span><br><span class="line">cc();</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure>
<p>闭包的一个应用：私有变量<br>例子：A，B两同学共同开发代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleA = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">10</span>;<span class="comment">//私有变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;<span class="comment">//私有方法</span></span><br><span class="line">        count += <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        count *= <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        funcA: aaa,</span><br><span class="line">        funcB: bbb</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> moduleA = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        count += <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        count *= <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        funcA: aaa,</span><br><span class="line">        funcB: bbb</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">moduleA.funcA();</span><br><span class="line">moduleA.funcB();</span><br><span class="line"></span><br><span class="line">moduleB.funcA();</span><br><span class="line">moduleB.funcB();</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记</title>
    <url>/2019/12/26/%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTML-CSS问题"><a href="#HTML-CSS问题" class="headerlink" title="HTML + CSS问题"></a>HTML + CSS问题</h2><h3 id="Position取值和含义？"><a href="#Position取值和含义？" class="headerlink" title="Position取值和含义？"></a>Position取值和含义？</h3><ol>
<li>static：静态定位，是默认值，表⽰⽆论怎么设置 top、bottom、right、left 都不会发⽣改变。</li>
<li>relative：相对定位，表⽰⽤ top、bottom、right、left 属性可以设置元素相对与其相对于初始位置的相对位置。</li>
<li>absolute：绝对定位，表⽰⽤ top、bottom、right、left 属性可以设置元素相对于其⽗元素（除了设置了static 的⽗元素以外）左上⾓的位置，如果⽗元素设置了static，⼦元素会继续追溯到祖辈元素⼀直到body。</li>
<li>fixed：固定定位，相对于浏览器窗⼝进⾏定位，同样使⽤ top、bottom、right、left。<br>四种取值中，除了 static 之外，其他属性都可通过 z-index 进⾏层次分级</li>
<li>sticky：粘性定位</li>
</ol>
<h3 id="如何清除浮动？"><a href="#如何清除浮动？" class="headerlink" title="如何清除浮动？"></a>如何清除浮动？</h3><p>clear 清除浮动（添加空div法）在浮动元素下方添加空 div，并给该元素写 CSS 样式 {clear:both; height:0; overflow:hidden;}<br>给浮动元素父级设置高度<br>父级同时浮动（需要给父级同级元素添加浮动）<br>父级设置成 inline-block<br>给父级添加 overflow: hidden<br>万能清除法 after 伪类 清浮动（现在主流方法，推荐使用）</p>
<h3 id="什么是BFC？"><a href="#什么是BFC？" class="headerlink" title="什么是BFC？"></a>什么是BFC？</h3><p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素。<br>在常规流和 float 里面有效，不能包着脱离常规流的定位元素。<br>BFC 触发条件<br>根元素<br>position: absolute/fixed<br>display: inline-block / table<br>浮动元素<br>ovevflow 不为 visible<br>应用：<br>子元素浮动父元素高度塌陷，可以把父元素设置成 BFC<br>元素浮动后发生重叠，把其中一个设置成 BFC</p>
<h3 id="行内元素和块元素有哪些，本质区别"><a href="#行内元素和块元素有哪些，本质区别" class="headerlink" title="行内元素和块元素有哪些，本质区别"></a>行内元素和块元素有哪些，本质区别</h3><p>行内元素：span、img、button、input、b、q、i、a、em、label<br>块元素：div、p、h1-h6、ul、ol、dl、li、header、footer、aside、section、article、form、table</p>
<p>区别：行内元素设置 width，height 属性无效，起边距作用的只 有 margin-left、margin-right、padding-left、padding-right，其它属性不会起边距效果（可以设置 line-height），设置 margin 和 padding 的上下不会对其他元素产生影响。块级元素可以设置 width，height 属性</p>
<h3 id="水平、垂直居中"><a href="#水平、垂直居中" class="headerlink" title="水平、垂直居中"></a>水平、垂直居中</h3><p>水平：行内元素：父元素 text-align: center<br>块元素：宽度已知用 margin: auto，宽度未知：用 display: inline 变成行内元素后在父元素上设置 text-align: center<br>父元素 position: relative，子元素 position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%)<br>垂直：display: flex; align-item: center</p>
<blockquote>
<p>grid 和 flex 布局对行内、块级元素都适用</p>
</blockquote>
<h3 id="实现两栏布局"><a href="#实现两栏布局" class="headerlink" title="实现两栏布局"></a>实现两栏布局</h3><ul>
<li>左浮动定宽，右自适应</li>
<li>调整 margin-left</li>
<li>左浮动，右绝对定位</li>
</ul>
<h3 id="实现三栏布局"><a href="#实现三栏布局" class="headerlink" title="实现三栏布局"></a>实现三栏布局</h3><ul>
<li>左右浮动（浮动元素脱离文档流）</li>
<li>左右绝对定位（绝对定位元素脱离文档流）</li>
<li>父元素设置 flex 布局，中间 order:1, flex-grow:1，右 order:2</li>
<li>圣杯布局和双飞翼布局</li>
</ul>
<h3 id="flex、table和grid"><a href="#flex、table和grid" class="headerlink" title="flex、table和grid"></a>flex、table和grid</h3><p>Flex 意为弹性布局，任何一个容器都可以指定为 Flex 布局。行内元素也可以使用 Flex 布局。<br>flex-direction属性 该属性定义了子元素的排列方向</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex-wrap属性 该属性称“轴线”的围绕方向</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex-flow 属性： flex-direction 和 flex-wrap 的简写，默认值为 row nowrap<br>justify-content 属性 该属性定义了子元素内容在主轴上的对齐方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>align-items 属性 该属性定义了项目在交叉轴上如何对齐</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>align-content 属性，该属性定义了多跟轴线的对齐方式，如果项目只有一根轴线，该属性不起作用</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。<br>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。<br><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></p>
<p>一般只有用到需要表格展示的数据才用 table，而且 table 布局代码量较大，页面可读性差</p>
<h3 id="CSS让元素不可见的方法"><a href="#CSS让元素不可见的方法" class="headerlink" title="CSS让元素不可见的方法"></a>CSS让元素不可见的方法</h3><p>display: none | z-index: -9999（只能在定位元素上生效） | opacity:0 | position: absolute; left: -9999; top: -9999</p>
<h3 id="如何设计移动端页面和响应式界面"><a href="#如何设计移动端页面和响应式界面" class="headerlink" title="如何设计移动端页面和响应式界面"></a>如何设计移动端页面和响应式界面</h3><h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><p>!important - 内联 - id - 类 - 标签 - 通配符 - 继承</p>
<h3 id="px、em、rem、-、vw、vh、vm这些单位的区别"><a href="#px、em、rem、-、vw、vh、vm这些单位的区别" class="headerlink" title="px、em、rem、%、vw、vh、vm这些单位的区别"></a>px、em、rem、%、vw、vh、vm这些单位的区别</h3><p>em：参考的是父元素的 font-size，具有继承的特点，如果自身定义了 font-size 则按自身来计算（浏览器默认字体是16px），整个页面内 1em 不是一个固定的值<br>rem：相对于根元素 html，可以设置根元素 html 的 font-size 为 10px，则 1.2em 就是12px；<br>vw：css3 新单位，view width 的缩写，是指可视窗口的宽高，假如宽度是1200px，则10vw就是120px；举个例子：浏览器宽度1200px， 1 vw = 1200px/100 = 12 px。<br>Vh：类似vw，指的是可视窗口的高度。<br>Vm：相对于视口的宽度或高度中较小的那个，其中最小的单位被均分为100个单位，举个例子：浏览器高度 900px，宽度 1200px，取最小的浏览器高度，1vm = 900px/100 = 9 px</p>
<h3 id="说一下对HTML语义化的理解"><a href="#说一下对HTML语义化的理解" class="headerlink" title="说一下对HTML语义化的理解"></a>说一下对HTML语义化的理解</h3><p>语义化就是选择与语义相符合的标签，使代码语义化，这样不仅便于开发者进行阅读，同时也能维护和写出更优雅的代码，还能够让搜索引擎和浏览器等工具更好地解析。<br>通俗的讲语义化就是让正确的标签做正确的事情，比如段落用 p 标签，头部用 header 标签，主要内容用 main 标签，侧边栏用 aside 标签等等。</p>
<h3 id="meta-viewport是做什么用的"><a href="#meta-viewport是做什么用的" class="headerlink" title="meta viewport是做什么用的"></a>meta viewport是做什么用的</h3><p>将视口大小设置为可视区域的大小。</p>
<h3 id="两种盒模型"><a href="#两种盒模型" class="headerlink" title="两种盒模型"></a>两种盒模型</h3><p>content-box 和 border-box 的区别：计算最大尺寸时是否包含边距，border-box 最大尺寸是包含了边距的（width:100， content(80) + border(10) = 100），content-box 最大尺寸是不包含边距（width: 100， content(100) + border(10) = 120）</p>
<h3 id="响应式布局实现原理和方案"><a href="#响应式布局实现原理和方案" class="headerlink" title="响应式布局实现原理和方案"></a>响应式布局实现原理和方案</h3><p>原理：响应式开发一套界面，通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容<br>方案<br>媒体查询：@media 可以针对不同的屏幕尺寸设置不同的样式，当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。<br>百分比布局：通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果。Bootstrap 里面的栅格系统就是利用百分比来定义元素的宽高，CSS3 支持最大最小高，可以将百分比和 max(min) 一起结合使用来定义元素在不同设备下的宽高。<br>rem 布局：rem 是 CSS3 新增的单位，rem 单位都是相对于根元素 html 的 font-size 来决定大小的。当页面的 size 发生变化时，只需要改变 font-size 的值，那么以 rem 为固定单位的元素的大小也会发生响应的变化（而 em 是相对于父元素的）。</p>
<h3 id="DOM和BOM是什么"><a href="#DOM和BOM是什么" class="headerlink" title="DOM和BOM是什么"></a>DOM和BOM是什么</h3><p>BOM 是浏览器对象模型，用来获取或设置浏览器的属性、行为，例如:新建窗口、获取屏幕分辨率、浏览器版本号等。<br>DOM 是文档对象模型，用来获取或设置文档中标签的属性，例如获取或者设置 input 表单的 value 值。</p>
<h3 id="CSS加载会造成阻塞吗"><a href="#CSS加载会造成阻塞吗" class="headerlink" title="CSS加载会造成阻塞吗"></a>CSS加载会造成阻塞吗</h3><ol>
<li>css 加载不会阻塞 DOM 树的解析。</li>
<li>css 加载会阻塞 DOM 树的渲染。</li>
<li>css 加载会阻塞后面 js 语句的执行。</li>
</ol>
<h3 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h3><p>都是不存在于 DOM 文档中的虚拟元素，虽然逻辑上存在，但并不实际存在于 DOM 树中。<br>伪类的效果可以通过添加实际的类来实现。<br>伪元素的效果可以通过添加实际的元素来实现。<br>所以它们的本质区别就是是否抽象创造了新元素。<br>伪类只能使用 “:”，伪元素可以使用 “:” 也可以使用 “::”。</p>
<h3 id="如何设计实现无缝轮播"><a href="#如何设计实现无缝轮播" class="headerlink" title="如何设计实现无缝轮播"></a>如何设计实现无缝轮播</h3><p>轮播图基本都是 ul 盒子里面的 li 元素，首先获取第一个 li 元素和最后一个 li 元素，<br>克隆第一个 li 元素，和最后一个 li 元素，分别插入到 last li 的后面和 first li 的前面，<br>然后监听滚动事件,如果滑动距离超过 x 或 -x，让其实现跳转下一张图或者跳转上一张，(此处最好设置滑动距离)，<br>然后在滑动最后一张实现最后一张和克隆第一张的无缝转换，当到克隆的第一张的时候停下的时候，让其切入真的第一张，则实现无线滑动。向前滑动同理。</p>
<h3 id="如何实现换肤功能？"><a href="#如何实现换肤功能？" class="headerlink" title="如何实现换肤功能？"></a>如何实现换肤功能？</h3><p><a href="https://juejin.cn/post/6844904122643120141">https://juejin.cn/post/6844904122643120141</a></p>
<h3 id="CSS选择器有哪些"><a href="#CSS选择器有哪些" class="headerlink" title="CSS选择器有哪些"></a>CSS选择器有哪些</h3><p><a href="https://segmentfault.com/a/1190000013424772">https://segmentfault.com/a/1190000013424772</a></p>
<h3 id="圣杯和双飞翼布局"><a href="#圣杯和双飞翼布局" class="headerlink" title="圣杯和双飞翼布局"></a>圣杯和双飞翼布局</h3><p>左右两栏固定宽度，中间部分自适应的三栏布局。<br><a href="https://juejin.cn/post/6844903817104850952">https://juejin.cn/post/6844903817104850952</a></p>
<h3 id="什么是浮动元素"><a href="#什么是浮动元素" class="headerlink" title="什么是浮动元素"></a>什么是浮动元素</h3><p>什么是浮动元素：浮动元素同时处于常规流内和流外的元素。其中块级元素认为浮动元素不存在，而浮动元素会影响行内元素的布局，浮动元素会通过影响行内元素间接影响了包含块的布局。</p>
<p>常规流：页面上从左往右，从上往下排列的元素流，就是常规流。<br>脱离常规流：绝对定位，fixed 定位的元素有自己固定的位置，脱离了常规流。<br>包含块：一个元素离它最近的块级元素是它的包含块。</p>
<h3 id="如何减少回流与重绘"><a href="#如何减少回流与重绘" class="headerlink" title="如何减少回流与重绘"></a>如何减少回流与重绘</h3><ul>
<li>应该尽量以局部布局的形式组织 html 结构，尽可能小的影响回流的范围。如果要改变内层元素的样式，就不要把样式写在外层标签上。</li>
<li>样式集中改变；</li>
<li>分离 DOM 的读写操作；</li>
<li>先设置 display: none，做完较多的更改后再改回来；</li>
<li>减少不必要的 DOM 深度和 CSS 规则数量；</li>
</ul>
<h3 id="CSS命名冲突怎么办？"><a href="#CSS命名冲突怎么办？" class="headerlink" title="CSS命名冲突怎么办？"></a>CSS命名冲突怎么办？</h3><p><a href="https://blog.csdn.net/qq_43569680/article/details/123750956">https://blog.csdn.net/qq_43569680/article/details/123750956</a></p>
<h3 id="什么是CSS变量？"><a href="#什么是CSS变量？" class="headerlink" title="什么是CSS变量？"></a>什么是CSS变量？</h3><p>CSS 变量可以访问 DOM，创建局部或全局变量，使用 JS 和媒体查询来修改变量。全局变量可以在整个文档进行访问使用，局部变量只能在声明它的选择器内部使用。</p>
<h2 id="JavaScript问题"><a href="#JavaScript问题" class="headerlink" title="JavaScript问题"></a>JavaScript问题</h2><h3 id="JS基本数据类型和引用数据类型，解释一下引用数据类型"><a href="#JS基本数据类型和引用数据类型，解释一下引用数据类型" class="headerlink" title="JS基本数据类型和引用数据类型，解释一下引用数据类型"></a>JS基本数据类型和引用数据类型，解释一下引用数据类型</h3><p>基本：null、undefined、boolean、number、string、symbol。<br>引用：Obect、Array、Function、Data。<br>基本数据类型指的是简单的数据段，是按值访问的，因为可以直接操作保存在变量中的实际值。引用数据类型指的是有多个值构成的对象，改变引用数据类型是操作对象在栈内存中的引用地址。<br>引用数据类型的值可以改变、可以添加属性和方法、赋值是对象引用。<br>null 是空对象引用（空指针），undefined 没有赋值的对象（未初始化的变量），值相等但类型不同。</p>
<h3 id="为什么Javascript中的基本类型能调用方法？"><a href="#为什么Javascript中的基本类型能调用方法？" class="headerlink" title="为什么Javascript中的基本类型能调用方法？"></a>为什么Javascript中的基本类型能调用方法？</h3><p>String、Number 和 Boolean 为了方便我们操作，有对应的基本包装类型。<br><a href="http://t.zoukankan.com/lessfish-p-4836101.html">http://t.zoukankan.com/lessfish-p-4836101.html</a></p>
<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p>对象中都有两个默认的属性，叫__proto__和 constructor， 指向当前对象的原型、当前对象的构造函数<br>函数独有一个 prototype 属性指向它的原型，因为函数也是一种对象，所以函数也拥有__proto__和 constructor 属性。（原型是 Function 的对象：Object, Number, Boolean, String, Array, RegExp, Date, Function, Error）。</p>
<p>__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（原型）里找，一直找，直到__proto__属性的终点 null，再往上找就相当于在 null 上取值，会报错。通过__proto__属性将对象连接起来的这条链路即原型链。</p>
<p>所有的对象都有原型吗？</p>
<blockquote>
<p>Object.create(null) 创建的对象没有原型。</p>
</blockquote>
<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>全局作用域、函数作用域、块级作用域（存在 let 或 const 的作用域）<br>当需要使用函数或者变量时，如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这样一个查找过程形成的链条就叫做作用域链。<br>反过来一般情况下外层不能访问内层作用域的变量，会报错 xxx is not defined。</p>
<h3 id="JS的传参、深拷贝浅拷贝"><a href="#JS的传参、深拷贝浅拷贝" class="headerlink" title="JS的传参、深拷贝浅拷贝"></a>JS的传参、深拷贝浅拷贝</h3><p>简单点说，对象是引用传递，基础类型是值传递，通过将基础类型包装可以以引用方式传递<br>按值传递(call by value)是最常用的求值策略：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。（类似深拷贝对象）通过自定义函数实现深拷贝（递归遍历对象）</p>
<ol>
<li>for in 遍历对象中所有属性，取出对应值</li>
<li>通过 sourceValue.constructor 拿到这个对象的构造函数的类型，新建对象或数组</li>
<li>取值如果是引用数据类型，将遍历到的属性值复制给新建的空对象或数组，否则直接复制之前属性<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过遍历拿到 source 中的所有属性，取出当前遍历到的属性对应的值，判断当前的取值是否是引用数据类型（对象、数组、函数，一般是对象嵌套），通过 sourceValue.constructor 拿到这个对象的构造函数的类型，然后新建这个对象或数组，再次调用深拷贝，将遍历到的属性的值拷贝给新建的对象或数组，如果不是引用数据类型，之前的属性拷贝即可</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deCopy</span>(<span class="params">target， source</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> key <span class="keyword">in</span> source</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> sourceValue = souce[key];</span><br><span class="line">      <span class="function"><span class="title">if</span>(<span class="params">sourceValue <span class="keyword">instanceof</span> <span class="built_in">Object</span></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> subTarget = <span class="keyword">new</span> sourceValue.constructor;</span><br><span class="line">          deCopy(subTarget， sourceValue);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          target[key] = sourceValue</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果是原始类型，无需继续拷贝，直接返回<br>如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行深拷贝后依次添加到新对象上。<br>很容易理解，如果有更深层次的对象可以继续递归直到属性为原始类型。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deCopy</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> deCopyTarget = &#123;&#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">          deCopyTarget[key] = decopy(target[key]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> deCopyTarget;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
按引用传递(call by reference)时，函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。（类似浅拷贝对象）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cloneTarget = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">        cloneTarget[key] = target[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
按引用传递会使函数调用的追踪更加困难，有时也会引起一些微妙的 BUG。按值传递由于每次都需要克隆副本，对一些复杂类型，性能较低。两种传值方式都有各自的问题。可能很多人都是做后端的，所有会想到“引用传递”，然而实际上却不是，导致了问题的产生。</li>
</ol>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>协议、域名、端口三者有一个不同就会引起跨域的错误问题<br>严格的说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。浏览器的同源限制策略是这样执行的：<br>通常浏览器允许进行跨域写操作（Cross-origin writes），如链接，重定向；<br>通常浏览器允许跨域资源嵌入（Cross-origin embedding），如 img、script 标签；<br>通常浏览器不允许跨域读操作（Cross-origin reads）。<br>解决：JSONP：通过创建 script 标签，其 src 指向非同源的 url，并传递一个 callback 参数作为函数名的函数的调用和一系列参数，页面接收到响应后执行回调并对数据进行处理。CORS：服务端在 http header 设置 Access-Control-Allow-Origin 即可<br>Nginx 反向代理 <a href="https://blog.csdn.net/weixin_46872121/article/details/111700983">https://blog.csdn.net/weixin_46872121/article/details/111700983</a><br>个人经验：<br>webpack 本来就是开发者模式，vue.config.js 配一下 devServer 的 proxy，原理是利用 http-proxy-middleware 这个http 代理中间件，在本地起一个 node 服务，实现请求转发给其他的服务器<br>当你有一个单独的 API 后端开发服务器，并且想要在同一个域上发送 API 请求时，则代理这些 url。看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  <span class="string">&#x27;/proxy&#x27;</span>: &#123;</span><br><span class="line">    <span class="comment">// 目标代理服务器地址</span></span><br><span class="line">      target: <span class="string">&#x27;http://your_api_server.com&#x27;</span>,</span><br><span class="line">      <span class="comment">// 允许跨域</span></span><br><span class="line">      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">          <span class="string">&#x27;^/proxy&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设你主机名为 localhost:8080, 请求 API 的 url 是 http：//your_api_server.com/user/list<br>‘/proxy’：如果点击某个按钮，触发请求 API 事件，这时请求 url 是http：//localhost:8080/proxy/user/list<br>changeOrigin：如果 true ，那么 http：//localhost:8080/proxy/user/list 变为 http：//your_api_server.com/proxy/user/list。但还不是我们要的 url 。<br>pathRewrite：重写路径。匹配 /proxy ，然后变为’’ ，那么 url 最终为 http：//your_api_server.com/user/list。<br><a href="https://www.cnblogs.com/zhilili/p/14738262.html">https://www.cnblogs.com/zhilili/p/14738262.html</a></p>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>方法一：倒进集合再倒出来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>([<span class="number">1</span>， <span class="number">2</span>， <span class="number">2</span>， <span class="number">3</span>， <span class="number">4</span>， <span class="number">5</span>， <span class="number">5</span>])]</span><br><span class="line"><span class="comment">//[1， 2， 3， 4， 5]</span></span><br></pre></td></tr></table></figure>
<p>方法二：indexOf()<br>方法三：双重循环（先排序然后用 splice ）</p>
<h3 id="ES6的symol-是什么，适用场景有什么"><a href="#ES6的symol-是什么，适用场景有什么" class="headerlink" title="ES6的symol 是什么，适用场景有什么"></a>ES6的symol 是什么，适用场景有什么</h3><p>一种特殊的数据类型，定义不可更改，适合用来作为属性名标识独一无二的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个symbol类型的值</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s);<span class="comment">//&quot;symbol&quot;</span></span><br></pre></td></tr></table></figure>
<p>用作对象属性、模拟类的私有方法</p>
<h3 id="generator和async-await，如何捕获异常"><a href="#generator和async-await，如何捕获异常" class="headerlink" title="generator和async/await，如何捕获异常"></a>generator和async/await，如何捕获异常</h3><p>generator 函数返回一个遍历器对象<br>遍历器对象 每次调用 next 方法返回有 value 和 done 两个属性的对象<br>generator 函数 yield 后面的表达式即为 返回对象 value 属性的值<br>遍历器对象每执行一次 next() 都只执行了 generator 函数内部部分代码，遇到 yield 本次执行就结束了。</p>
<p>写法跟 generator 很像，就是将星号替换成 async，将 yield 替换成 await。async 是加在函数前的修饰符，无论 async 函数有无 await 操作，其总是返回一个 Promise。所以 async 函数可以直接接 then，返回值就是 then 方法传入的参数。如果 await 等到的不是一个 promise 对象，那跟着的表达式的运算结果就是它等到的东西。</p>
<ul>
<li>没有显式 return，相当于 return Promise.resolve(undefined);</li>
<li>return 非 Promise 的数据 data，相当于 return Promise.resolve(data);</li>
<li>return Promise, 会得到 Promise 对象本身<br>使用场景：需要 promise 链式调用的时候，每个步骤都是异步的，且依赖上一步的执行结果<br>try{} catch{} finally<br>try 语句：里面是填写 js 代码，里面可以接 throw 语句，抛出自己填写的报错信息（一般抛出 throw new Error(“”))，并且 try 里面的执行语句终止，catch 的变量 e 会接收这个错误；throw 会在离自己最近的 try 语句中生效.<br>catch: 如果 try 语句里面有错误，catch 会返回错误的具体信息；需要一个变量 e 来接收错误，e 只在自己的 catch 语句中生效。<br>变量 e 有几个属性，e.stack：调用栈信息；e.message：具体的错误原因；e.name：错误类型函数<br>finally：里面的代码永远可以运行，不管前面有没有错误。<blockquote>
<p>async/await 是 generator 的语法糖，就是将 Generator 函数和自动执行器，包装在一个函数里。awiat 相当于 Pormise.then()。try…catch 相当于替代了 Promise 的 catch</p>
</blockquote>
</li>
</ul>
<h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><p>防抖是事件触发 n 秒后执行回调，如果在这 n 秒内又被触发，则重新计时。<br>使用场景：<br>提交按钮时防止多次提交，只执行最后一次提交。<br>搜索框搜索输入。只需用户最后一次输入完，再发送请求。<br>手机号、邮箱验证输入检测。<br>窗口大小 resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。<br>实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">f,time</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeId = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...argments</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeId)</span><br><span class="line">      <span class="keyword">var</span> timeId = <span class="built_in">setTimeout</span>(f(argments),time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>节流是 n 秒内只能触发一次函数，如果 n 秒内多次触发，只有一次生效。<br>使用场景：<br>拖拽在固定时间内只执行一次，防止超高频率触发位置变动；缩放时监控浏览器 resize。<br>滚动加载，加载更多或滚到底部监听。<br>搜索框，搜索联想功能<br>实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">f, duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timerId</span><br><span class="line">  <span class="keyword">var</span> lastRunTime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timerId)</span><br><span class="line">    <span class="keyword">var</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">if</span> (now - lastRunTime &gt; duration) &#123;</span><br><span class="line">      f(...args)</span><br><span class="line">      lastRunTime = now</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timerId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        f(...args)</span><br><span class="line">        lastRunTime = <span class="built_in">Date</span>.now()</span><br><span class="line">      &#125;, duration)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类数组转换为数组的方法"><a href="#类数组转换为数组的方法" class="headerlink" title="类数组转换为数组的方法"></a>类数组转换为数组的方法</h4><p>使用 Array.from()<br>使用 Array.prototype.slice.call()<br>使用 Array.prototype.forEach() 进行遍历并生成新的数组<br>转换后数组的长度由 length 属性决定。索引不连续时转换结果是连续的，会自动补位</p>
<h4 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h4><p>const 和 let<br>模板字符串<br>箭头函数<br>对象和数组解构<br>async/await<br>对象超类：ES6 允许在对象中使用 super 方法<br>for…of 和 for…in，for…of 用于遍历一个迭代器，如数组，for…in 用来遍历对象中的属性<br>ES6 中的类：ES6 中支持 class 语法，不过，ES6 的 class 不是新的对象继承模型，它只是原型链的语法糖表现形式。<br>函数的参数默认值<br>Spread / Rest 操作符<br>二进制和八进制字面量（这是啥</p>
<h4 id="语句和表达式的区别"><a href="#语句和表达式的区别" class="headerlink" title="语句和表达式的区别"></a>语句和表达式的区别</h4><p>语句和表达式的区别在于，语句是为了进行某种操作，一般情况下不需要返回值，而表达式都是为了得到返回值，一定会返回一个值（这里的值不包括undefined）。<br>例如：var a = 1 + 2 是语句<br>1 + 2 是表达式</p>
<h4 id="前端模块化和组件化"><a href="#前端模块化和组件化" class="headerlink" title="前端模块化和组件化"></a>前端模块化和组件化</h4><p>我们把每一个 .js 文件都视为一个 块，模块内部有自己的作用域，不会影响到全局。并且，我们约定一些关键词来进行依赖声明和 API 暴露。而这些约定的关键词就是通过制定一些规范去进行规范的。比较有名模块化规范的是 CMD、AMD、CommonJS 和 ES6 Module。Webpack 是模块化工具</p>
<p>将模板、样式和逻辑都抽象出来独立出来的做法称之为组件化。比如说，我们在开发 Button 组件的时候，不再需要分别在几个文件夹之间跳来跳去，去修改它们的模板、样式和逻辑。我们只需要在公共的 Button 组件的文件夹里修改就好了。Vue 和 React 也是组件化的框架<br><a href="https://segmentfault.com/a/1190000017466120">https://segmentfault.com/a/1190000017466120</a></p>
<h4 id="为什么对象在JavaScript中不可迭代"><a href="#为什么对象在JavaScript中不可迭代" class="headerlink" title="为什么对象在JavaScript中不可迭代"></a>为什么对象在JavaScript中不可迭代</h4><p>直接原因：ES6 中的 Object.prototype 没有实现 Symbol.iterator 属性。<br>对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。<br>部署了遍历器接口的对象其实就是 ES6 里的 Map 结构，现在 ES6 中内置了数据结构 Map，所以很方便地实现了集合对象。<br>Map 和 Object 比较<br>Map 是干净的，只含有显示插入的键，而 Object上会有原型上的属性以及方法，ES5 之后可以说使用 Object.create(null)来创建一个干净的对象（vuex 源码中大量使用）<br>Map 的键可以是任意的数据类型，包括基本的数据类型，对象以及函数，而 Object 只允许使用 Symbol 以及 String<br>Map 中的 key 是有序的，迭代的时候以其插入的顺序返回键值，而 Object 的键是无序的<br>Map 长度可以通过 size 方法来获取，而 Object 需要手动计算（Object.keys(obj).length）<br>Map 是可迭代的，Object 需要通过获取键来迭代<br>应用场景<br>当需要在单独的逻辑中访问属性或者元素的时候，应该使用 Object，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  id: <span class="number">1</span>, </span><br><span class="line">  name: <span class="string">&quot;It&#x27;s Me!&quot;</span>, </span><br><span class="line">  print: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Object Id: <span class="subst">$&#123;<span class="built_in">this</span>.id&#125;</span>, with Name: <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.print()); <span class="comment">// Object Id: 1, with Name: It&#x27;s Me.</span></span><br><span class="line"><span class="comment">// 以上操作不能用 Map 实现</span></span><br></pre></td></tr></table></figure>
<p>JSON 直接支持 Object，但不支持 Map<br>Map 是纯粹的 hash，而 Object 还存在一些其他内在逻辑，所以在执行 delete 的时候会有性能问题。所以写入删除密集的情况应该使用 Map。<br>Map 会按照插入顺序保持元素的顺序，而 Object 做不到。<br>Map 在存储大量元素的时候性能表现更好，特别是在代码执行时不能确定 key 的类型的情况。</p>
<h3 id="js继承方式"><a href="#js继承方式" class="headerlink" title="js继承方式"></a>js继承方式</h3><p>原型链继承：将父类的实例作为子类的原型<br>构造继承：使用 call()、apply() 或 bind() 方法继承父类构造函数中的属性<br>实例继承：为父类实例添加新特性，作为子类实例返回<br>组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用<br>寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>
<h3 id="实现call，apply，bind"><a href="#实现call，apply，bind" class="headerlink" title="实现call，apply，bind"></a>实现call，apply，bind</h3><p>三个方法的第一个参数都是要绑定的 this，call 的后续参数依次传入，apply 的参数放在一个数组中一起传入，call 和 apply 是立即执行函数。bind 返回一个函数并把它的 this 绑定为传入的第一个参数。<br>实现 bind：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myBind</span>(<span class="params">thisArg, ...fixedArgs</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span> </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bound</span>(<span class="params">...<span class="built_in">arguments</span></span>)</span>&#123;</span><br><span class="line">    fixedArgs.push(...arguments) </span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">new</span>.target === bound</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> self(...fixedArgs)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.apply(thisArg,fixedArgs)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要使用 bind？<br>作用域的问题，foo() {} 与 const foo = () =&gt; {} 里面的this作用域不一样，foo() {} 里面使用外部成员，需要 bind(this)，直接使用的 this 的话，作用域仅在 foo 方法内部。</p>
<h3 id="const定义的变量真的不可改变吗"><a href="#const定义的变量真的不可改变吗" class="headerlink" title="const定义的变量真的不可改变吗"></a>const定义的变量真的不可改变吗</h3><p>仅限于 const 定义基本数据类型</p>
<h3 id="什么是DOM事件流，如何阻止事件冒泡"><a href="#什么是DOM事件流，如何阻止事件冒泡" class="headerlink" title="什么是DOM事件流，如何阻止事件冒泡"></a>什么是DOM事件流，如何阻止事件冒泡</h3><p>一个事件的生命周期有三个阶段：捕捉，目标，冒泡。</p>
<ol>
<li>捕捉阶段<br>事件从 document 一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>
<li>处理（目标）阶段<br>当捕捉阶段完成后，事件到达目标元素, 触发目标元素的监听函数。</li>
<li>冒泡阶段<br>冒泡阶段的顺序与捕捉阶段的顺序刚好相反，在此阶段，事件从目标元素冒泡到 document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>
</ol>
<p>阻止事件冒泡，防止事件冒泡而带来不必要的错误和困扰。<br>这个方法就是：stopPropagation()</p>
<h3 id="什么是事件委托（事件代理）"><a href="#什么是事件委托（事件代理）" class="headerlink" title="什么是事件委托（事件代理）"></a>什么是事件委托（事件代理）</h3><p>在外部节点添加一个事件处理器，并根据 target 属性判断事件来源，这样可以把内部共用的事件绑定到外部</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>浏览器的事件循环：<br>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。</p>
<p>Node的事件循环：<br>nodejs 是单线程执行的，同时它又是基于事件驱动的非阻塞 IO 编程模型，事件循环机制是实现这一特性的原理<br>异步操作时，将任务给到另外的线程（CPU 的其它核），异步事件触发之后，就会通知主线程，主线程执行相应事件的回调。<br>执行顺序<br>程序运行会从上至下依次执行所有的同步代码<br>在执行的过程中如果遇到异步代码会将异步代码放到事件循环中<br>当所有同步代码都执行完毕后，JS 会不断检测事件循环中的异步代码是否满足条件<br>一旦满足条件就执行满足条件的异步代码</p>
<p>事件循环中的任务被分为宏任务和微任务，是为了给高优先级任务一个插队的机会：微任务比宏任务有更高优先级。<br>综上事件循环为：同步 &gt; 异步 微任务 &gt; 宏任务<br>Promise 构造函数是和主线程代码一起同步执行的，then 方法是异步执行的<br>那么微任务和宏任务都有什么呢，简单总结下就是：<br>宏任务：整体代码 script、setTimeout、setInterval、DOM 事件、Ajax<br>微任务：原生 Promise 相关（如 Promise.then()）、async/await、Node 环境下的 process.nextTick<br>注意：</p>
<ul>
<li>promise 本身是一个同步的代码（只是容器），只有它后面调用的 then() 方法才是微任务</li>
<li>await 后面的代码才是微任务, 前面的代码还是会立即执行。await 微任务可以转换成等价的 promise 微任务分析</li>
<li>宏任务在 DOM 渲染后触发，微任务在 DOM 渲染前触发<br>为什么微任务执行更早？<br>微任务是由 ES6 语法规定的，宏任务是由 Web API 规定的，宏任务执行时间一般比较长。</li>
</ul>
<h3 id="为什么JS是单线程的？为什么GUI渲染线程和JS引擎线程互斥？"><a href="#为什么JS是单线程的？为什么GUI渲染线程和JS引擎线程互斥？" class="headerlink" title="为什么JS是单线程的？为什么GUI渲染线程和JS引擎线程互斥？"></a>为什么JS是单线程的？为什么GUI渲染线程和JS引擎线程互斥？</h3><p>历史原因，JS 这门语言在创立时，多进程多线程的架构并不流行，硬件支持不够好；<br>多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高；<br>如果同时操作 DOM ，在多线程不加锁的情况下，会导致 DOM 渲染的结果不可预期。</p>
<p>由于 JS 可以操作 DOM，如果同时修改元素属性并同时渲染界面(即 JS 线程和 UI 线程同时运行)，那么渲染线程前后获得的元素可能不一致。</p>
<h3 id="ES6的Class有什么好处"><a href="#ES6的Class有什么好处" class="headerlink" title="ES6的Class有什么好处"></a>ES6的Class有什么好处</h3><p>Class 是 ES6 提供的更接近于传统语言的的写法，作为对象的模板。通过 class 关键字，可以定义类<br>class 写法只是一个语法糖，它只是让对象原型的写法更加清晰，更像面向对象编程的语法</p>
<h3 id="全局作用域和函数作用域"><a href="#全局作用域和函数作用域" class="headerlink" title="全局作用域和函数作用域"></a>全局作用域和函数作用域</h3><p>全局作用域在页面打开时被创建，页面关闭时被销毁<br>编写在 script 标签中的变量和函数，作用域为全局，在页面的任意位置都可以访问到<br>在全局作用域中有全局对象 window，代表一个浏览器窗口，由浏览器创建，可以直接调用<br>全局作用域中声明的变量和函数会作为 window 对象的属性和方法保存</p>
<p>调用函数时，函数作用域被创建，函数执行完毕，函数作用域被销毁<br>每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的<br>在函数作用域中可以访问到全局作用域的变量，在函数外无法访问到函数作用域内的变量<br>在函数作用域中访问变量、函数时，会先在自身作用域中寻找，若没有找到，则会到函数的上一级作用域中寻找，一直到全局作用域<br>在函数作用域中也有声明提前的特性，对于变量和函数都起作用，此时函数作用域相当于一个小的全局作用域，详细声明提前请看声明提前部分</p>
<p>作用域链<br>函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供 JavaScript 引擎访问的内部属性。其中一个内部属性是[[Scope]]，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>
<h3 id="词法环境和变量环境"><a href="#词法环境和变量环境" class="headerlink" title="词法环境和变量环境"></a>词法环境和变量环境</h3><p>词法环境是一种标识符到变量的映射关系<br>在词法环境中有两个组成部分：</p>
<ul>
<li>环境记录（EnvironmentRecord）：储存变量和函数声明的实际位置</li>
<li>对外部环境的引用（Outer）：当前可以访问的外部词法环境<br>词法环境分为两种类型：</li>
<li>全局环境：全局执行上下文，没有外部环境的引用，有全局对象 window 和关联的方法和属性，eg: Math, String, Date 等。还有用户定义的全局变量，并将 this 指向全局对象。</li>
<li>函数环境：用户在函数定义的变量将储存在环境记录中。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。环境记录中包含用户声明的变量，函数，还有 arguments。</li>
</ul>
<p>变量环境也是一个词法环境。他具有词法环境中所有的属性 在 ES6 中，LexicalEnvironment 和 VariableEnvironment 的区别在于前者用于存储函数声明和变量 let 和 const 绑定，而后者仅用于存储变量 var 绑定。<br>使用 let 和 const 声明的变量在词法环境创建时是未赋值初始值。而使用 var 定义的变量在变量环境创建时赋值为 undefined。这也就是为什么 const、let 声明的变量在声明前调用会报错，而 var 声明的变量不会。</p>
<h3 id="什么是执行上下文？"><a href="#什么是执行上下文？" class="headerlink" title="什么是执行上下文？"></a>什么是执行上下文？</h3><p><a href="https://github.com/mqyqingfeng/Blog/issues/4">https://github.com/mqyqingfeng/Blog/issues/4</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/5">https://github.com/mqyqingfeng/Blog/issues/5</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/6">https://github.com/mqyqingfeng/Blog/issues/6</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/8">https://github.com/mqyqingfeng/Blog/issues/8</a><br>当 JavaScript 代码执行一段可执行代码时，会创建对应的执行上下文。对于每个执行上下文，都有三个重要属性：<br>变量对象（Variable object，VO）；<br>作用域链（Scope chain）；<br>this（关于 this 指向问题，在上面推荐的深入系列也有讲从 ES 规范讲的，但是实在是难懂，对于应付面试来说以下这篇阮一峰的文章应该就可以了：JavaScript 的 this 原理 <a href="https://www.ruanyifeng.com/blog/2018/06/javascript-this.html%EF%BC%89">https://www.ruanyifeng.com/blog/2018/06/javascript-this.html）</a></p>
<h3 id="forEach和map"><a href="#forEach和map" class="headerlink" title="forEach和map"></a>forEach和map</h3><p>共同点<br>只能遍历数组<br>都是循环遍历数组中的每一项<br>每一次执行匿名函数都支持三个参数，数组中的当前项 item，当前项的索引 index ，原始数组 input<br>匿名函数中的 this 都是指 window<br>forEach 方法跳出循环–通过 dthrow error() 抛出异常的方式跳出循环，通过 return 跳过当次循环</p>
<p>不同点<br>forEach 没有返回值，不能 return；map 有返回值，可以 return</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 指向什么取决函数的调用形式，而不取决于函数的在哪调用，也不取决于在哪定义。<br>全局环境下调用 this 指向 window（全局对象）<br>函数作为对象方法被调用（指向该对象）<br>通过 call、apply 和 bind 方法显式指定 this<br>作为构造函数调用（指向创建的对象实例）<br>纯函数形式调用，指向 window<br>this 永远不能被赋值，即 this 不能写在等号左边。</p>
<h3 id="图片懒加载原理"><a href="#图片懒加载原理" class="headerlink" title="图片懒加载原理"></a>图片懒加载原理</h3><p>一张图片就是一个 img 标签，浏览器是否发起请求图片是根据 img 的 src 属性，所以实现懒加载的关键就是，在图片没有进入可视区域时，先不给 img 的 src 赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给 src 赋值。<br>实现懒加载有四个步骤，如下：</p>
<ol>
<li>加载 loading 图片</li>
<li>判断哪些图片要加载【重点】</li>
<li>隐形加载图片</li>
<li>替换真图片<br>三种具体的属性和方法：</li>
<li>offsetTop &lt; clientHeight + scrollTop</li>
<li>element.getBoundingClientRect().top &lt; clientHeight</li>
<li>IntersectionObserver<br>最简单的 html 实现：给 img 标签加上 loading=”lazy”<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;./example.jpg&quot;</span> loading=<span class="string">&quot;lazy&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h3><h3 id="什么操作会引起内存泄漏"><a href="#什么操作会引起内存泄漏" class="headerlink" title="什么操作会引起内存泄漏"></a>什么操作会引起内存泄漏</h3><p>引擎中有垃圾回收机制，调用函数的时候，系统会分配对应的空间给这个函数使用（空间大小的情况一般由这个函数的变量和形参决定），当函数试用完毕以后，这个内存空间要释放，还给系统，在函数内部声明的变量和形参是属于当前函数的内存空间的。<br>其实引擎虽然针对垃圾回收做了各种优化从而尽可能的确保垃圾得以回收，但并不是说我们就可以完全不用关心这块了，我们代码中依然要主动避免一些不利于引擎做垃圾回收操作，因为不是所有无用对象内存都可以被回收的，那当不再用到的对象内存，没有及时被回收时，我们叫它 内存泄漏</p>
<ol>
<li>不合理的使用闭包，两个函数嵌套，内部 return 的函数中存在对外部函数中变量的引用。在函数调用后，把外部的引用关系置空就好了。</li>
<li>隐式全局变量，可以在使用完之后将其置空（null）或重新分配。</li>
<li>遗忘的定时器，也就是 setTimeout 和 setInterval。调用 clearInterval 和 clearTimeout 清除。</li>
<li>遗忘的事件监听器、监听者模式</li>
<li>遗忘的 Map、Set对象。如果使用 Map ，对于键为对象的情况，可以采用 WeakMap，WeakMap。如果需要使用 Set 引用对象，可以采用 WeakSet，WeakSet 对象允许存储对象弱引用的唯一值。<br>这里可能需要简单介绍下，谈弱引用，我们先来说强引用，之前我们说 JS 的垃圾回收机制是如果我们持有对一个对象的引用，那么这个对象就不会被垃圾回收，这里的引用，指的就是 强引用 ，而弱引用就是一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，因此可能在任何时刻被回收。</li>
<li>未清理的 Console 输出<br>可以用控制台的 Performance 栏勾选 Memory 来定位和排查<br>内存泄漏如何排查和定位：<a href="https://juejin.cn/post/6984188410659340324">https://juejin.cn/post/6984188410659340324</a></li>
</ol>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>标记清除：<br>大部分浏览器以此方式进行垃圾回收，当变量进入执行环境（函数中声明变量）的时候，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，在离开环境之后还有的变量则是需要被删除的变量。标记方式不定，可以是某个特殊位的反转或维护一个列表等。<br>垃圾收集器给内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。在此之后再被加上的标记的变量即为需要回收的变量，因为环境中的变量已经无法访问到这些变量。<br>引用计数：<br>以有没有其他对象引用到它为依据判断对象是否需要回收。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。</p>
<h3 id="如果一个地区的页面加载特别慢，是因为什么原因，该怎么处理"><a href="#如果一个地区的页面加载特别慢，是因为什么原因，该怎么处理" class="headerlink" title="如果一个地区的页面加载特别慢，是因为什么原因，该怎么处理"></a>如果一个地区的页面加载特别慢，是因为什么原因，该怎么处理</h3><p>使用 cdn，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率</p>
<h3 id="预检请求和简单请求"><a href="#预检请求和简单请求" class="headerlink" title="预检请求和简单请求"></a>预检请求和简单请求</h3><p>对那些可能对服务器数据产生副作用的 HTTP 请求方法，浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。</p>
<p>按照预检请求的理解，简单请求就是对服务器无副作用的请求。</p>
<h3 id="箭头函数没有arguments，怎么获取不知道数量的参数"><a href="#箭头函数没有arguments，怎么获取不知道数量的参数" class="headerlink" title="箭头函数没有arguments，怎么获取不知道数量的参数"></a>箭头函数没有arguments，怎么获取不知道数量的参数</h3><p>可以使用 ES6 的解构语法来代替。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;函数的参数是：&#x27;</span>， args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 函数的参数是： [1， 2， 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="promise如何执行？promise-all和promise-race"><a href="#promise如何执行？promise-all和promise-race" class="headerlink" title="promise如何执行？promise.all和promise.race"></a>promise如何执行？promise.all和promise.race</h3><p>异步函数返回一个 promise，一个 promise 对象代表一个异步操作结果。</p>
<p>一个 Promise 必然处于以下几种状态之一：<br>待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。<br>已兑现（fulfilled）: 意味着操作成功完成。<br>已拒绝（rejected）: 意味着操作失败。<br>resolve() 可直接返回 Promise 成功对象，把一个普通对象转为 Promise 对象。手动实现 Promise 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转成Promise对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;why&quot;</span> &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(obj)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;res:&quot;</span>, res) <span class="comment">// res: &#123; name: &#x27;why&#x27; &#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise 通过修改状态的方式，在合适的时机触发相应状态的回调来达到处理异步的目的。Promise 通过 then() 链式调用，它接一个 Promise 对象的执行结果作为参数，return 一个返回值作为下一个 then 方法的参数，如果是 return 一个 Promise 对象，那么就需要判断它的状态。<br>Promise.race(values)，返回一个在迭代器中遇到的第一个状态确定（settled）的 promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">values</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve，reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span> ; i&lt; values.length;i++</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(values[i]).then(resolve，reject)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Promise.all(values)，返回一个 promise 实例。如果迭代器中所有的 promise 参数状态都是 resolved， 则 promise 实例的状态为 resolved，其 [[PromiseValue]] 为每个参数的 [[PromiseValue]] 组成的数组；<br>如果参数中的 promise 有一个失败（rejected），此实例的状态为 rejected，其 [[PromiseValue]] 为是第一个失败 promise 的 [[PromiseValue]]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve， reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> result = []</span><br><span class="line">      <span class="keyword">var</span> resolvedCount = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (value.length == <span class="number">0</span>) &#123;</span><br><span class="line">        resolve([])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(values[i]).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            result[i] = val</span><br><span class="line">            resolvedCount++</span><br><span class="line">            <span class="keyword">if</span> (resolvedCount == values.length) &#123;</span><br><span class="line">              resolve(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;，reason =&gt; &#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Promise.allSettled(values)方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。<br>在多个 promise 同时进行时我们很快会想到使用 Promise.all 来进行包装, 但是由于 Promise.all 的短路特性, 三个提交中若前面任意一个提交失败, 则后面的表单也不会进行提交了, 这就与我们需求不符合。<br>Promise.allSettled 跟 Promise.all 类似, 其参数接受一个 Promise 的数组, 返回一个新的 Promise, 唯一的不同在于, 其不会进行短路, 也就是说当 Promise 全部处理完成后我们可以拿到每个 Promise 的状态, 而不管其是否处理成功。<br>Promise.any。any 与 all 相反，接收一个 Promise 数组，数组中如有非 Promise 项，则此项当做成功，如果有一个Promise 成功，则返回这个成功结果，如果所有 Promise 都失败，则报错</p>
<h3 id="JS面向对象编程的理解"><a href="#JS面向对象编程的理解" class="headerlink" title="JS面向对象编程的理解"></a>JS面向对象编程的理解</h3><ol>
<li>抽象性：抽取核心数据,剔除无关属性和行为组成一个对象</li>
<li>封装性：封装就是隐藏内部的实现细节</li>
<li>继承性：所谓继承即为自己没有的继承别人有的，即在已有的对象的基础上进行拓展从而得到一个新的对象。</li>
<li>多态性：即同一操作对于不同的对象会有不同的结果。</li>
</ol>
<h3 id="SEO是什么"><a href="#SEO是什么" class="headerlink" title="SEO是什么"></a>SEO是什么</h3><p>搜索引擎优化，提高网站在搜索引擎里面的自然排名</p>
<h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><ol>
<li>外形不同：箭头函数使用箭头定义，普通函数中没有</li>
<li>箭头函数都是匿名函数。普通函数可以有匿名函数，也可以有具体名函数，但是箭头函数都是匿名函数。</li>
<li>箭头函数不能用于构造函数，不能使用 new。普通函数可以用于构造函数，以此创建对象实例。</li>
<li>箭头函数中 this 的指向不同。在普通函数中，this 总是指向调用它的对象，如果用作构造函数，this 指向创建的对象实例。箭头函数本身没有 this，但是它在声明时可以捕获其所在作用域的 this 供自己使用。call()、bind()、apply() 均不能改变其指向</li>
<li>箭头函数不绑定 arguments，取而代之用 rest 参数 … 解决</li>
<li>其他区别：<br>箭头函数不能 Generator 函数，不能使用 yeild 关键字。<br>箭头函数不具有 prototype 原型对象。<br>箭头函数不具有 super。<br>箭头函数不具有 new.target（用于检测函数或构造方法是否是通过 new 运算符被调用的）。</li>
</ol>
<h3 id="对fetch的理解"><a href="#对fetch的理解" class="headerlink" title="对fetch的理解"></a>对fetch的理解</h3><p>fetch() 方法是比 XMLHttpRequest 更简洁的 Ajax 请求。fetch 是全局量 window 的一个方法，第一个参数为 URL。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// url (必须), options (可选)</span></span><br><span class="line">fetch(<span class="string">&#x27;/some/url&#x27;</span>, &#123;</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 出错了;等价于 then 的第二个参数,但这样更好用更直观 :(</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/qq_36754767/article/details/89645041">https://blog.csdn.net/qq_36754767/article/details/89645041</a></p>
<h3 id="什么是闭包？会造成栈溢出吗？"><a href="#什么是闭包？会造成栈溢出吗？" class="headerlink" title="什么是闭包？会造成栈溢出吗？"></a>什么是闭包？会造成栈溢出吗？</h3><ul>
<li>可以访问其他函数内变量的函数（内部可以访问外部），叫做闭包。</li>
<li>定义函数不会创建闭包，只有创建/执行函数同时才创建闭包；</li>
<li>闭包可以理解为作用域嵌套，函数创建时就会形成闭包。特点是作用域里面的函数要访问作用域里面的变量，作用域不能销毁，作用域里面的函数在调用时会产生新的作用域，嵌套在当前作用域里面；</li>
<li>函数运行时创建作用域，函数结束时作用域不一定销毁；如果还有代码使用作用域里面的变量值，作用域就不会销毁，里面的变量值还是可以被调用它的函数使用；</li>
<li>函数本身处在哪个作用域（A），它运行时创建的作用域（B）就在哪个作用域（A）内部；函数本身也是处于一个作用域的。是创建它的函数运行时所创建的作用域。<br>应用场景：函数作为参数传递、函数作为返回值返回、封装功能（需要使用私有属性和方法）、防抖节流函数、私有变量<br>优点：可以读取函数内部的变量、可以重复使用变量，并且不会造成变量污染<br>缺点：会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>
</ul>
<p>栈溢出（stack overflow）指使用过多的存储器时导致调用堆栈产生的溢出。堆栈溢出的产生是由于过多的函数调用，导致使用的调用堆栈大小超过事先规划的大小，覆盖其他存储器内的资料，一般在递归中产生。堆栈溢出很可能由无限递归（Infinite recursion）产生，但也可能仅仅是过多的堆栈层级。个人认为闭包一般不会造成栈溢出。</p>
<h3 id="什么是私有作用域"><a href="#什么是私有作用域" class="headerlink" title="什么是私有作用域"></a>什么是私有作用域</h3><p>函数执行的时候，开辟的用来解析函数体的代码的新的栈内存，他也叫做私有作用域；<br>js 没有块级作用域，但是可以模拟，比如：</p>
<ol>
<li>立即执行函数，将函数声明转化为表达式<br>使用私有作用域的技术可以减少闭包所占用的空间，因为没有指向匿名函数的引用。 当函数自调用执行完成后，马上销毁其作用域链了。还可以限制了向全局作用域中添加全局变量和函数，减少内存的占用率</li>
</ol>
<h3 id="的结果和-的结果？"><a href="#的结果和-的结果？" class="headerlink" title="[]==[]的结果和[]==![]的结果？"></a>[]==[]的结果和[]==![]的结果？</h3><p>[]==[] 的结果是 false，因为每次使用 [] 都是新建一个数组对象，比较的时候比较的是它们的引用，尽管两两边看起来都是空数组但实际上从引用看是不相等的，[]==![] 的结果也是 false。如果想判断数组为空，可以判断 array.length === 0。</p>
<p>[]==![] 的结果是 true</p>
<ol>
<li>! 运算符优先级比 == 高，所以先运算 ![]，得到 false.</li>
<li>false 在运算中会强制转换为 0.</li>
<li>[] 强制转换为原始类</li>
</ol>
<p>型为 “”。<br>4. “” 会强制转换为 0。<br>5. 两侧都是 number 类型为 0，所以 0==0 为 true。</p>
<h3 id="路由跳转的时候原来的页面去哪了？（京东）"><a href="#路由跳转的时候原来的页面去哪了？（京东）" class="headerlink" title="路由跳转的时候原来的页面去哪了？（京东）"></a>路由跳转的时候原来的页面去哪了？（京东）</h3><p>个人认为销毁了。</p>
<h3 id="路由原理-history-和-hash-两种路由方式的特点"><a href="#路由原理-history-和-hash-两种路由方式的特点" class="headerlink" title="路由原理 history 和 hash 两种路由方式的特点"></a>路由原理 history 和 hash 两种路由方式的特点</h3><h4 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h4><p>vue-router 默认使用 hash 模式，原理是 onhashchange 事件，基于 location.hash 来实现的。</p>
<ol>
<li>location.hash 的值实际就是 URL 中 # 后面的东西 它的特点在于：hash 虽然出现 URL 中，但它是用来指导浏览器动作的，所以不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</li>
<li>可以为 hash 的改变添加监听事件。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>, funcRef, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h4 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h4>利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。<br>这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。<h4 id="abstract-模式"><a href="#abstract-模式" class="headerlink" title="abstract 模式"></a>abstract 模式</h4>较少用到。支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。</li>
</ol>
<h3 id="前端设计模式"><a href="#前端设计模式" class="headerlink" title="前端设计模式"></a>前端设计模式</h3><ol>
<li>单例模式</li>
<li>工厂模式</li>
<li>策略模式</li>
<li>代理模式</li>
<li>观察者模式</li>
<li>模块模式</li>
<li>构造函数模式</li>
<li>混合模式<br><a href="https://www.jianshu.com/p/4f3014fb8b8b">https://www.jianshu.com/p/4f3014fb8b8b</a></li>
</ol>
<h3 id="对前端的异步编程的了解有哪些"><a href="#对前端的异步编程的了解有哪些" class="headerlink" title="对前端的异步编程的了解有哪些"></a>对前端的异步编程的了解有哪些</h3><p>回调函数<br>事件监听<br>发布订阅<br>Promise</p>
<h3 id="js中自定义事件的使用与触发"><a href="#js中自定义事件的使用与触发" class="headerlink" title="js中自定义事件的使用与触发"></a>js中自定义事件的使用与触发</h3><p>在开发过程中，js原生事件不足以满足开发需求，需要开发者自定义事件。<br>Events 可以使用 Event 构造函数创建，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">&#x27;build&#x27;</span>);</span><br><span class="line">elem.addEventListener(<span class="string">&#x27;build&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; ... &#125;, <span class="literal">false</span>);</span><br><span class="line">elem.dispatchEvent(event) <span class="comment">// 触发该事件</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/cangqinglang/p/9746650.html">https://www.cnblogs.com/cangqinglang/p/9746650.html</a></p>
<h3 id="continue-是干啥用的"><a href="#continue-是干啥用的" class="headerlink" title="continue 是干啥用的"></a>continue 是干啥用的</h3><p>在循环中使用，为 true 时跳过当前循环</p>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。一个简单实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通的add函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingAdd</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)           <span class="comment">// 3</span></span><br><span class="line">curryingAdd(<span class="number">1</span>)(<span class="number">2</span>)   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>使用柯里化函数的好处<br><a href="https://www.jianshu.com/p/2975c25e4d71">https://www.jianshu.com/p/2975c25e4d71</a></p>
<h3 id="new的原理"><a href="#new的原理" class="headerlink" title="new的原理"></a>new的原理</h3><ol>
<li>首先创建一个空对象</li>
<li>将这个空对象的原型对象指向构造函数的原型，从而继承原型上的方法，即 prototype 连接</li>
<li>this 指向调用它的对象</li>
<li>如果构造函数返回了一个对象 res，就将该返回值 res 返回，如果返回值不是对象，就将创建的对象返回<br>实现：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为new是关键字,我用函数的形式来实现，可以将构造函数和构造函数的参数传入</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">f, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个空对象，并将对象的__proto__指向构造函数的prototype 这里我两步一起做了</span></span><br><span class="line">    <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(f.prototype);</span><br><span class="line">    <span class="comment">//2.将构造函数中的this指向obj，执行构造函数代码,获取返回值 </span></span><br><span class="line">    <span class="keyword">const</span> res = f.apply(obj, args);</span><br><span class="line">    <span class="comment">//3.判断返回值类型 </span></span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="new-Array-10-创建的数组数组中的元素是什么，map对上述数组处理后返回什么（字节飞书人力套件）"><a href="#new-Array-10-创建的数组数组中的元素是什么，map对上述数组处理后返回什么（字节飞书人力套件）" class="headerlink" title="new Array(10)创建的数组数组中的元素是什么，map对上述数组处理后返回什么（字节飞书人力套件）"></a>new Array(10)创建的数组数组中的元素是什么，map对上述数组处理后返回什么（字节飞书人力套件）</h3>会创建一个长度为 10，元素全为 undefined 的数组<br>map() 会跳过空位，但会保留这个值<br>其他方法：<br>forEach(), filter(), every() 和 some() 都会跳过空位。<br>join() 和 toString() 会将空位视为 undefined，而 undefined 和 null 会被处理成空字符串<br><a href="http://www.javashuo.com/article/p-vwvhoxam-dq.html">http://www.javashuo.com/article/p-vwvhoxam-dq.html</a></li>
</ol>
<h3 id="for-in和for-of的区别"><a href="#for-in和for-of的区别" class="headerlink" title="for in和for of的区别"></a>for in和for of的区别</h3><p>for in 是 ES5 标准，遍历的是 key（可遍历对象、数组或字符串的 key）；for of 是 ES6 标准，遍历的是 value（可遍历对象、数组或字符串的 value）。<br>使用 for in 可以遍历数组，但是会存在以下问题：</p>
<ol>
<li>index 索引为字符串型数字（注意，非数字），不能直接进行几何运算。</li>
<li>遍历顺序有可能不是按照实际数组的内部顺序（可能按照随机顺序）。</li>
<li>使用 for in 会遍历数组所有的可枚举属性，包括原型。原型方法 method 和 name 属性都会被遍历出来，通常需要配合 hasOwnProperty() 方法判断某个属性是否该对象的实例属性，来将原型对象从循环中剔除。所以 for in 更适合遍历对象，通常是建议不要使用 for in 遍历数组。<br>for of 可以简单、正确地遍历数组（不遍历原型上的 method 和 name）。</li>
<li>这是最简洁、最直接的遍历数组元素的语法。</li>
<li>这个方法避开了 for in 循环的所有缺陷。</li>
<li>与 forEach() 不同的是，它可以正确响应 break、continue 和 return 语句。<br>因此建议是使用 for of 遍历数组，因为 for of 遍历的只是数组内的元素，而不包括数组的原型属性 method 和索引 name。<br>区别总结：</li>
</ol>
<ul>
<li>简单总结就是，for in 遍历的是数组的索引（即键名），而 for of 遍历的是数组元素值。</li>
<li>for in 总是得到对象的 key 或数组、字符串的下标。</li>
<li>for of 总是得到对象的 value 或数组、字符串的值，另外还可以用于遍历 Map 和 Set。</li>
</ul>
<h3 id="什么是SPA"><a href="#什么是SPA" class="headerlink" title="什么是SPA"></a>什么是SPA</h3><p>单页面应用<br><a href="https://blog.csdn.net/huangpb123/article/details/86183453">https://blog.csdn.net/huangpb123/article/details/86183453</a></p>
<h3 id="你觉得js是怎么运行的？这个语言它是怎么去跑起来的？（2022-3-字节飞书）"><a href="#你觉得js是怎么运行的？这个语言它是怎么去跑起来的？（2022-3-字节飞书）" class="headerlink" title="你觉得js是怎么运行的？这个语言它是怎么去跑起来的？（2022.3 字节飞书）"></a>你觉得js是怎么运行的？这个语言它是怎么去跑起来的？（2022.3 字节飞书）</h3><h3 id="0-1-0-2-0-3的问题"><a href="#0-1-0-2-0-3的问题" class="headerlink" title="0.1+0.2!==0.3的问题"></a>0.1+0.2!==0.3的问题</h3><p>JS 在做数字计算的时候，使用 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。实际相加的是两个非常接近 0.1 和 0.2 的数字。<br>解决方案：转化为整数相加、使用库如 math.js</p>
<h2 id="浏览器-计算机网络问题"><a href="#浏览器-计算机网络问题" class="headerlink" title="浏览器 + 计算机网络问题"></a>浏览器 + 计算机网络问题</h2><h3 id="讲一下计算机网络的概念，每一层都是做什么工作的"><a href="#讲一下计算机网络的概念，每一层都是做什么工作的" class="headerlink" title="讲一下计算机网络的概念，每一层都是做什么工作的"></a>讲一下计算机网络的概念，每一层都是做什么工作的</h3><p>应用层：为应用程序提供网络服务<br>表示层：数据格式化、加密解密<br>会话层：解除、建立、管理会话连接</p>
<p>传输层：解除、建立、管理端到端的连接和通信细节</p>
<p>网络层：数据在网络中分组传输，IP 寻址和路由选择</p>
<p>数据链路层：控制网络层与物理层之间通信<br>物理层：以二进制数据形式在物理媒体上传输数据</p>
<h3 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h3><p>GET 请求在浏览器刷新或者回退的时候是无副作用的。POST 的数据会被重新提交。<br>GET 会将数据存在浏览器的历史中，POST 不会<br>GET 编码格式只能用 ASCII 码，POST 没有限制<br>可见性，参数在 URL，用户可以看见，POST 的参数在 request body 中，不会被用户看见<br>长度 get 参数一般限制为 url 可输入长度，post 参数无限制。</p>
<h3 id="TCP连接为什么要生成随机值，为什么-1，怎么判断丢包（2022-3-字节飞书）"><a href="#TCP连接为什么要生成随机值，为什么-1，怎么判断丢包（2022-3-字节飞书）" class="headerlink" title="TCP连接为什么要生成随机值，为什么 +1，怎么判断丢包（2022.3 字节飞书）"></a>TCP连接为什么要生成随机值，为什么 +1，怎么判断丢包（2022.3 字节飞书）</h3><p>防止 TCP 会话攻击模拟 IP 和服务器建立连接。抓包只能发生在同一网络中，随机 ISN 能避免非同一网络的攻击<br>广域网的连接情况很复杂，可能连接波动但数据还没到服务器，报文不一定会按发送的时序到达目标，所以要 +1</p>
<h3 id="讲一下登录过程（2022-3-字节飞书）"><a href="#讲一下登录过程（2022-3-字节飞书）" class="headerlink" title="讲一下登录过程（2022.3 字节飞书）"></a>讲一下登录过程（2022.3 字节飞书）</h3><p>初次登录的时候，前端调后调的登录接口，发送用户名和密码，后端收到请求，验证用户名和密码，验证成功，就给前端返回一个 token，和一个用户信息的值，前端拿到 token，将 token 储存到 Vuex 中，然后从 Vuex 中把 token 的值存入浏览器 Cookies 中。把用户信息存到 Vuex 然后再存储到 LocalStroage 中；<br>然后跳转到下一个页面，根据后端接口的要求，只要不登录就不能访问的页面需要在前端每次跳转页面时判断 Cookies 中是否有 token，没有就跳转到登录页，有就跳转到相应的页面，我们应该再每次发送 post/get 请求的时候应该加入 token，常用方法在项目 utils/service.js 中添加全局拦截器，将 token 的值放入请求头中<br>怎么把 token 放到 header？用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">headers: &#123;<span class="string">&#x27;Authorization&#x27;</span>: token&#125;</span><br></pre></td></tr></table></figure>
<p>token 怎么设置过期时间？<br>由后端设置<br>讲一下 304 和重定向？<br>如果用户在正常操作的过程中，Token 过期失效了，要求用户重新登录。用户体验岂不是很糟糕？<br>使用 Refresh Token，它可以避免频繁的读写操作。这种方案中，服务端不需要刷新 Token 的过期时间，一旦 Token 过期，就反馈给前端，前端使用 Refresh Token 申请一个全新 Token 继续使用。</p>
<h3 id="你在项目中是如何封装接口的？（2022-3-字节飞书）"><a href="#你在项目中是如何封装接口的？（2022-3-字节飞书）" class="headerlink" title="你在项目中是如何封装接口的？（2022.3 字节飞书）"></a>你在项目中是如何封装接口的？（2022.3 字节飞书）</h3><p>封装了一个 useRequest 函数，调接口传入参数后调用这个函数，传请求方法、后端路径和参数。然后里面封装了个 Promise 请求，用了 rxjs 的 toPromise()（将 Observer 返回的 Observable 对象转化成 Promise，Observable 是由 Observer（观察者）通过（Subscribe）订阅的方式被动接受各种形式的数据），正确就调用 .then() 返回 res，有错误就 .catch() 返回 err。</p>
<h3 id="AST-的了解？怎么抽象的？用途是什么"><a href="#AST-的了解？怎么抽象的？用途是什么" class="headerlink" title="AST 的了解？怎么抽象的？用途是什么"></a>AST 的了解？怎么抽象的？用途是什么</h3><p>抽象语法树。</p>
<ol>
<li>词法分析：浏览器的解析器首先将代码解析成 AST。它读取我们的代码，移除空格注释等，然后分割进一个数组。</li>
<li>语法分析：它会将词法分析出来的数组转换成树形的形式，同时验证语法。语法如果有错的话，抛出语法错误。<br>用途：编程语言很多，需要一个统一的结构让计算机识别。比如 typescript 的类型检查，IDE 的语法高亮，代码检查，转译等等，都是需要先将代码转化成 AST 在进行后续的操作。</li>
</ol>
<h3 id="介绍-HTTPS-握手过程（加密流程和原理）"><a href="#介绍-HTTPS-握手过程（加密流程和原理）" class="headerlink" title="介绍 HTTPS 握手过程（加密流程和原理）"></a>介绍 HTTPS 握手过程（加密流程和原理）</h3><p>客户端使用 https 的 url 访问 web 服务器,要求与服务器建立 ssl 连接<br>tcp 连接建立后，客户端向服务端请求公钥，客户端拿到服务端返回的公钥后，用这个公钥加密一组对称密钥的信息，传输给服务端。后续 http 的通信过程，就用这套对称密钥加密解密。</p>
<h3 id="http-和-https"><a href="#http-和-https" class="headerlink" title="http 和 https"></a>http 和 https</h3><p>http：超文本传输协议。基于文本，无状态，无连接。是一个客服端和服务器端请求和应答的标准（tcp），使浏览器更加高效，使网络传输减少。默认使用 80 端口<br>https：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版本，运行在 SSL/TLS 层上，而 SSL/TLS 层是运行在 TCP 层之上，通过 SSL 加密，要 CA 证书（要钱）。默认使用 443 端口</p>
<ul>
<li>在 HTTP 和 TCP 中多了一层 TLS</li>
<li>加密是对称加密和非对称加密</li>
</ul>
<h3 id="http1-0-和-http1-1"><a href="#http1-0-和-http1-1" class="headerlink" title="http1.0 和 http1.1"></a>http1.0 和 http1.1</h3><ol>
<li>缓存策略。<br>http1.0 的缓存策略主要是依赖 header 中的 If-Modiified-Since, Expire（到期）<br>http1.1 的缓存策略要比 http1.0 略多,例如 Entity tag（实体标签）, If-Unmodified-Since, If-Match, If-None-Match等。</li>
<li>宽带和网络连接优化:。<br>http1.0 中会存在一些性能浪费,比如我们的只需要对象中的一部分,但是每次请求返回的却是整个对象,这无疑造成了性能的损害<br>http1.1 则不然,它可以通过在请求头处设置 range 头域,就可以返回请求资源的某一部分,也就是返回码为 206（Partial Content）的时候,这对于性能优化很有必要。<blockquote>
<p>这里所谓的请求资源的一部分,也就是大家常说的断点续传</p>
</blockquote>
</li>
<li>Host头处理：<br>http1.0 中默认每台服务器都绑定唯一的一个 IP 地址，所以请求消息中 url 并没有传递主机名,也就是 hostname<br>http1.1 中请求消息和响应消息都支持 Host 头域，而且，如果我们不传这个字段还会报一个 400（bad request） 的状态码</li>
<li>长连接：<br>http1.1 支持长连接和请求的流水线(pipelining)，在一个 TCP 链接上可以传送多个 http 请求和响应。这样就不用多次建立和关闭 TCP 连接了。</li>
</ol>
<h3 id="http1-0-和-http2-0"><a href="#http1-0-和-http2-0" class="headerlink" title="http1.0 和 http2.0"></a>http1.0 和 http2.0</h3><p>HTTP1.x 的解析是基于文本。HTTP2.0 的协议解析采用二进制格式<br>HTTP2.0 比 HTTP1.0 有多路复用，一个连接可以并发处理多个请求<br>header 压缩：HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小<br>服务器推送：我们对支持 HTTP2.0 的 web server 请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源<br>多路复用：只通过一个 TCP 连接就可以传输所有的请求数据。解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输</p>
<h3 id="一个TCP连接能发几个HTTP请求？"><a href="#一个TCP连接能发几个HTTP请求？" class="headerlink" title="一个TCP连接能发几个HTTP请求？"></a>一个TCP连接能发几个HTTP请求？</h3><p>HTTP1.0 不支持长连接，因此一个 TCP 发送一个 HTTP 请求；<br>HTTP1.1 支持长连接，只要 TCP 连接不断开，可以一直发送 HTTP 请求，没有上限；<br>HTTP2.0 支持多用复用，一个 TCP 连接可以并发多个 HTTP 请求，也支持长连接，因此只要不断开 TCP 连接，HTTP 请求数可以没有上限地持续发送。</p>
<h3 id="Cookie、SessionStronge、LocalStronge-的区别"><a href="#Cookie、SessionStronge、LocalStronge-的区别" class="headerlink" title="Cookie、SessionStronge、LocalStronge 的区别"></a>Cookie、SessionStronge、LocalStronge 的区别</h3><h4 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h4><p>HTTP 协议是一种无状态协议，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Cookie： cookie 是存在浏览器的标识用户的方式，由服务端为每一个用户签发不同 session id 发送给浏览器并存储在cookie，下次访问会带上这个session id，服务端就知道这个访问是哪个用户了。<br>SessionStorage 和 LocalStorage：由支持本地存储的浏览器实现。添加属性即可实现存储。</p>
<h4 id="在同一浏览器下有效期不同"><a href="#在同一浏览器下有效期不同" class="headerlink" title="在同一浏览器下有效期不同"></a>在同一浏览器下有效期不同</h4><p>Cookie:         默认是关闭浏览器后失效， 但是也可以设置过期时间<br>SessionStorage: 仅在当前会话（窗口）下有效，关闭窗口或浏览器后被清除，不能设置过期时间<br>LocalStorage:   除非被清除，否则永久保存</p>
<h4 id="容量不同"><a href="#容量不同" class="headerlink" title="容量不同"></a>容量不同</h4><p>Cookie 容量限制：大小(4KB左右)和个数(20~50)<br>SessionStorage 和 LocalStorage 容量限制：大小（5M左右）<br>localStorage 存满了怎么办？划分域名。各域名下的存储空间由各业务组统一规划使用；跨页面传数据：考虑单页应用、优先采用 url 传数据；最后的兜底方案：清掉别人的存储</p>
<h4 id="网络请求不同"><a href="#网络请求不同" class="headerlink" title="网络请求不同"></a>网络请求不同</h4><p>Cookie 网络请求：在第一次请求时由服务端生成返回给客户端，每次都会携带在 HTTP 请求头中如果使用 cookie 保存过多数据会带来性能问题<br>SessionStorage 和 LocalStorage 网络请求：仅在浏览器中保存，不参与和服务器的通信</p>
<h4 id="应用场景不同"><a href="#应用场景不同" class="headerlink" title="应用场景不同"></a>应用场景不同</h4><p>Cookie:         判断用户是否登录、保存上次查看的页面信息<br>sessionStorage: 表单数据、同一用户的不同页面、保存登录信息<br>LocalStorage:   购物车、一些需要长期保存在本地的数据</p>
<h4 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h4><p>Express 中使用 res.cookie() 一个验证身份的字符串，网站在用户验证成功之后都会设置一个 cookie，只要 cookie 没有过期，用户就可以自由浏览这个网站的任意页面不需要再次登录<br>localStorage.setItem(item，value)<br>localStorage.getItem(item)<br>localStorage.removeItem(item)<br>sessionStorage 和 localStorage 用法一样，但是它只保存数据到浏览器关闭，不会触发 onstorage 事件</p>
<h3 id="Cookie和Token的作用"><a href="#Cookie和Token的作用" class="headerlink" title="Cookie和Token的作用"></a>Cookie和Token的作用</h3><ul>
<li>cookie<br>弥补 HTTP 无状态的问题，保存用户的相关登录状态，当第一次验证通过后，服务器可以通过 set-cookie 令客户端将自己的 cookie  保存起来，当下一次再发送请求的时候，直接带上 cookie 即可，而服务器检测到客户端发送的 cookie 与其保存的 cookie 值保持一致时，则直接信任该连接，不再进行验证操作。</li>
<li>Token<br>类似 cookie 的一种验证信息，客户端通过登录验证后，服务器会返回给客户端一个加密的 token，然后当客户端再次向服务器发起连接时，带上 token，服务器直接对 token 进行校验即可完成权限校验。<br>区别：cookie 有跨域限制；Token 没有；存储空间 cookie 4kb，Token 无限制；cookie 需存储在服务端，Token 可以在客户端存储。<br><a href="https://juejin.cn/post/7111349594625146887">https://juejin.cn/post/7111349594625146887</a></li>
</ul>
<h3 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h3><p>强缓存：服务器通知浏览器一个缓存时间，在缓存时间内的请求会直接使用缓存，不再执行比较缓存策略<br>协商缓存：让服务端判断客户端的资源是否更新的验证。提升缓存的复用率，将缓存信息中的 Etag 和 Last-Modified 通过请求发送给服务器，由服务器校验，返回 304 时直接使用缓存</p>
<h3 id="讲讲Etag和LastModified"><a href="#讲讲Etag和LastModified" class="headerlink" title="讲讲Etag和LastModified"></a>讲讲Etag和LastModified</h3><p>http 协商缓存中：<br>Etag / lastModified 过程如下：</p>
<ol>
<li>客户端请求一个页面（A）。</li>
<li>服务器返回页面 A，并在给 A 加上一个 Last-Modified / ETag。</li>
<li>客户端展现该页面，并将页面连同 Last-Modified / ETag一起缓存。</li>
<li>客户再次请求页面 A，并将上次请求时服务器返回的 Last-Modified / ETag 一起传递给服务器。</li>
<li>服务器检查该 Last-Modified 或 ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应 304 和一个空的响应体。<br>当浏览器第一次请求一个资源时，服务端返回状态码 200，返回请求的资源的同时 HTTP 响应头会有一个 Last-Modified 标记着文件在服务端最后被修改的时间。还有一个 Etag 字段，是服务端生成的一个序列值，如果服务器的资源没有变化，Etag 字段没有被修改，则返回 304<br>Last-Modified 还有个对应的请求头叫 If-Modified-Since。浏览器第二次请求上次请求过的资源时，浏览器会在 HTTP 请求头中添加一个 If-Modified-Since 的标记，用来询问服务器该时间之后文件是否被修改过</li>
</ol>
<h3 id="如果你的页面加载时，需要同时请求50个同源的http1-0接口，每个接口的相应时长为100毫秒，那么你用chrome浏览器，多久能完成请求？"><a href="#如果你的页面加载时，需要同时请求50个同源的http1-0接口，每个接口的相应时长为100毫秒，那么你用chrome浏览器，多久能完成请求？" class="headerlink" title="如果你的页面加载时，需要同时请求50个同源的http1.0接口，每个接口的相应时长为100毫秒，那么你用chrome浏览器，多久能完成请求？"></a>如果你的页面加载时，需要同时请求50个同源的http1.0接口，每个接口的相应时长为100毫秒，那么你用chrome浏览器，多久能完成请求？</h3><p>多久不重要，重要的是知道浏览器存在并发限制，不同浏览器的不同版本、不同 http 协议的并发限制数都不同</p>
<ul>
<li>对客户端操作系统而言，过多的并发涉及到端口数量和线程切换开销。</li>
<li>HTTP/1.1 有 Keep Alive，支持复用现有连接，等请求返回回来后，再复用连接请求可以快很多。</li>
<li>将所有请求一起发给服务器，也很可能会引发服务器的并发阈值控制而被 BAN。<br>还可以涉及页面加载的性能优化问题</li>
</ul>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>进程是 CPU 资源分配的最小单位，线程是 CPU 调度的最小单位。一个进程里面可以有多个线程，线程是共享了进程的上下文环境，的更为细小的 CPU 时间段。CPU 运行一个软件相当于打开一个了进程，执行该软件里面的 1 个功能相当于打开一个线程<br><a href="https://juejin.cn/post/6844903919789801486">https://juejin.cn/post/6844903919789801486</a></p>
<h3 id="https加密原理"><a href="#https加密原理" class="headerlink" title="https加密原理"></a>https加密原理</h3><ol>
<li><p>HTTPS 对称加密<br>服务器每次发送真实数据前，会先生成一把密钥传输（以明文方式传输密钥容易被劫持）给客户端，服务器给客户端发送的真实数据会先用这把密钥进行加密，客户端收到加密数据后再用密钥进行解密（客户端给服务器发送数据同理）</p>
</li>
<li><p>HTTPS 非对称加密<br>客户端和服务器都有两把密钥，一把公钥一把私钥（公钥加密的数据只有私钥才能解密，私钥加密的数据只有公钥才能解密），服务器在给客户端发送真实数据前，先用客户端明文传输给服务器的公钥进行加密，客户端收到后用自己的私钥进行解密，反之同理</p>
</li>
<li><p>HTTPS 对称加密 + 非对称加密<br>鉴于 HTTPS 非对称加密在加密时速度特别慢，可使用 HTTPS 对称加密 + 非对称加密（以非对称加密的方式传输对称加密密钥），接着就可使用对称加密的密钥传输数据。非对称加密之所以不安全是因为客户端不知道接收的公钥是否属于服务器</p>
</li>
<li><p>HTTPS 数字证书<br>核心在于证明客户端接收的公钥是属于服务器的，解决这个问题方法是使用数字证书（即找到一个大家都认可的认证中心 CA）<br>服务器在给客户端传输公钥的过程中，会将公钥+服务器个人信息通过 hash 算法生成信息摘要，为防止信息摘要被掉包服务器会用 CA 提供的私钥对信息摘要加密形成数字签名。最后还会将没有进行 hash 算法计算的服务器个人信息 + 公钥和数字签名合并在一起形成数字证书。<br>客户端拿到数字证书后，用 CA 提供的公钥对数字签名进行解密得到信息摘要，然后对数字证书中服务器个人信息+公钥进行hash 得到另一份信息摘要，两份信息摘要进行比对，若一样则是目标服务器，否则不是。<br>服务器会申请证书，客户端会内置证书。</p>
</li>
</ol>
<h3 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h3><ul>
<li>XSS 注入：往 web 页面插入恶意的 html 标签或者 js 代码。对用户输入的内容，需要转码（大部分时候要服务端来处理，偶尔也需要前端处理），禁止使用 eval 函数，尽量采用 post 而不使用 get 提交表单；</li>
<li>https：这个显然是必须的，好处非常多；</li>
<li>CSRF：通过伪装来自受信任用户的请求。要求服务端加入 CSRF 的处理方法（至少在关键页面加入），添加校验 token 等、执行严格的 cookie 策略、双重 Cookie 验证、同源检测、验证 HTTP Referer（它记录了该 HTTP 请求的来源地址）字段等<br><a href="https://www.cnblogs.com/meituantech/p/9777222.html">https://www.cnblogs.com/meituantech/p/9777222.html</a><br><a href="https://www.cnblogs.com/shanyou/p/5038794.html">https://www.cnblogs.com/shanyou/p/5038794.html</a></li>
</ul>
<h3 id="304-是什么意思-一般什么场景出现，命中强缓存返回什么状态码"><a href="#304-是什么意思-一般什么场景出现，命中强缓存返回什么状态码" class="headerlink" title="304 是什么意思 一般什么场景出现，命中强缓存返回什么状态码"></a>304 是什么意思 一般什么场景出现，命中强缓存返回什么状态码</h3><p>304 状态码或许不应该认为是一种错误，而是对客户端有缓存情况下服务端的一种响应。<br>客户端在请求一个文件的时候，发现自己缓存的文件有 Last Modified ，那么在请求中会包含 If Modified Since ，这个时间就是缓存文件的 Last Modified。因此，如果请求中包含 If Modified Since，就说明已经有缓存在客户端。服务端只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 。<br>强缓存命中返回 200（200 from cache）<br>常见状态码：<br>200 请求处理成功<br>204 请求处理成功<br>301 永久性重定向<br>302 临时性重定向<br>303 临时性重定向，并明确表示客户端要用 GET 方法请求资源<br>304 资源已找到，但客户端缓存资源未过期，仍可使用<br>400 请求报文中存在语法错误<br>401（总共返回两次） ①需要认证（弹出认证窗口）②认证失败<br>403 没有权限，拒绝访问<br>404 无法找到请求的资源（①网址错了 ②服务器拒绝请求，不说明理由）<br>500 服务器内部资源错误<br>503 服务器超载，停机维护</p>
<h3 id="浏览器不同页面之间怎么传递消息"><a href="#浏览器不同页面之间怎么传递消息" class="headerlink" title="浏览器不同页面之间怎么传递消息"></a>浏览器不同页面之间怎么传递消息</h3><ol>
<li>通过 form 表单传递参数：注意表单元素隐藏按钮的使用</li>
<li>通过带参数的 url 传递：url?参数名1=值1&amp;参数名2=值2</li>
<li>请求 request 对象：将数据绑定到 request 对象上，通过 request 对象 getAttribute 和 setAttribute 方法读写</li>
<li>用户会话 session 对象：将数据绑定到 session 对象上，通过 session 对象 getAttribute 和 setAttribute 方法读写</li>
<li>application 对象：将数据绑定到 application 对象上，通过 application 对象 getAttribute 和 setAttribute 方法读写</li>
<li>cookie 对象：将数据写到到客户端浏览器 cookie 文件中<br>其中方式一、方式二只能实现字符串参数的传递，方式三、四、五、六可以实现对象的传递（方式六需要对象序列化后进行存储）。<br>方式一、方式二、方式三数据传递只能请求页面获取数据，而方式四、五、六可以在多个不同页面获取数据对象。<br>方式四和六保存的数据对象都是和某个用户相关的信息，不同的是方式四将数据保存到服务器内存中，方式六将数据保存到客户端内存中。<br>方式五保存的数据对象都是和所有用户相关的信息，数据也是保存到服务器内存中。</li>
</ol>
<h3 id="ajax用途"><a href="#ajax用途" class="headerlink" title="ajax用途"></a>ajax用途</h3><p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。<br>AJAX = Asynchronous JavaScript and XML（异步的 JavaS3cript 和 XML）。AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</p>
<h3 id="什么是websocket"><a href="#什么是websocket" class="headerlink" title="什么是websocket"></a>什么是websocket</h3><p>WebSocket 是一种网络通信协议。<br>由于 HTTP 协议无法实现服务器主动向客户端发起消息，WebSocket 就是这样发明的。任意一方都可以通过建立的连接将数据推送到另一端。WebSocket 只需要建立一次连接，就可以一直保持连接状态。这相比于 AJAX 轮询方式的不停建立连接显然效率要大大提高。<br>websocket可以用于跨域，由其 API 实现，open 和 message 方法分别可以传输和接收后台的值。<br><a href="https://www.cnblogs.com/LO-ME/p/10829284.html">https://www.cnblogs.com/LO-ME/p/10829284.html</a><br><a href="https://gitlwz.github.io/2018/08/20/js-websocket-ky/">https://gitlwz.github.io/2018/08/20/js-websocket-ky/</a><br>websocket 既然能支持跨域方法，那就是说，一个开放给公网的 websocket 服务任何人都能访问，那安全性如何保障？可以控制只有通过认证的域名才能访问吗？</p>
<h3 id="什么是SSR"><a href="#什么是SSR" class="headerlink" title="什么是SSR?"></a>什么是SSR?</h3><p>将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序。<br><a href="https://www.jianshu.com/p/10b6074d772c">https://www.jianshu.com/p/10b6074d772c</a></p>
<h3 id="聊聊浏览器架构"><a href="#聊聊浏览器架构" class="headerlink" title="聊聊浏览器架构"></a>聊聊浏览器架构</h3><p><a href="https://xie.infoq.cn/article/5d36d123bfd1c56688e125ad3">https://xie.infoq.cn/article/5d36d123bfd1c56688e125ad3</a></p>
<h3 id="讲讲TCP和UDP协议"><a href="#讲讲TCP和UDP协议" class="headerlink" title="讲讲TCP和UDP协议"></a>讲讲TCP和UDP协议</h3><p>基于 UDP 的协议：dhcp/dns/ntp 低延迟<br>基于 TCP 的协议：http/ftp/tls/ws/socks5 可靠性高<br>UDP：用户数据报协议（UDP，User Datagram Protocol）为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据报的方法，特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">像信箱</span><br><span class="line">非连接型</span><br><span class="line">给定目标位置直接扔过去</span><br><span class="line">无响应，不知道有没有送到</span><br><span class="line">接收方会校验数据的正确性，所以送到的话一般来说是对的</span><br><span class="line">支持一对一、一对多、多对一、多对多</span><br><span class="line">缺点：不保证送达，数据包很小，不能保证按照发送顺序送达</span><br><span class="line">优点：低延迟，丢包也不重发；如游戏，电话语音</span><br></pre></td></tr></table></figure>
<p>TCP：传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP 四元组：源 ip, 目的 ip，源端口，目的端口；确定网络中独一无二的连接</span><br><span class="line">三次握手保证连接的可靠性（客户端请求连接，服务器同意连接，客户端表示收到服务器的消息）</span><br><span class="line">只能一对一通信</span><br><span class="line">TCP 半开状态：即一侧关闭了连接，不再发送数据，但可以接收数据，直至对侧也关闭了连接；另一侧没有关闭连接，仍可以发送数据。</span><br><span class="line">四次挥手（客户端请求断开，服务器表示收到，服务器请求断开，客户端表示收到）</span><br></pre></td></tr></table></figure>

<h3 id="知道http3-0吗"><a href="#知道http3-0吗" class="headerlink" title="知道http3.0吗"></a>知道http3.0吗</h3><p>http3.0 基于 UDP 协议实现，基本继承了 HTTP2.0 的强大功能<br>HTTP2.0 协议的多路复用机制解决了 HTTP 层的队头阻塞问题，但是在 TCP 层仍然存在队头阻塞问题。QUIC 在一条链接上可以有多个 stream，stream 之间是互不影响的，当一个 stream 出现丢包影响范围非常小，从而解决队头阻塞问题<br>0RTT连接：简单来说，基于 TCP 协议和 TLS 协议的 HTTP2.0 在真正发送数据包之前需要花费一些时间来完成握手和加密协商，完成之后才可以真正传输业务数据。但是 QUIC 则第一个数据包就可以发业务数据，从而在连接延时有很大优势，可以节约数百毫秒的时间。<br>连接迁移：一条连接由一个四元组标识，在当今移动互联网的时代，如果一台手机从一个 wifi 环境切换到另一个 wifi 环境，ip 发生变化，那么连接必须重新建立，inflight 的包全部丢失。QUIC 协议基于 UDP 实现摒弃了五元组的概念，使用 64 位的随机数作为连接的 ID，并使用该 ID 表示连接。基于 QUIC 协议之下，我们在日常 wifi 和 4G 切换时，或者不同基站之间切换都不会重连，从而提高业务层的体验。（五元组：SIP、SPort、DIP、DPort、协议号）<br><a href="https://blog.csdn.net/wolfGuiDao/article/details/108729560">https://blog.csdn.net/wolfGuiDao/article/details/108729560</a></p>
<h2 id="数据结构与算法问题"><a href="#数据结构与算法问题" class="headerlink" title="数据结构与算法问题"></a>数据结构与算法问题</h2><h3 id="实现-sleep（2022-3-字节飞书）"><a href="#实现-sleep（2022-3-字节飞书）" class="headerlink" title="实现 sleep（2022.3 字节飞书）"></a>实现 sleep（2022.3 字节飞书）</h3><h3 id="什么叫最大堆最小堆（2022-3-字节飞书）"><a href="#什么叫最大堆最小堆（2022-3-字节飞书）" class="headerlink" title="什么叫最大堆最小堆（2022.3 字节飞书）"></a>什么叫最大堆最小堆（2022.3 字节飞书）</h3><p>堆是一颗完全二叉树，树中每个结点的值都比其左右孩子的值大或小。<br>根节大于等于左右孩子就是大顶堆（从大到小），小于等于左右孩子就是小顶堆（从小到大）</p>
<h3 id="栈-stack-和堆-heap-的区别"><a href="#栈-stack-和堆-heap-的区别" class="headerlink" title="栈(stack)和堆(heap)的区别"></a>栈(stack)和堆(heap)的区别</h3><ol>
<li>空间分配：栈由操作系统自动分配释放；堆需要由程序员释放或程序结束时由 OS 回收。</li>
<li>结构区别：堆类似于一棵树，如堆排序；栈是一种先进后出的数据结构，类似于往箱子里放书取书，最先放进去的书在最底，拿出来时最后拿。</li>
<li>缓存方式：堆使用二级缓存，生命周期由虚拟机的垃圾回收算法决定；栈使用的是一级缓存，调用时处于存储空间中，调用完毕立刻释放。</li>
</ol>
<h3 id="weakMap和Map的区别（字节飞书人力套件）"><a href="#weakMap和Map的区别（字节飞书人力套件）" class="headerlink" title="weakMap和Map的区别（字节飞书人力套件）"></a>weakMap和Map的区别（字节飞书人力套件）</h3><ol>
<li>WeakMap 只接受对象作为 key，如果设置其他类型的数据作为 key，会报错。</li>
<li>WeakMap 的 key 所引用的对象都是弱引用，只要对象的其他引用被删除，垃圾回收机制就会释放该对象占用的内存，从而避免内存泄漏。</li>
<li>由于 WeakMap 的成员随时可能被垃圾回收机制回收，成员的数量不稳定，所以没有 size 属性。</li>
<li>没有 clear() 方法</li>
<li>不能遍历</li>
</ol>
<h3 id="Map和Set的区别，Map和Object的区别"><a href="#Map和Set的区别，Map和Object的区别" class="headerlink" title="Map和Set的区别，Map和Object的区别"></a>Map和Set的区别，Map和Object的区别</h3><p><a href="https://blog.csdn.net/muzidigbig/article/details/121995777">https://blog.csdn.net/muzidigbig/article/details/121995777</a></p>
<h3 id="树和图的区别"><a href="#树和图的区别" class="headerlink" title="树和图的区别"></a>树和图的区别</h3><p>一个图包含一系列的点和一系列的边。边用来把点连接起来。路线是用来描述共用一条边的点的轨迹的术语。<br>树，和图一样也是一系列点的集合。有一个根节点。这个根节点有一些子节点。子节点也有它们自己的孙子节点。不断重复直到所有的数据都被用树的数据结构表示。树是没有环的图</p>
<h3 id="递归求斐波那契数列"><a href="#递归求斐波那契数列" class="headerlink" title="递归求斐波那契数列"></a>递归求斐波那契数列</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归方式求1到100的和"><a href="#递归方式求1到100的和" class="headerlink" title="递归方式求1到100的和"></a>递归方式求1到100的和</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n， m</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = n + m;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">m + <span class="number">1</span> &gt; <span class="number">100</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(n， m + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = add(<span class="number">1</span>， <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="数组有哪些方法"><a href="#数组有哪些方法" class="headerlink" title="数组有哪些方法"></a>数组有哪些方法</h3><p>对象继承方法：数组是一种特殊的对象，继承了 Object 的这三个方法<br>toString()       返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串<br>toLocaleString() 是 toString() 方法的本地化版本，经常返回与 toString() 方法相同的值，但也不总如此<br>valueOf()        返回数组对象本身</p>
<p>转换方法：<br>concat()        连接两个或更多的数组，并返回结果。<br>copyWithin()    从数组的指定位置拷贝元素到数组的另一个指定位置中。<br>entries()        返回数组的可迭代对象。<br>every()            检测数值元素的每个元素是否都符合条件。<br>fill()            使用一个固定值来填充数组。<br>filter()        检测数值元素，并返回符合条件所有元素的数组。<br>find()            返回符合传入测试（函数）条件的数组元素。<br>findIndex()        返回符合传入测试（函数）条件的数组元素索引。<br>forEach()        数组每个元素都执行一次回调函数。<br>from()            通过给定的对象中创建一个数组。<br>includes()        判断一个数组是否包含一个指定的值。<br>indexOf()        搜索数组中的元素，并返回它所在的位置。<br>isArray()        判断对象是否为数组。<br>join()            把数组的所有元素放入一个字符串。<br>keys()            返回数组的可迭代对象，包含原始数组的键(key)。<br>lastIndexOf()    搜索数组中的元素，并返回它最后出现的位置。<br>map()            通过指定函数处理数组的每个元素，并返回处理后的数组。<br>pop()            删除数组的最后一个元素并返回删除的元素。<br>push()            向数组的末尾添加一个或更多元素，并返回新的长度。<br>reduce()        将数组元素计算为一个值（从左到右）。<br>reduceRight()    将数组元素计算为一个值（从右到左）。<br>reverse()        反转数组的元素顺序。<br>shift()            删除并返回数组的第一个元素。<br>slice()            选取数组的一部分，并返回一个新数组。<br>some()            检测数组元素中是否有元素符合指定条件。<br>sort()            对数组的元素进行排序。<br>splice()        从数组中添加或删除元素。<br>toString()        把数组转换为字符串，并返回结果。<br>unshift()        向数组的开头添加一个或更多元素，并返回新的长度。<br>valueOf()        返回数组对象的原始值。</p>
<h3 id="遍历栈和树的时间复杂度"><a href="#遍历栈和树的时间复杂度" class="headerlink" title="遍历栈和树的时间复杂度"></a>遍历栈和树的时间复杂度</h3><p>树的四种遍历方式时间复杂度和空间复杂度都为O(N)<br>栈遍历的时间复杂度是O(N)</p>
<h3 id="JS怎么遍历字符串或数组"><a href="#JS怎么遍历字符串或数组" class="headerlink" title="JS怎么遍历字符串或数组"></a>JS怎么遍历字符串或数组</h3><p>可以用 for 循环配合 charAt 函数遍历字符串。循环从 0 开始，循环次数为 str.length ，在for循环中添加 str.charAt(i) ，charAt 中的值为循环中的次数，然后将结果输出，这样字符串就被遍历出来了。<br>遍历数组包括但不限于：<br>for 循环<br>for…of<br>for…in<br>forEach()<br>entries()<br>keys()<br>values()<br>reduce()<br>map()</p>
<h2 id="性能-工程问题"><a href="#性能-工程问题" class="headerlink" title="性能 + 工程问题"></a>性能 + 工程问题</h2><h3 id="让加载更快"><a href="#让加载更快" class="headerlink" title="让加载更快"></a>让加载更快</h3><p>减少资源体积：压缩代码<br>减少访问次数：合并代码、SSR 服务器端渲染，缓存，css 雪碧图<br>减少请求数量<br>使用更快的网络：CDN，TCP 网络链路优化（花钱）<br>unpkg：提供 npm 包的 CDN 加速，可以将一些比较固定了依赖写入 html 模版中，从而提高网页的性能</p>
<h3 id="让渲染更快"><a href="#让渲染更快" class="headerlink" title="让渲染更快"></a>让渲染更快</h3><p>CSS 放在 head，JS 放在 body 最下面<br>尽早开始执行 JS，用 DOMContentLoaded 触发<br>懒加载（图片懒加载、下滑加载更多、分页器）<br>对 DOM 查询进行缓存<br>减少重绘重排，使用事件委托，将频繁的 DOM 操作，合并到一起插入到 DOM 结构<br>节流、防抖等常用性能优化方法<br>script 标签加上 defer 属性 和 async 属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。<br>defer 属性：用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。<br>async 属性：HTML5 新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。<br><a href="https://zhuanlan.zhihu.com/p/121056616">https://zhuanlan.zhihu.com/p/121056616</a><br><a href="https://juejin.cn/post/6844903657318645767">https://juejin.cn/post/6844903657318645767</a></p>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>webpack 的作用：模块打包、编译兼容、能力扩展（按需加载、代码压缩等）<br>loader 将除 js 以外的其它资源也当成 require 的资源，如图片，CSS， json， svg，字体，通过把这些非 js 资源转化为等价的 js 文件来实现<br>plugin 在 webpack 则是对整体的打包结果进行处理的一种插件机制（如混淆和压缩代码、编译时配置全局变量、自动加载模块、单独抽离样式等）<br>babel-loader 将 ES6 转化为 ES5<br>file-loader 将文件输出到一个文件夹中，在代码中通过相对URL去引用<br>url-loader 与 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中<br><a href="https://juejin.cn/post/6943468761575849992">https://juejin.cn/post/6943468761575849992</a></p>
<h3 id="有哪些常见的-loader-和-plugin"><a href="#有哪些常见的-loader-和-plugin" class="headerlink" title="有哪些常见的 loader 和 plugin"></a>有哪些常见的 loader 和 plugin</h3><p>Loader:</p>
<ul>
<li>babel-loader：把 ES6 转换成 ES5</li>
<li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li>
<li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。<br>Plugin:</li>
<li>define-plugin：定义环境变量</li>
<li>commons-chunk-plugin：提取公共代码</li>
<li>uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码</li>
</ul>
<h3 id="说一下模块打包运行原理？"><a href="#说一下模块打包运行原理？" class="headerlink" title="说一下模块打包运行原理？"></a>说一下模块打包运行原理？</h3><p>webpack 的整个打包流程：<br>1、读取 webpack 的配置参数；<br>2、启动 webpack，创建 Compiler 对象并开始解析项目；<br>3、从入口文件（entry）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；<br>4、对不同文件类型的依赖模块文件使用对应的 Loader 进行编译，最终转为 Javascript 文件；<br>5、整个过程中 webpack 会通过发布订阅模式，向外抛出一些 hooks，而 webpack 的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。</p>
<h3 id="插件和loader的区别？"><a href="#插件和loader的区别？" class="headerlink" title="插件和loader的区别？"></a>插件和loader的区别？</h3><p>Loader 是文件转换器，将 A 文件进行编译形成 B 文件，这里操作的是文件，A.less -&gt; A.css<br>plugin 是扩展器，针对的是 loader 结束后 webpack 打包的整个过程，并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。</p>
<h3 id="babel解析流程"><a href="#babel解析流程" class="headerlink" title="babel解析流程"></a>babel解析流程</h3><ol>
<li>词法解析(Lexical Analysis)</li>
<li>语法解析(Syntactic Analysis)，构建 AST（抽象语法树）</li>
</ol>
<h3 id="如何实现按需加载"><a href="#如何实现按需加载" class="headerlink" title="如何实现按需加载"></a>如何实现按需加载</h3><p>见CSDN收藏夹</p>
<h3 id="浏览器工作和渲染流程"><a href="#浏览器工作和渲染流程" class="headerlink" title="浏览器工作和渲染流程"></a>浏览器工作和渲染流程</h3><p>构建 DOM -&gt; 构建 CSSOM -&gt; 构建渲染树 -&gt; 布局 -&gt; 绘制。<br>CSSOM 会阻塞渲染，只有当 CSSOM 构建完毕后才会进入下一个阶段构建渲染树。<br>通常情况下 DOM 和 CSSOM 是并行构建的，但是当浏览器遇到一个不带 defer 或 async 属性的 script 标签时，DOM 构建将暂停，如果此时又恰巧浏览器尚未完成 CSSOM 的下载和构建，由于 JavaScript 可以修改 CSSOM，所以需要等 CSSOM 构建完毕后再执行 JS，最后才重新 DOM 构建。<br>script 脚本的执行只在默认的情况下是同步和阻塞的。 script 标签可以有 defer 和 async 属性，这可以改变脚本的执行方式（在支持他们的浏览器）</p>
<h3 id="从输入url地址栏到所有内容显示到界面上做了哪些事？"><a href="#从输入url地址栏到所有内容显示到界面上做了哪些事？" class="headerlink" title="从输入url地址栏到所有内容显示到界面上做了哪些事？"></a>从输入url地址栏到所有内容显示到界面上做了哪些事？</h3><ol>
<li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；检查缓存</li>
<li>建立 TCP 连接（三次握手）：<br> 客户端发包到服务器，等待服务器确认<br> 服务器收到并确认，同时也发送一个自己的包<br> 客户端收到服务端的包，向服务器发送确认包<br> 客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。</li>
<li>浏览器发出读取文件(URL 中域名后面部分对应的文件)的 HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</li>
<li>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</li>
<li>浏览器将该 html 文本并显示内容;</li>
<li>释放 TCP 连接（四次挥手）：<br> 客户端发出连接释放报文<br> 服务端收到连接释放报文，发出确认报文，进入等待关闭状态<br> 客户端收到服务器的确认后，必须发出确认，进入等待关闭状态<br> 服务器收到客户端发出的确认，关闭并撤销 TCP 连接<br><a href="https://blog.csdn.net/qq_34439370/article/details/107946475">https://blog.csdn.net/qq_34439370/article/details/107946475</a></li>
</ol>
<h3 id="打开网页到访问到你部署到服务整体到一个访问链路是怎么样的，结合部署的过程（我的博客用的-GitHub-Pages-部署）"><a href="#打开网页到访问到你部署到服务整体到一个访问链路是怎么样的，结合部署的过程（我的博客用的-GitHub-Pages-部署）" class="headerlink" title="打开网页到访问到你部署到服务整体到一个访问链路是怎么样的，结合部署的过程（我的博客用的 GitHub Pages 部署）"></a>打开网页到访问到你部署到服务整体到一个访问链路是怎么样的，结合部署的过程（我的博客用的 GitHub Pages 部署）</h3><p>先请求域名，代理网关判断来源，分配给最近的 CDN<br>github 密钥存在哪里？谁去请求密钥？<br>存放在当前项目的 environment。GitHub Action 请求</p>
<h3 id="docker了解吗"><a href="#docker了解吗" class="headerlink" title="docker了解吗"></a>docker了解吗</h3><p>有简单的了解，生产服务器如果有 100 台，100 台都手动配置的话，难免会出错。docker 就解决了这种开发到线上的封装部署问题。</p>
<h3 id="CommonJs和ES-Module的区别"><a href="#CommonJs和ES-Module的区别" class="headerlink" title="CommonJs和ES Module的区别"></a>CommonJs和ES Module的区别</h3><h4 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h4><ul>
<li>CommonJs 可以动态加载语句，代码发生在运行时</li>
<li>CommonJs 混合导出，还是一种语法，只不过不用声明前面对象而已，当我导出引用对象时之前的导出就被覆盖了</li>
<li>CommonJs 导出值是拷贝，可以修改导出的值，这在代码出错时，不好排查引起变量污染<h4 id="Es-Module"><a href="#Es-Module" class="headerlink" title="Es Module"></a>Es Module</h4></li>
<li>Es Module 是静态的，不可以动态加载语句，只能声明在该文件的最顶部，代码发生在编译时</li>
<li>Es Module 混合导出，单个导出，默认导出，完全互不影响</li>
<li>Es Module 导出是引用值之间都存在映射关系，并且值都是可读的，不能修改</li>
</ul>
<h3 id="前端怎样对用户的数据进行加密传输"><a href="#前端怎样对用户的数据进行加密传输" class="headerlink" title="前端怎样对用户的数据进行加密传输"></a>前端怎样对用户的数据进行加密传输</h3><p>整体看下来，前端加密是无意义的，无非说是对于后端而言，前端直接发送明文密码，还是使用 md5、decypt、sha 等加密的密文密码，从数据层面来讲，都是『明文』，只要被劫持，就算是密文，也并不需要去破解，直接伪造请求，照样发送就好了。再加上，因为前端代码是运行在用户本地浏览器，什么加密算法都是用户可见的，混淆，散列，加密无非是增大这种可见的难度，根本上并没有解决问题。<br><a href="https://juejin.cn/post/6844904074156982279">https://juejin.cn/post/6844904074156982279</a></p>
<h3 id="如何部署一个网站"><a href="#如何部署一个网站" class="headerlink" title="如何部署一个网站"></a>如何部署一个网站</h3><p>域名购买——服务器购买——服务器环境部署——上传文件到服务器</p>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="什么是MVVM框架"><a href="#什么是MVVM框架" class="headerlink" title="什么是MVVM框架"></a>什么是MVVM框架</h3><p>Model-View-ViewModel，主要目的是分离视图和模型，View 负责显示数据和发送命令，ViewMode 负责提供数据和执行命令，互不影响。</p>
<h3 id="vue的文件为什么可以在浏览器中运行呢，浏览器可以加载-vue的文件吗"><a href="#vue的文件为什么可以在浏览器中运行呢，浏览器可以加载-vue的文件吗" class="headerlink" title="vue的文件为什么可以在浏览器中运行呢，浏览器可以加载.vue的文件吗"></a>vue的文件为什么可以在浏览器中运行呢，浏览器可以加载.vue的文件吗</h3><p>因为 vue 代码是通过框架编译生成原生 js 代码才可以在浏览器中运行</p>
<h3 id="vue相比原生操作有什么不同"><a href="#vue相比原生操作有什么不同" class="headerlink" title="vue相比原生操作有什么不同"></a>vue相比原生操作有什么不同</h3><p>掩盖了操作 DOM 的细节，document.getElementById，xxx.innerHTML，文本内容的定义赋值等</p>
<h3 id="Vuex作用"><a href="#Vuex作用" class="headerlink" title="Vuex作用"></a>Vuex作用</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。可以将共享的数据保存到 Vuex 中，方便整个程序中的任何组件都可以获取和修改 Vuex 中保存的公共数据</p>
<p>每个 Vuex 应用的核心是 store，store 基本上是一个容器，包含着应用中的大部分状态。Vuex 的状态存储是响应式的，当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么响应的组件也会得到更新</p>
<p>改变 store 中状态的唯一途径是提交 mutation。这样可以方便的跟踪每个状态的变化</p>
<ul>
<li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li>
<li>Getter：允许组件从 Store 中获取数据。mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li>
<li>Mutation： 唯一更改 store 中状态的方法，且必须是同步函数。</li>
<li>Action：用于提交 Mutation，而不是直接更改状态，可以包含任意异步操作。</li>
<li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中<br>简述 Vuex 的数据传递流程<br><a href="https://vuex.vuejs.org/vuex.png">https://vuex.vuejs.org/vuex.png</a><br>当组件进行数据修改的时候我们需要调用 dispatch 来触发 actions 里面的方法。actions 里面的每个方法中都会有一个commit 方法，当方法执行的时候会通过 commit 来触发 mutations 里面的方法进行数据的修改。mutations 里面的每个函数都会有一个 state 参数，这样就可以在 mutations 里面进行 state 的数据修改，当数据修改完毕后，会传导给页面。页面的数据也会发生改变</li>
</ul>
<h3 id="聊聊双向绑定"><a href="#聊聊双向绑定" class="headerlink" title="聊聊双向绑定"></a>聊聊双向绑定</h3><p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，核心是通过 ES5（所以vue不支持 IE8 及以下）的 Object.defineProperty() 来劫持各个属性的 setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>实现数据监听器 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者<br>实现一个指令解析器 Compile<br>实现一个 Watcher，作为 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图<br>Mvvm 入口函数，整合以上三者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;userName&quot;</span> /&gt;</span><br><span class="line">&lt;input v-bind:value=<span class="string">&quot;userName&quot;</span> v-on:input=<span class="string">&quot;userName = $event.target.value&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>第一行的代码其实只是第二行的语法糖。input 元素本身有个 oninput 属性，这是 HTML5 新增的，类似 onchdange，每当输入框的内容发生变化，就会触发 oninput</p>
<h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><p>beforeCreate 阶段：vue 实例的挂载元素 el 和数据对象 data 都是 undefined，还没有初始化。<br>created 阶段：vue 实例的数据对象 data 有了，可以访问里面的数据和方法。未挂载到 DOM，el 还没有<br>beforeMount 阶段：vue 实例的 el 和 data 都初始化了，但是挂载之前为虚拟的 dom 节点<br>mounted 阶段：vue 实例挂载到真实 DOM 上，就可以获取 DOM 节点<br>beforeUpdate 阶段：响应式数据更新时调用，发生在虚拟 DOM 打补丁之前，适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器<br>updated 阶段：虚拟 DOM 重新渲染和打补丁之后调用，组成新的 DOM 已经更新，避免在这个钩子函数中操作数据，防止死循环<br>beforeDestroy 阶段：实例销毁前调用，实例还可以用，this 能获取到实例，常用于销毁定时器，解绑事件<br>destroyed 阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁<br>axios 放在哪个生命周期函数下？<br>在 vue 的 mounted 生命周期使用，mounted 在 html 加载完成后执行。因此进行网络数据查询，需要更新视图的只能在 mounted 生命周期里写。</p>
<h3 id="Vue2和3生命周期的区别？"><a href="#Vue2和3生命周期的区别？" class="headerlink" title="Vue2和3生命周期的区别？"></a>Vue2和3生命周期的区别？</h3><p>整体都一样，Vue3 只不过有了新的命名：beforeDestroy 变成了beforeUnmounted；destroy 变成了 unmounted，名字变了但是原理没变。<br>Vue3 增加了 setup()，它是在 beforeCreate 和 created 之前运行的，可以用它来代替这两个钩子函数。</p>
<h3 id="Vue3的组合式API是什么？"><a href="#Vue3的组合式API是什么？" class="headerlink" title="Vue3的组合式API是什么？"></a>Vue3的组合式API是什么？</h3><p>将同个逻辑的代码配置在一起，提高代码的可维护性和可读性。</p>
<h3 id="keep-alive做了什么，对生命周期有什么影响"><a href="#keep-alive做了什么，对生命周期有什么影响" class="headerlink" title="keep alive做了什么，对生命周期有什么影响"></a>keep alive做了什么，对生命周期有什么影响</h3><p>keep-alive 是 vue 内置的一个组件，可以被包含的组件保留状态，或避免重新渲染。（页面缓存）<br>总结来说，keep-alive 实现原理就是将对应的状态放入一个缓存对象中，对应的 DOM 节点放入缓存 DOM 中，当下次再次需要渲染时，从对象中获取状态，从缓存 DOM 中移出至挂载 DOM 节点中。</p>
<p>activated 和 deactivated<br>keep-alive 的生命周期</p>
<ol>
<li>activated： 页面第一次进入的时候，钩子触发的顺序是 created -&gt; mounted -&gt; activated</li>
<li>deactivated: 页面退出的时候会触发 deactivated，当再次前进或者后退的时候只触发 activated</li>
</ol>
<h3 id="说说nextTick的用处和原理？"><a href="#说说nextTick的用处和原理？" class="headerlink" title="说说nextTick的用处和原理？"></a>说说nextTick的用处和原理？</h3><p>nextTick 是 Vue 提供的一个全局 API，由于 vue 的异步更新策略导致我们对数据的修改不会立刻体现在 DOM 变化上，此时如果想要立即获取更新后的 DOM 状态，就需要使用这个方法。<br>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick 方法会在队列中加入一个回调函数，确保该函数在前面的 dom 操作完成后才调用。<br>所以当我们想在修改数据后立即看到 DOM 执行结果就需要用到 nextTick 方法。比如，我在干什么的时候就会使用 nextTick 传一个回调函数进去，在里面执行 DOM 操作即可。<br>简单了解 nextTick 实现：它会在 callbacks 里面加入我们传入的函数然后用 timerFunc 异步方式调用它们，首选的异步方式会是 Promise。Promise 是微任务，微任务因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕。（把传入的操作包装成异步微任务）</p>
<blockquote>
<p>为什么数据更新不会立刻变化 DOM？<br>vue 的响应式是按一定策略进行 DOM 更新的，vue 在修改数据后，会等同一事件循环中的所有数据变化完成以后，再统一进行视图更新。同步里执行的方法，每个方法里做的事情组成一个事件循环，接下来再次调用的是另一个事件循环。</p>
</blockquote>
<h3 id="set的功能"><a href="#set的功能" class="headerlink" title="$set的功能"></a>$set的功能</h3><p>this.$set( target, key, value ) target：表示数据源，即是要操作的数组或者对象，key：要操作的的字段，value：更改的数据。<br>给一个对象添加属性并且让它可以响应式的进行改变。<br>原理：使用 Object.defineProperty 给对象的属性增加了 setter 和 getter，使 vue 能追踪属性，在他们发生修改时通知视图变更。</p>
<h3 id="ref-与-reactive-的功能与区别？"><a href="#ref-与-reactive-的功能与区别？" class="headerlink" title="ref 与 reactive 的功能与区别？"></a>ref 与 reactive 的功能与区别？</h3><p>ref 将基本数据类型的变量转变为响应式，reactive 将复杂数据类型转变为响应式，底层使用了 Proxy。</p>
<h3 id="toRef-s-的功能？"><a href="#toRef-s-的功能？" class="headerlink" title="toRef(s)的功能？"></a>toRef(s)的功能？</h3><p>将响应式对象转变为普通对象，但每个（某一个）属性都是 Ref 对象。</p>
<h3 id="除了v-model和v-bind还有哪些命令？有哪些常用修饰符？"><a href="#除了v-model和v-bind还有哪些命令？有哪些常用修饰符？" class="headerlink" title="除了v-model和v-bind还有哪些命令？有哪些常用修饰符？"></a>除了v-model和v-bind还有哪些命令？有哪些常用修饰符？</h3><p>v-show、v-if/v-else/v-else-if、v-for、v-text、v-html<br>.lazy（减少触发次数。在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步。你可以添加 lazy 修饰符，相当于在onchange事件触发更新。）<br>.trim<br>.number<br>.once</p>
<h3 id="父子组件怎么传值"><a href="#父子组件怎么传值" class="headerlink" title="父子组件怎么传值"></a>父子组件怎么传值</h3><ol>
<li>父向子传值 props</li>
<li>子组件向父组件传值 $emit</li>
<li>父组件调用子组件的方法通过 ref，在 DOM 元素上使用 $refs 可以迅速进行 dom 定位，类似于 $(“selectId”)，使用 this.$refs.paramsName 能更快的获取操作子组件属性值或函数。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。</li>
<li>$parent / $children / $root：访问父 / 子实例 / 根实例，我们可以使用 $children[i].paramsName 来获取某个子组件的属性值或函数，$children 返回的是一个子组件数组</li>
<li>vue 全局事件 (eventBus)，在 main.js 里：window.eventBus = new Vue(); // 注册全局事件对象</li>
<li>兄弟、父子、隔代之间的传值用 Vuex，在 state 里定义数据和属性，在 mutations 里定义函数 fn，在页面通过 this.$store.commit(‘fn’，params) 来触发函数</li>
</ol>
<h3 id="在Vue中，子组件为何不可以修改父组件传递的Prop"><a href="#在Vue中，子组件为何不可以修改父组件传递的Prop" class="headerlink" title="在Vue中，子组件为何不可以修改父组件传递的Prop"></a>在Vue中，子组件为何不可以修改父组件传递的Prop</h3><p>一个父组件下不只有一个子组件。<br>同样，使用这份 prop 数据的也不只有一个子组件。<br>如果每个子组件都能修改 prop 的话，将会导致修改数据的源头不止一处。<br>所以我们需要将修改数据的源头统一为父组件，子组件想要改 prop 只能委托父组件帮它。从而保证数据修改源唯一。</p>
<h3 id="为什么不建议用index作为key的值"><a href="#为什么不建议用index作为key的值" class="headerlink" title="为什么不建议用index作为key的值"></a>为什么不建议用index作为key的值</h3><p>当对数组进行下标有关的操作时，比如删除一个值，后面的值的 index 都会发生变化，那么 key 值自然也跟着全部发生改变。<br>在平时的开发过程中, 因为我们的数据绝大部分都是从后台获取来的. 数据库中每一条数据都会一个 id 作为唯一标识，而这个 id 也是我们最常使用作为 key 值的来源。<br>vue 列表渲染中的 key 主要用于 diff，在新旧 nodes 对比时辨识 VNodes，基于 key 的变化重新排列元素顺序。不同的 key 组件不会复用，相同的 key 组件复用<br>当页面的数据发生变化时，Diff 算法只会比较同一层级的节点：<br>如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。<br>如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新。<br>当某一层有很多相同的节点时，也就是列表节点时，Diff 算法的更新过程默认情况下也是遵循以上原则。</p>
<h3 id="Vue-的响应式原理中-Object-defineProperty-有什么缺陷？为什么在-Vue3-0-采用了-Proxy，抛弃了-Object-defineProperty？"><a href="#Vue-的响应式原理中-Object-defineProperty-有什么缺陷？为什么在-Vue3-0-采用了-Proxy，抛弃了-Object-defineProperty？" class="headerlink" title="Vue 的响应式原理中 Object.defineProperty 有什么缺陷？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？"></a>Vue 的响应式原理中 Object.defineProperty 有什么缺陷？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？</h3><ol>
<li>Object.defineProperty 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；</li>
<li>Object.defineProperty 只能监听基本数据类型，或复杂数据类型的最外层，我们直接修改一个对象内的某个属性，或者给数组 push 一条数据，都不会触发内部的 set 和 get。从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy 可以劫持整个对象，并返回一个新的对象。</li>
<li>Proxy 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。<br><a href="https://blog.csdn.net/qq_46193451/article/details/114704778">https://blog.csdn.net/qq_46193451/article/details/114704778</a></li>
</ol>
<h3 id="Vue2的Mixins？"><a href="#Vue2的Mixins？" class="headerlink" title="Vue2的Mixins？"></a>Vue2的Mixins？</h3><p>Mixins 是在引入组件之后，则是将组件内部的内容如 data 等方法、method 等属性与父组件相应内容进行合并。相当于在引入后，父组件的各种属性方法都被扩充了。如果在引用 mixins 的同时，在组件中重复定义相同的方法，则 mixins 中的方法会被覆盖。</p>
<h3 id="讲一下-sync修饰符"><a href="#讲一下-sync修饰符" class="headerlink" title="讲一下.sync修饰符"></a>讲一下.sync修饰符</h3><p>是一种语法糖，与我们平常使用 $emit 实现父子组件通信没有区别，简化了父组件监听子组件并更新本地数据的写法</p>
<h3 id="为什么vue中的data要用return返回"><a href="#为什么vue中的data要用return返回" class="headerlink" title="为什么vue中的data要用return返回"></a>为什么vue中的data要用return返回</h3><p>组件是可复用的 vue 实例，当存在多个相同组件被引用，其实都是基于同一份对象进行构建，如果不使用 retuen 返回，则这些组件 data 都会指向同一个对象，会互相影响。使用函数就可以使变量只在当前组件生效，此时组件之间的 data 互不干扰。</p>
<h3 id="Vue模板编译原理"><a href="#Vue模板编译原理" class="headerlink" title="Vue模板编译原理"></a>Vue模板编译原理</h3><p>主要逻辑分三步</p>
<ul>
<li>第一步是将 模板字符串 转换成 element ASTs，是一个 JS 对象（解析器）</li>
<li>第二步是对 AST 进行静态节点标记，即 DOM 不需要发生变化的节点，主要用来做虚拟 DOM 的渲染优化（优化器）</li>
<li>第三步是 使用 element ASTs 生成 render 函数代码字符串（代码生成器）<br><a href="https://segmentfault.com/a/1190000013763590">https://segmentfault.com/a/1190000013763590</a></li>
</ul>
<h3 id="Vue路由守卫？（路由的生命周期）"><a href="#Vue路由守卫？（路由的生命周期）" class="headerlink" title="Vue路由守卫？（路由的生命周期）"></a>Vue路由守卫？（路由的生命周期）</h3><p>导航守卫就是路由跳转过程中的一些钩子函数。路由跳转是一个大的过程，这个大的过程分为跳转前中后等等细小的过程，在每一个过程中都有一函数，这个函数能让你操作一些其他的事，这就是导航守卫。类似于组件生命周期钩子函数。<br><a href="https://juejin.cn/post/6844903924760051725">https://juejin.cn/post/6844903924760051725</a></p>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="Vue和React的不同"><a href="#Vue和React的不同" class="headerlink" title="Vue和React的不同"></a>Vue和React的不同</h3><ol>
<li>数据流的不同<br>React 从诞生之初就不支持双向绑定，React 一直提倡的是单向数据流，称之为 onChange/setState() 模式，在 setState 后会重新渲染。Vue 的响应式思想基于数据可变，父子组件之间 props 单向流动，但是组件与 DOM 之间可以通过 v-model 双向绑定<br>React 的性能优化需要手动去做，而 Vue 的性能优化是自动的</li>
<li>模板渲染思想不同<br>React 的思想是 all in js，所以设计了 tsx。而 Vue 是在和组件 JS 代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现，html 还可以通过模板引擎处理。</li>
<li>React 通过高阶组件来扩展组件，React 组件本身就是函数，所以高阶组件对 React 很容易。Vue 则用 Mixin，因为 Vue 组件是一个被包装好的函数，比如模板的编译和 Props 的传递，如果自己直接把组件的声明包装一下返回一个高阶组件，那么这个被包装的组件就无法正常工作了。Vue 使用 Mixin 来扩展组件。</li>
</ol>
<h3 id="Redux-介绍和如何使用"><a href="#Redux-介绍和如何使用" class="headerlink" title="Redux 介绍和如何使用"></a>Redux 介绍和如何使用</h3><p>redux 是为了解决 react 中组件与组件之间数据传递的问题。是一个全局的数据中心，监听 state 变更并将数据传递给下层组件<br>组建于组件之间的传递有三种情况：</p>
<ol>
<li>父组件传递数据给子组件：由于 redux 是一个单向数据流的框架，所以它的 props 就只能由父组件传递给子组件；</li>
<li>子组件传递给父组件：而子组件想父组件的传值的话则需要使用回调函数，</li>
<li>子组件与子组件：那么子组件与子组件之间的传递则相当麻烦，需要先将子组件的值传递给父组件，然后再由父组件在分发给指定的子组件，而 redux 则是解决这种问题的。<br>使用情况：非父子组件之间需要共享一些状态。需要将状态提升到最近的祖先</li>
</ol>
<p>用法<br>引入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/redux@4.0.4/dist/redux.js&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创造一个 store</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> store = Redux.createStore(<span class="function">(<span class="params">state， action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;，state)</span><br></pre></td></tr></table></figure>
<p>第一个参数是一个 reducer 函数，函数有 2 个参数，state 表示储存的数据，action 是一个对象，子组件里面通过 dispatch 函数来传递这个对象，这个 reducer 函数通过 action 的信息来触发对 state 的相关操作，返回一个新的 state<br>创建的 store 上面有两个常用的方法，dispatch 和 subscribe 方法<br>dispatch，传递给下层组件，下层组件利用这个方法操作 state 触发更新<br>subscribe，用来监听 state 变更<br>var unSubscribe = store.subscribe(fn)<br>数据变更时 fn 会运行，这个 fn 不接参数，并返回一个函数 unSubscribe<br>调用 unSubscribe 就会把这次的监听函数 subscribe 解绑</p>
<h3 id="Vuex和Redux各自的特点？"><a href="#Vuex和Redux各自的特点？" class="headerlink" title="Vuex和Redux各自的特点？"></a>Vuex和Redux各自的特点？</h3><ul>
<li>Vuex 是针对 Vue 特化的，Redux 则是一个泛用的实现，和 Vue 的契合度不如 Vuex</li>
<li>由于上一个原因，Vuex 的 API 比 Redux 更为简洁，Redux 必须依赖第三方库才能相对高效率地获得状态树的局部状态，而 Vuex 直接使用 Vue 的计算属性就行</li>
</ul>
<h3 id="React如何实现数据绑定"><a href="#React如何实现数据绑定" class="headerlink" title="React如何实现数据绑定"></a>React如何实现数据绑定</h3><p>在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。可以通过 shouldComponentUpdate 这个生命周期进行控制 pureRender<br>通过 JSX 中标签加属性实现视图和数据的绑定，类组件中 render 里的大括号动态传递 state，this.state 记录数据状态，函数组件中则使用 hooks 管理状态（个人理解，不知道对不对）<br>Vue 实现数据绑定考的是数据劫持（Object.defineProperty()） + 发布-订阅模式。在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件需要被被重新渲染。可以理解为每一个组件都已经自动获得了 shouldComponentUpdate，并且没有上面的子树问题限制</p>
<h3 id="React如何在重新加载页面时保留数据？"><a href="#React如何在重新加载页面时保留数据？" class="headerlink" title="React如何在重新加载页面时保留数据？"></a>React如何在重新加载页面时保留数据？</h3><p>使用浏览器 localstorage 来保存应用程序的状态。我们将整个存储数据保存在 localstorage 中，每当有页面刷新或重新加载时，我们从 localstorage 加载状态。</p>
<h3 id="state-和-props-的区别"><a href="#state-和-props-的区别" class="headerlink" title="state 和 props 的区别"></a>state 和 props 的区别</h3><p>state 是组件自己管理数据，控制自己的状态，可变，必须通过 setState 更改。<br>props 是外部传入的数据参数，不可变，父组件通过传递 props 给子组件来更新视图，子组件不能将 prop 送回父组件。这有助于维护单向数据流，通常用于呈现动态生成的数据。</p>
<h3 id="简述虚拟DOM和diff算法"><a href="#简述虚拟DOM和diff算法" class="headerlink" title="简述虚拟DOM和diff算法"></a>简述虚拟DOM和diff算法</h3><p>无 key 时，如果两棵树的根元素类型不同，React 会销毁旧树，创建新树。对于类型相同的 React DOM 元素，只更新不同的属性，如果类型不同，直接替换。当处理完这个 DOM 节点，React 就会递归处理子节点。比较内容，如果有不同直接替换。<br>有 key 时，如果 key 相同，组件有所变化，React 会只更新组件对应变化的属性；如果 key 不同，组件会销毁之前的组件，将整个组件重新渲染。<br>使用 React 要注意的一点是，Key 值必须是稳定的, 可预测并且是唯一的，这里给我们性能优化提供了两个非常重要的依据：</p>
<ul>
<li>保持 DOM 结构的稳定性</li>
<li>加唯一 key 值<br>虚拟 DOM 是 JS 和真实 DOM 之间的一个缓存，可以看作是一个使用 javascript 模拟了 DOM 结构的树形结构，这个树结构包含整个 DOM 结构的信息。利用 diff 算法比较虚拟 DOM 和真实 DOM 的不同后根据 diff 算法的替换规则更改真实 DOM，因为操作 DOM 非常耗费性能，所以虚拟 DOM 和 diff 算法是提高性能的一个重要方法。</li>
</ul>
<h3 id="Virtual-Dom的优势在哪里？"><a href="#Virtual-Dom的优势在哪里？" class="headerlink" title="Virtual Dom的优势在哪里？"></a>Virtual Dom的优势在哪里？</h3><p>DOM 引擎、JS 引擎 相互独立，但又工作在同一线程（主线程）</p>
<h3 id="函数组件和类组件"><a href="#函数组件和类组件" class="headerlink" title="函数组件和类组件"></a>函数组件和类组件</h3><p>函数组件是一个纯函数，接收参数并返回 React 元素，并且没有任何副作用。没有生命周期函数和 state。<br>通过 class xx extends React.Component 这类组件可以通过 setState() 来改变组件的状态，并且可以使用生命周期函数</p>
<p>定义组件时，复杂场景用类组件，简单场景用函数组件。<br>简单：一个组件仅仅是为了展示数据。<br>复杂：一个组件中有一定业务逻辑，需要操作数据，并且此时需要使用 state。</p>
<p>什么是纯函数？</p>
<ol>
<li>函数的返回结果只依赖于它的参数。</li>
<li>不改变函数体外部数据，函数执行过程里面没有副作用。</li>
</ol>
<p>Redux 三大原则</p>
<ol>
<li>单一数据流：整个应用 state 都被储存在一个 store 里面 构成一个 Object tree</li>
<li>state 是只读的：唯一改变 state 的方法就是触发 action, action 是一个用于描述已发生事件的普通对象</li>
<li>使用纯函数来执行修改：为了描述 action 如何改变 state tree， 你需要编写 reducers<br>Redux 的设计思想就是不产生副作用，使数据的更改状态可回溯。只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用、没有 API 请求、没有变量修改，单纯执行计算。</li>
</ol>
<h3 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h3><p>在 HTML 当中，像 input，textarea 和 select 这类表单元素会维持自身状态，并根据用户输入进行更新。 在 React 中，可变的状态通常保存在组件的 state 中，并且只能用 setState() 方法进行更新. React 根据初始状态渲染表单组件，接受用户后续输入，改变表单组件内部的状态。因此，将那些值由 React 控制的表单元素称为受控组件。</p>
<p>受控组件的特点：</p>
<ol>
<li>表单元素</li>
<li>由 React 通过 JSX 渲染出来</li>
<li>由 React 控制值的改变，想要改变元素的值，只能通过 React 提供的方法来修改</li>
</ol>
<p>非受控组件的状态是不受 React 控制的，而是组件本身具有的</p>
<p>非受控 -&gt; 受控组件的转化<br>首先把状态绑定到非受控组件的 value、checked 上。<br>然后监听该组件的 onChange 事件 用 e.target 获取 input 上面的数据 然后通过 setState 设置数据给 state 内的数据。</p>
<h3 id="Hooks及常用API"><a href="#Hooks及常用API" class="headerlink" title="Hooks及常用API"></a>Hooks及常用API</h3><ol>
<li>基础API<br> useState：通过在函数组件里调用它来给组件添加一些内部 state。React 会在重复渲染时保留这<br> state。useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并。<br> useEffect：在函数组件中执行副作用操作（副作用：和函数业务主逻辑关联不大，特定时间或事件中执行的动作，比如Ajax 请求后端数据，添加登录监听或取消登录、手动修改DOM等），useEffect 在每次 state 更新时执行，主要用来代替常用的生命周期函数。<br> useContext：与 Context 一样，是 React Hooks 中提供的更加高级的一种组件中传递值的方式，不再需要一层一层的向下传递 props，而是可以隔层传递。</li>
<li>其他的API<br> useReducer<br> useCallback<br> useMemo<br> useRef<br> useImperativeMethods<br> useLayoutEffect</li>
</ol>
<h3 id="useState、useEffect、useContext怎么用"><a href="#useState、useEffect、useContext怎么用" class="headerlink" title="useState、useEffect、useContext怎么用"></a>useState、useEffect、useContext怎么用</h3><ol>
<li>useState 函数（状态钩子），接收的参数会设置为 state 的初始值，返回一个数组 [state, 操作 state 的函数 setState]</li>
<li>useEffect 函数（生命周期钩子），相当于一个生命周期函数 componentDidMount 或 componentDidUpdate，直接在函数组件内部使用，每次渲染时都会调用。<br>第一个参数是一个函数，可以挂载 componentDidMount 或 componentDidUpdate 阶段需要的操作。这个函数可以有一个返回值函数，返回值函数会在函数组件 componentWillUnmount 阶段运行，可有挂载一些解绑操作；对于函数组件来讲，每次更新都会卸载再挂载；所以每次更新都会运行这个返回值函数。第二个参数见下面</li>
<li>useContext 先在外部创建一个 context 实例 var ColorContext = React.createContext()，Context 实例对象上面有个 ColorContext.Provider 组件开始向下传递数据，用于组件内部，如 &lt;ColorContext.Provider value={color}&gt;<br>接收数据方法<br>在后代组件中直接使用 useContext(Context 实例对象）接收数据。var color = useContext(ColorContext) 接收数据</li>
</ol>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>避免在 循环/条件判断/嵌套函数 中调用 hooks，保证调用顺序的稳定；<br>不能在 useEffect 中使用 useState，React 会报错提示；<br>类组件不会被替换或废弃，不需要强制改造类组件，两种方式能并存</p>
<h3 id="useEffect无限调用、第二个参数是什么"><a href="#useEffect无限调用、第二个参数是什么" class="headerlink" title="useEffect无限调用、第二个参数是什么"></a>useEffect无限调用、第二个参数是什么</h3><p>当你在 useEffect 中监听对象或数组的时候，它会无条件无限执行.你可以理解为引用数据类型数据在监听时每次都生成了一个新的数据.所以必定会执行。要监听的对象修改后的值不同于修改前的就会执行，但是每次执行时监听对象都会变化，将会无限次执行。</p>
<p>解决办法</p>
<ol>
<li>同步更新一个可检测的数据，然后监听这个数据</li>
<li>假如知道数据的走向，并且可以准确找到临界点，可以通过判断来打断无限更新的流程</li>
<li>对象监听，通过监听对象属性来判断对象变化，不符合监听规则就不无限执行</li>
</ol>
<p>第二个可选参数是一个数组，是要监听的数据，当组件刷新时如果发现数组的内容和上一次一样，那么就不会运行这个 useEffect 函数，用于性能优化；要确保数组中包含了外部作用域中会随时间变化并且在 effect 中使用的变量，否则你的代码会引用到先前渲染中的旧变量，如果是空数组表示每次都是完全一样的内容，不运行</p>
<h3 id="useEffect的作用，为什么在组件内部调用useEffect"><a href="#useEffect的作用，为什么在组件内部调用useEffect" class="headerlink" title="useEffect的作用，为什么在组件内部调用useEffect"></a>useEffect的作用，为什么在组件内部调用useEffect</h3><ol>
<li>通过调用 useEffect，你可以告诉 React 组件需要在渲染后执行某些操作。React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。在这个 effect 中，我们设置了 document 的 title 属性，不过我们也可以执行数据获取或调用其他命令式的 API。</li>
<li>与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。</li>
</ol>
<h3 id="useEffect什么时候会执行"><a href="#useEffect什么时候会执行" class="headerlink" title="useEffect什么时候会执行"></a>useEffect什么时候会执行</h3><p>在默认情况下、useEffect 在第一次渲染之后和每次更新之后都会执行。你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。</p>
<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p>在使用 useState 时，修改值时传入同样的值，组件不会重新渲染。<br>只会在当前组件的第一次渲染执行 useState 函数。<br>setUseState 时获取上一轮的值：我们在使用 useState 的第二个参数时，我们想要获取上一轮该 state 的值的话，只需要在 useState 返回的第二个参数，</p>
<p>就是我们上面的例子中的 setCount 使用时，传入一个参数，该函数的参数就是上一轮的 state 的值。</p>
<h3 id="Hooks相对普通Class有什么优势"><a href="#Hooks相对普通Class有什么优势" class="headerlink" title="Hooks相对普通Class有什么优势"></a>Hooks相对普通Class有什么优势</h3><p>简化代码：声明一个简单的组件只要简单的几行代码；<br>容易上手：对于初学者来说，相对复杂的 class 的声明周期，hooks 的钩子函数更好理解；<br>简化业务：充分利用组件化的思想把业务拆分成多个组件，便于维护；<br>方便数据管理：相当于三种的提升，各个组件不用通过非常复杂的 props 多层传输，解耦操作；<br>便于重构：业务改变或者接手别人的代码，代码都是比较容易读懂；</p>
<h3 id="什么情况下使用Class，什么情况下使用Hooks"><a href="#什么情况下使用Class，什么情况下使用Hooks" class="headerlink" title="什么情况下使用Class，什么情况下使用Hooks"></a>什么情况下使用Class，什么情况下使用Hooks</h3><h3 id="React-怎么获取到组件的-DOM"><a href="#React-怎么获取到组件的-DOM" class="headerlink" title="React 怎么获取到组件的 DOM"></a>React 怎么获取到组件的 DOM</h3><p>获取 DOM 是 ReactDOM.findDOMNode(this.refs.box_table)；<br>而 this.refs.box_table 直接取到的是组件，可以直接调用其内部的方法。</p>
<h3 id="React的生命周期方法有哪些"><a href="#React的生命周期方法有哪些" class="headerlink" title="React的生命周期方法有哪些"></a>React的生命周期方法有哪些</h3><p>componentWillMount:在渲染之前执行，用于根组件中的 App 级配置。<br>componentDidMount：在第一次渲染之后执行，可以在这里做 AJAX 请求，DOM 的操作或状态更新以及设置事件监听器。<br>componentWillReceiveProps：在初始化 render 的时候不会执行，它会在组件接受到新的 Props 时被触发，一般用于组件状态更新时子组件的重新渲染<br>shouldComponentUpdate：确定是否更新组件。默认情况下，它返回 true。如果确定在 state 或 props 更新后组件在重新渲染，则可以返回false，这是一个提高性能的方法。<br>componentWillUpdate：在 shouldComponentUpdate 返回 true 确定要更新组件之前件之前执行。<br>componentDidUpdate：它主要用于更新 DOM 以响应 props 或 state 更改。<br>componentWillUnmount：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器</p>
<h3 id="JXS是什么，有什么优势"><a href="#JXS是什么，有什么优势" class="headerlink" title="JXS是什么，有什么优势"></a>JXS是什么，有什么优势</h3><p>JSX 是 JavaScript 的语法扩展<br>增强 js 语义、结构清晰、抽象程度高（诞生了跨平台 React Native）、代码模块化</p>
<h3 id="setState有哪些使用方式"><a href="#setState有哪些使用方式" class="headerlink" title="setState有哪些使用方式"></a>setState有哪些使用方式</h3><ol>
<li>传入新的 state 对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  age: <span class="number">2</span>，</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>传入回调函数，并在回调函数里面返回新的 state 对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">prevState， props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age: prevState.age + props.age，</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="可以在Class组件里写Hook吗"><a href="#可以在Class组件里写Hook吗" class="headerlink" title="可以在Class组件里写Hook吗"></a>可以在Class组件里写Hook吗</h3><h3 id="React组件间的通信"><a href="#React组件间的通信" class="headerlink" title="React组件间的通信"></a>React组件间的通信</h3><p>父组件向子组件通信：props<br>子组件向父组件通信：回调函数<br>跨级组件通信：context、useContext、redux<br>没有嵌套关系的组件通信：eventEmitter，利用全局对象来保存事件，用广播的方式去处理事件。</p>
<h3 id="原生事件和React事件的区别"><a href="#原生事件和React事件的区别" class="headerlink" title="原生事件和React事件的区别"></a>原生事件和React事件的区别</h3><ul>
<li>React 事件使用驼峰命名，而不是全部小写。</li>
<li>通过 JSX, 你传递一个函数作为事件处理程序，而不是一个字符串。</li>
<li>在 React 中你不能通过返回 false 来阻止默认行为。必须明确调用 preventDefault。</li>
</ul>
<h3 id="什么是HOC，有什么好处和应用场景"><a href="#什么是HOC，有什么好处和应用场景" class="headerlink" title="什么是HOC，有什么好处和应用场景"></a>什么是HOC，有什么好处和应用场景</h3><p>高阶组件和高阶函数相同。我们实现一个函数，传入一个组件，然后在函数内部再实现一个函数去扩展传入的组件，最后返回一个新的组件，这就是高阶组件的概念，作用就是为了更好的复用代码。<br>常用场景：权限控制、组件性能渲染追踪、页面复用</p>
<h3 id="useInterval和useDebounce"><a href="#useInterval和useDebounce" class="headerlink" title="useInterval和useDebounce"></a>useInterval和useDebounce</h3><p>useDebounce 钩子可让你消除任何快速变化的值。当在指定的时间段内未调用 useDebounce 钩子时，去抖动的值将仅反映最新的值。 你可以轻松地确保诸如 API 调用之类的昂贵操作不会过于频繁地执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDebounce</span>(<span class="params">value, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [debouncedValue, setDebouncedValue] = useState(value);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setDebouncedValue(value);</span><br><span class="line">    &#125;, delay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(handler);</span><br><span class="line">    &#125;;</span><br><span class="line">    &#125;, [value, delay]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> debouncedValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>useInterval 设置了一个计时器，并且在组件 unmount 的时候清理掉了。 这是通过组件生命周期上绑定 setInterval 与 clearInterval 的组合完成的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useInterval</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> savedCallback = useRef();</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// Remember the latest callback.</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    savedCallback.current = callback;</span><br><span class="line">  &#125;);</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// Set up the interval.</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      savedCallback.current();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (delay !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> id = <span class="built_in">setInterval</span>(tick, delay);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [delay]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见场景和解决方案"><a href="#常见场景和解决方案" class="headerlink" title="常见场景和解决方案"></a>常见场景和解决方案</h2><h4 id="前端文件下载"><a href="#前端文件下载" class="headerlink" title="前端文件下载"></a>前端文件下载</h4><ol>
<li>form表单提交。为一个下载按钮添加 click 事件，点击时动态生成一个表单，利用表单提交的功能来实现文件的下载</li>
<li>a 标签的 download</li>
<li>Blob 对象。调用 api，将文件流转为 Blob 二进制对象，IE10 以下不支持</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="为什么选择前端，平时是怎么学习的？"><a href="#为什么选择前端，平时是怎么学习的？" class="headerlink" title="为什么选择前端，平时是怎么学习的？"></a>为什么选择前端，平时是怎么学习的？</h3><h3 id="你遇到最难的问题是怎样的？"><a href="#你遇到最难的问题是怎样的？" class="headerlink" title="你遇到最难的问题是怎样的？"></a>你遇到最难的问题是怎样的？</h3><h3 id="你在团队的突出贡献是什么？"><a href="#你在团队的突出贡献是什么？" class="headerlink" title="你在团队的突出贡献是什么？"></a>你在团队的突出贡献是什么？</h3><h3 id="最近在关注什么新技术"><a href="#最近在关注什么新技术" class="headerlink" title="最近在关注什么新技术"></a>最近在关注什么新技术</h3><h3 id="lodash有什么印象深刻的"><a href="#lodash有什么印象深刻的" class="headerlink" title="lodash有什么印象深刻的"></a>lodash有什么印象深刻的</h3><p>chunk，将数组进行切分<br>compact，去除假值（将所有的空值，0，NaN 过滤掉）<br>uniq，数组去重。（将数组中的对象去重，只能去重数组不能去重对象）<br>merge，参数合并</p>
<h3 id="平时看代码的习惯-看代码有什么要点"><a href="#平时看代码的习惯-看代码有什么要点" class="headerlink" title="平时看代码的习惯/看代码有什么要点"></a>平时看代码的习惯/看代码有什么要点</h3><ul>
<li>声明不看（用到再看）</li>
<li>if 先不看（但 if else 要看）</li>
<li>函数调用必看<h3 id="对-TS-有多少了解？"><a href="#对-TS-有多少了解？" class="headerlink" title="对 TS 有多少了解？"></a>对 TS 有多少了解？</h3>更好的参数和返回值提示<br>类型推断<br>泛型：一个组件支持多种类型<br>类型定义：可以把公用的数据类型单独写一个文件<h3 id="node-js是怎么运行js的，跟浏览器环境的js有什么区别？"><a href="#node-js是怎么运行js的，跟浏览器环境的js有什么区别？" class="headerlink" title="node.js是怎么运行js的，跟浏览器环境的js有什么区别？"></a>node.js是怎么运行js的，跟浏览器环境的js有什么区别？</h3>在控制台输入 node 就可以进入 node 代码执行与编辑模式，原理还没了解<br>区别：</li>
</ul>
<ol>
<li>全局环境下this的指向</li>
<li>js引擎</li>
<li>DOM 操作</li>
<li>I/O 读写</li>
<li>模块加载<br><a href="https://www.cnblogs.com/webARM/p/5004595.html">https://www.cnblogs.com/webARM/p/5004595.html</a><h3 id="你觉得node-js的底层是什么？"><a href="#你觉得node-js的底层是什么？" class="headerlink" title="你觉得node.js的底层是什么？"></a>你觉得node.js的底层是什么？</h3><h3 id="如何入手熟悉一个项目？"><a href="#如何入手熟悉一个项目？" class="headerlink" title="如何入手熟悉一个项目？"></a>如何入手熟悉一个项目？</h3>从登录鉴权，请求封装，路由配置，组件封装，hooks 封装，状态管理，看一遍，梳理一遍，就完事了<h3 id="开发过程中遇到一些困难，或收到一些反馈，如何去解决问题"><a href="#开发过程中遇到一些困难，或收到一些反馈，如何去解决问题" class="headerlink" title="开发过程中遇到一些困难，或收到一些反馈，如何去解决问题"></a>开发过程中遇到一些困难，或收到一些反馈，如何去解决问题</h3><h3 id="上一个问题中提到首先需要复现-bug，那么如果不能复现-bug-怎么解决，比如用户说这个网页打不开了，你这个网页却打得开这种情况"><a href="#上一个问题中提到首先需要复现-bug，那么如果不能复现-bug-怎么解决，比如用户说这个网页打不开了，你这个网页却打得开这种情况" class="headerlink" title="上一个问题中提到首先需要复现 bug，那么如果不能复现 bug 怎么解决，比如用户说这个网页打不开了，你这个网页却打得开这种情况"></a>上一个问题中提到首先需要复现 bug，那么如果不能复现 bug 怎么解决，比如用户说这个网页打不开了，你这个网页却打得开这种情况</h3><h3 id="个人发展-职业-学习规划"><a href="#个人发展-职业-学习规划" class="headerlink" title="个人发展/职业/学习规划"></a>个人发展/职业/学习规划</h3>坚持走技术方向，加强技术深度，也希望拓宽方向，向大前端靠近。<h3 id="还有什么要问的"><a href="#还有什么要问的" class="headerlink" title="还有什么要问的"></a>还有什么要问的</h3>公司前后端团队人数<br>目前在使用什么技术栈，将来打算使用什么技术栈<br>平时需求是以怎样的形式给前端的<br>入职的话主要是做什么，产品上线了吗，公司对于这个产品和产品开发团队的发展规划是什么<br>工作进度是怎么管理的<br>期望薪资<br>外包的话询问是否是人力外包，人力外包&gt;项目外包</li>
</ol>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
